/** MathLive 0.91.2 */
    (function(global,factory){typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'],factory):(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.MathLive = {}));})(this, (function (exports) { 'use strict';
var MathLive = (() => {
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/mathlive.ts
  var mathlive_exports = {};
  __export(mathlive_exports, {
    MathfieldElement: () => MathfieldElement,
    autoRenderMathInElement: () => autoRenderMathInElement,
    convertAsciiMathToLatex: () => convertAsciiMathToLatex,
    convertLatexToAsciiMath: () => convertLatexToAsciiMath,
    convertLatexToMarkup: () => convertLatexToMarkup,
    convertLatexToMathMl: () => convertLatexToMathMl,
    convertLatexToSpeakableText: () => convertLatexToSpeakableText,
    globalMathLive: () => globalMathLive,
    makeSharedVirtualKeyboard: () => makeSharedVirtualKeyboard,
    renderMathInDocument: () => renderMathInDocument,
    renderMathInElement: () => renderMathInElement,
    serializeMathJsonToLatex: () => serializeMathJsonToLatex,
    validateLatex: () => validateLatex2,
    version: () => version
  });

  // src/common/types.ts
  function isArray(x) {
    return Array.isArray(x);
  }

  // src/editor/l10n-strings.ts
  var STRINGS = {
    en: {
      "keyboard.tooltip.functions": "Functions",
      "keyboard.tooltip.symbols": "Symbols",
      "keyboard.tooltip.greek": "Greek Letters",
      "keyboard.tooltip.command": "LaTeX Command Mode",
      "keyboard.tooltip.numeric": "Numeric",
      "keyboard.tooltip.alphabetic": "Roman Letters",
      "tooltip.copy to clipboard": "Copy to Clipboard",
      "tooltip.cut to clipboard": "Cut to Clipboard",
      "tooltip.paste from clipboard": "Paste from Clipboard",
      "tooltip.redo": "Redo",
      "tooltip.toggle virtual keyboard": "Toggle Virtual Keyboard",
      "tooltip.undo": "Undo",
      "menu.insert matrix": "Insert Matrix",
      "menu.insert vector": "Insert Vector",
      "submenu.array.matrix delimiters": "Matrix Delimiters",
      "menu.array.add row above": "Add Row After",
      "menu.array.add row below": "Add Row Before",
      "menu.array.add column after": "Add Column After",
      "menu.array.add column before": "Add Column Before",
      "menu.array.delete row": "Delete Row",
      "menu.array.delete rows": "Delete Selected Rows",
      "menu.array.delete column": "Delete Column",
      "menu.array.delete columns": "Delete Selected Columns",
      "submenu.array.insert separator": "Insert Separator",
      "menu.insert table": "Insert Table",
      "submenu.table style": "Table Style"
    },
    // Arabic
    ar: {
      "keyboard.tooltip.functions": "\u0645\u0647\u0627\u0645",
      "keyboard.tooltip.symbols": "\u062D\u0631\u0641 \u0627\u0648 \u0631\u0645\u0632",
      "keyboard.tooltip.greek": "\u062D\u0631\u0648\u0641 \u064A\u0648\u0646\u0627\u0646\u064A\u0629",
      "keyboard.tooltip.command": "\u062D\u0627\u0644\u0629 \u062A\u0644\u0642\u064A \u0627\u0644\u0623\u0648\u0627\u0645\u0631 \u0627\u0644\u0644\u0627\u062A\u0643",
      "keyboard.tooltip.numeric": "\u0627\u0644\u0631\u0642\u0645\u064A\u0629",
      "keyboard.tooltip.alphabetic": "\u0631\u0645\u0648\u0632 \u0627\u0644\u0627\u062D\u0631\u0641 \u0627\u0644\u0631\u0648\u0645\u0627\u0646\u064A\u0629",
      "tooltip.copy to clipboard": "\u0646\u0633\u062E \u0625\u0644\u0649 \u0627\u0644\u062D\u0627\u0641\u0638\u0629",
      "tooltip.redo": "\u0627\u0644\u0625\u0639\u0627\u062F\u0629",
      "tooltip.toggle virtual keyboard": "\u062A\u0628\u062F\u064A\u0644 \u0644\u0648\u062D\u0629 \u0627\u0644\u0645\u0641\u0627\u062A\u064A\u062D \u0627\u0644\u0625\u0641\u062A\u0631\u0627\u0636\u064A\u0629",
      "tooltip.undo": "\u0625\u0644\u063A\u0627\u0621",
      "menu.insert matrix": "\u0623\u062F\u062E\u0644 \u0627\u0644\u0645\u0635\u0641\u0648\u0641\u0629",
      "menu.insert vector": "\u0623\u062F\u062E\u0644 \u0645\u062A\u062C\u0647",
      "submenu.array.matrix delimiters": "\u0645\u062D\u062F\u062F\u0627\u062A \u0627\u0644\u0645\u0635\u0641\u0648\u0641\u0629",
      "menu.array.add row above": "\u0623\u0636\u0641 \u0635\u0641\u064B\u0627 \u0628\u0639\u062F \u0630\u0644\u0643",
      "menu.array.add row below": "\u0623\u0636\u0641 \u0627\u0644\u0635\u0641 \u0642\u0628\u0644",
      "menu.array.add column after": "\u0623\u0636\u0641 \u0627\u0644\u0639\u0645\u0648\u062F \u0628\u0639\u062F \u0630\u0644\u0643",
      "menu.array.add column before": "\u0623\u0636\u0641 \u0627\u0644\u0639\u0645\u0648\u062F \u0642\u0628\u0644",
      "menu.array.delete row": "\u0627\u062D\u0630\u0641 \u0635\u0641",
      "menu.array.delete rows": "\u062D\u0630\u0641 \u0627\u0644\u0635\u0641\u0648\u0641 \u0627\u0644\u0645\u062D\u062F\u062F\u0629",
      "menu.array.delete column": "\u062D\u0630\u0641 \u0627\u0644\u0639\u0645\u0648\u062F",
      "menu.array.delete columns": "\u062D\u0630\u0641 \u0627\u0644\u0623\u0639\u0645\u062F\u0629 \u0627\u0644\u0645\u062D\u062F\u062F\u0629",
      "submenu.array.insert separator": "\u0623\u062F\u062E\u0644 \u0641\u0627\u0635\u0644",
      "menu.insert table": "\u0625\u062F\u0631\u0627\u062C \u062C\u062F\u0648\u0644",
      "submenu.table style": "\u0646\u0645\u0637 \u0627\u0644\u062C\u062F\u0648\u0644"
    },
    //Bulgarian
    bg: {
      "keyboard.tooltip.functions": "\u0424\u0443\u043D\u043A\u0446\u0438\u0438",
      "keyboard.tooltip.symbols": "\u0421\u0438\u043C\u0432\u043E\u043B\u0438",
      "keyboard.tooltip.greek": "\u0413\u0440\u044A\u0446\u043A\u0438 \u0431\u0443\u043A\u0432\u0438",
      "keyboard.tooltip.command": "\u041A\u043E\u043C\u0430\u043D\u0434\u0435\u043D \u0440\u0435\u0436\u0438\u043C \u043D\u0430 \u043B\u0430\u0442\u0435\u043A\u0441",
      "keyboard.tooltip.numeric": "\u0427\u0438\u0441\u043B\u043E\u0432\u0438",
      "keyboard.tooltip.alphabetic": "\u0420\u0438\u043C\u0441\u043A\u0438 \u0431\u0443\u043A\u0432\u0438",
      "tooltip.copy to clipboard": "\u041A\u043E\u043F\u0438\u0440\u0430\u043D\u0435 \u0432 \u043A\u043B\u0438\u043F\u0431\u043E\u0440\u0434\u0430",
      "tooltip.redo": "\u041F\u043E\u0432\u0442\u043E\u0440\u043D\u043E",
      "tooltip.toggle virtual keyboard": "\u041F\u0440\u0435\u0432\u043A\u043B\u044E\u0447\u0432\u0430\u043D\u0435 \u043D\u0430 \u0432\u0438\u0440\u0442\u0443\u0430\u043B\u043D\u0430 \u043A\u043B\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0430",
      "tooltip.undo": "\u041E\u0442\u043C\u044F\u043D\u0430",
      "menu.insert matrix": "\u0412\u043C\u044A\u043A\u0432\u0430\u043D\u0435 \u043D\u0430 \u043C\u0430\u0442\u0440\u0438\u0446\u0430",
      "menu.insert vector": "\u0412\u043C\u044A\u043A\u0432\u0430\u043D\u0435 \u043D\u0430 \u0432\u0435\u043A\u0442\u043E\u0440",
      "submenu.array.matrix delimiters": "\u041C\u0430\u0442\u0440\u0438\u0447\u043D\u0438 \u0440\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u0438",
      "menu.array.add row above": "\u0414\u043E\u0431\u0430\u0432\u044F\u043D\u0435 \u043D\u0430 \u0440\u0435\u0434 \u0441\u043B\u0435\u0434",
      "menu.array.add row below": "\u0414\u043E\u0431\u0430\u0432\u044F\u043D\u0435 \u043D\u0430 \u0440\u0435\u0434 \u043F\u0440\u0435\u0434\u0438",
      "menu.array.add column after": "\u0414\u043E\u0431\u0430\u0432\u044F\u043D\u0435 \u043D\u0430 \u043A\u043E\u043B\u043E\u043D\u0430 \u0441\u043B\u0435\u0434",
      "menu.array.add column before": "\u0414\u043E\u0431\u0430\u0432\u044F\u043D\u0435 \u043D\u0430 \u043A\u043E\u043B\u043E\u043D\u0430 \u043F\u0440\u0435\u0434\u0438",
      "menu.array.delete row": "\u0418\u0437\u0442\u0440\u0438\u0432\u0430\u043D\u0435 \u043D\u0430 \u0440\u0435\u0434\u0430",
      "menu.array.delete rows": "\u0418\u0437\u0442\u0440\u0438\u0432\u0430\u043D\u0435 \u043D\u0430 \u0438\u0437\u0431\u0440\u0430\u043D\u0438\u0442\u0435 \u0440\u0435\u0434\u043E\u0432\u0435",
      "menu.array.delete column": "\u0418\u0437\u0442\u0440\u0438\u0432\u0430\u043D\u0435 \u043D\u0430 \u043A\u043E\u043B\u043E\u043D\u0430",
      "menu.array.delete columns": "\u0418\u0437\u0442\u0440\u0438\u0432\u0430\u043D\u0435 \u043D\u0430 \u0438\u0437\u0431\u0440\u0430\u043D\u0438\u0442\u0435 \u043A\u043E\u043B\u043E\u043D\u0438",
      "submenu.array.insert separator": "\u041F\u043E\u0441\u0442\u0430\u0432\u0435\u0442\u0435 \u0440\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B",
      "menu.insert table": "\u0412\u043C\u044A\u043A\u0432\u0430\u043D\u0435 \u043D\u0430 \u0442\u0430\u0431\u043B\u0438\u0446\u0430",
      "submenu.table style": "\u0422\u0430\u0431\u043B\u0438\u0447\u0435\u043D \u0441\u0442\u0438\u043B"
    },
    // Bosnian
    bs: {
      "keyboard.tooltip.functions": "Funkcije",
      "keyboard.tooltip.symbols": "Simboli",
      "keyboard.tooltip.greek": "Gr\u010Dka slova",
      "keyboard.tooltip.command": "LaTeX naredbeni na\u010Din",
      "keyboard.tooltip.numeric": "Numeri\u010Dki",
      "keyboard.tooltip.alphabetic": "Rimska slova",
      "tooltip.copy to clipboard": "Kopirati u clipboard",
      "tooltip.redo": "Ponovi",
      "tooltip.toggle virtual keyboard": "Uklju\u010Di / isklju\u010Di virtualnu tipkovnicu",
      "tooltip.undo": "Poni\u0161ti",
      "menu.insert matrix": "Umetni matricu",
      "menu.insert vector": "Umetni vektor",
      "submenu.array.matrix delimiters": "Matri\u010Dni razdjelnici",
      "menu.array.add row above": "Dodaj redak nakon",
      "menu.array.add row below": "Dodaj red prije",
      "menu.array.add column after": "Dodaj stupac nakon",
      "menu.array.add column before": "Dodaj stupac prije",
      "menu.array.delete row": "Izbri\u0161i red",
      "menu.array.delete rows": "Izbri\u0161i odabrane redove",
      "menu.array.delete column": "Izbri\u0161i stupac",
      "menu.array.delete columns": "Izbri\u0161i odabrane stupce",
      "submenu.array.insert separator": "Umetni separator",
      "menu.insert table": "Ubaci tabelu",
      "submenu.table style": "Stil tabele"
    },
    // Czech
    cs: {
      "keyboard.tooltip.functions": "Funkce",
      "keyboard.tooltip.symbols": "Symboly",
      "keyboard.tooltip.greek": "\u0158eck\xE9 dopisy",
      "keyboard.tooltip.command": "P\u0159\xEDkazov\xFD re\u017Eim LaTeX",
      "keyboard.tooltip.numeric": "\u010C\xEDseln\xE9",
      "keyboard.tooltip.alphabetic": "\u0158\xEDmsk\xE9 dopisy",
      "tooltip.copy to clipboard": "Zkop\xEDrovat do schr\xE1nky",
      "tooltip.redo": "P\u0159ed\u011Blat",
      "tooltip.toggle virtual keyboard": "P\u0159epnout virtu\xE1ln\xED kl\xE1vesnici",
      "tooltip.undo": "Vr\xE1tit",
      "menu.insert matrix": "Vlo\u017Ete matici",
      "menu.insert vector": "Vlo\u017Eit vektor",
      "submenu.array.matrix delimiters": "Odd\u011Blova\u010De matic",
      "menu.array.add row above": "P\u0159idat \u0159\xE1dek za",
      "menu.array.add row below": "P\u0159idat \u0159\xE1dek p\u0159ed",
      "menu.array.add column after": "P\u0159idat sloupec za",
      "menu.array.add column before": "P\u0159idat sloupec d\u0159\xEDve",
      "menu.array.delete row": "Odstranit \u0159\xE1dek",
      "menu.array.delete rows": "Odstranit vybran\xE9 \u0159\xE1dky",
      "menu.array.delete column": "Odstranit sloupec",
      "menu.array.delete columns": "Odstranit vybran\xE9 sloupce",
      "submenu.array.insert separator": "Vlo\u017Ete odd\u011Blova\u010D",
      "menu.insert table": "Vlo\u017Eit tabulku",
      "submenu.table style": "Styl tabulky"
    },
    // Dannish
    da: {
      "keyboard.tooltip.functions": "Funktioner",
      "keyboard.tooltip.symbols": "Symboler",
      "keyboard.tooltip.greek": "Gr\xE6ske bogstaver",
      "keyboard.tooltip.command": "LaTeX kommandotilstand",
      "keyboard.tooltip.numeric": "Numerisk",
      "keyboard.tooltip.alphabetic": "Romerske breve",
      "tooltip.copy to clipboard": "Kopier til udklipsholder",
      "tooltip.redo": "Gentag igen",
      "tooltip.toggle virtual keyboard": "Skift virtuelt tastatur",
      "tooltip.undo": "Fortryd",
      "menu.insert matrix": "Inds\xE6t matrix",
      "menu.insert vector": "Inds\xE6t vektor",
      "submenu.array.matrix delimiters": "Matrixafgr\xE6nsere",
      "menu.array.add row above": "Tilf\xF8j r\xE6kke efter",
      "menu.array.add row below": "Tilf\xF8j r\xE6kke f\xF8r",
      "menu.array.add column after": "Tilf\xF8j kolonne efter",
      "menu.array.add column before": "Tilf\xF8j kolonne f\xF8r",
      "menu.array.delete row": "Slet r\xE6kke",
      "menu.array.delete rows": "Slet valgte r\xE6kker",
      "menu.array.delete column": "Slet kolonne",
      "menu.array.delete columns": "Slet valgte kolonner",
      "submenu.array.insert separator": "Inds\xE6t separator",
      "menu.insert table": "Inds\xE6t tabel",
      "submenu.table style": "Tabelstil"
    },
    // German
    de: {
      "keyboard.tooltip.functions": "Funktionen",
      "keyboard.tooltip.symbols": "Symbole",
      "keyboard.tooltip.greek": "Griechische Buchstaben",
      "keyboard.tooltip.command": "LaTeX-Befehlsmodus",
      "keyboard.tooltip.numeric": "Numerisch",
      "keyboard.tooltip.alphabetic": "R\xF6mische Buchstaben",
      "tooltip.copy to clipboard": "In die Zwischenablage kopieren",
      "tooltip.redo": "Wiederholen",
      "tooltip.toggle virtual keyboard": "Virtuelle Tastatur umschalten",
      "tooltip.undo": "Widerrufen",
      "menu.insert matrix": "Matrix einf\xFCgen",
      "menu.insert vector": "Vektor einf\xFCgen",
      "submenu.array.matrix delimiters": "Matrixtrennzeichen",
      "menu.array.add row above": "Zeile hinzuf\xFCgen nach",
      "menu.array.add row below": "Zeile hinzuf\xFCgen vor",
      "menu.array.add column after": "Spalte hinzuf\xFCgen nach",
      "menu.array.add column before": "Spalte hinzuf\xFCgen vor",
      "menu.array.delete row": "Zeile l\xF6schen",
      "menu.array.delete rows": "Ausgew\xE4hlte Zeilen l\xF6schen",
      "menu.array.delete column": "Spalte l\xF6schen",
      "menu.array.delete columns": "Ausgew\xE4hlte Spalten l\xF6schen",
      "submenu.array.insert separator": "Trennzeichen einf\xFCgen",
      "menu.insert table": "Tabelle einf\xFCgen",
      "submenu.table style": "Tabellenstil"
    },
    // Greek
    el: {
      "keyboard.tooltip.functions": "\u03C3\u03C5\u03BD\u03B1\u03C1\u03C4\u03AE\u03C3\u03B5\u03B9\u03C2",
      "keyboard.tooltip.symbols": "\u03C3\u03CD\u03BC\u03B2\u03BF\u03BB\u03B1",
      "keyboard.tooltip.greek": "\u03B5\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC \u03B3\u03C1\u03AC\u03BC\u03BC\u03B1\u03C4\u03B1",
      "keyboard.tooltip.command": "\u039B\u03B5\u03B9\u03C4\u03BF\u03C5\u03C1\u03B3\u03AF\u03B1 \u03B5\u03BD\u03C4\u03BF\u03BB\u03CE\u03BD LaTeX",
      "keyboard.tooltip.numeric": "\u0391\u03C1\u03B9\u03B8\u03BC\u03B7\u03C4\u03B9\u03BA\u03CC\u03C2",
      "keyboard.tooltip.alphabetic": "\u03A1\u03C9\u03BC\u03B1\u03CA\u03BA\u03AC \u03B3\u03C1\u03AC\u03BC\u03BC\u03B1\u03C4\u03B1",
      "tooltip.copy to clipboard": "\u0391\u03BD\u03C4\u03B9\u03B3\u03C1\u03B1\u03C6\u03AE \u03C3\u03C4\u03BF \u03C0\u03C1\u03CC\u03C7\u03B5\u03B9\u03C1\u03BF",
      "tooltip.redo": "\u039E\u03B1\u03BD\u03B1\u03BA\u03AC\u03BD\u03C9",
      "tooltip.toggle virtual keyboard": "\u0395\u03BD\u03B1\u03BB\u03BB\u03B1\u03B3\u03AE \u03B5\u03B9\u03BA\u03BF\u03BD\u03B9\u03BA\u03BF\u03CD \u03C0\u03BB\u03B7\u03BA\u03C4\u03C1\u03BF\u03BB\u03BF\u03B3\u03AF\u03BF\u03C5",
      "tooltip.undo": "\u039E\u03B5\u03BA\u03AC\u03BD\u03C9",
      "menu.insert matrix": "\u0395\u03B9\u03C3\u03B1\u03B3\u03C9\u03B3\u03AE Matrix",
      "menu.insert vector": "\u0395\u03B9\u03C3\u03B1\u03B3\u03C9\u03B3\u03AE \u03B4\u03B9\u03B1\u03BD\u03CD\u03C3\u03BC\u03B1\u03C4\u03BF\u03C2",
      "submenu.array.matrix delimiters": "\u039F\u03C1\u03B9\u03BF\u03B8\u03AD\u03C4\u03B5\u03C2 Matrix",
      "menu.array.add row above": "\u03A0\u03C1\u03BF\u03C3\u03B8\u03AE\u03BA\u03B7 \u03C3\u03B5\u03B9\u03C1\u03AC\u03C2 \u03BC\u03B5\u03C4\u03AC",
      "menu.array.add row below": "\u03A0\u03C1\u03BF\u03C3\u03B8\u03AE\u03BA\u03B7 \u03C3\u03B5\u03B9\u03C1\u03AC\u03C2 \u03C0\u03C1\u03B9\u03BD",
      "menu.array.add column after": "\u03A0\u03C1\u03BF\u03C3\u03B8\u03AE\u03BA\u03B7 \u03C3\u03C4\u03AE\u03BB\u03B7\u03C2 \u03BC\u03B5\u03C4\u03AC",
      "menu.array.add column before": "\u03A0\u03C1\u03BF\u03C3\u03B8\u03AE\u03BA\u03B7 \u03C3\u03C4\u03AE\u03BB\u03B7\u03C2 \u03C0\u03C1\u03B9\u03BD",
      "menu.array.delete row": "\u0394\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE \u03C3\u03B5\u03B9\u03C1\u03AC\u03C2",
      "menu.array.delete rows": "\u0394\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE \u03B5\u03C0\u03B9\u03BB\u03B5\u03B3\u03BC\u03AD\u03BD\u03C9\u03BD \u03C3\u03B5\u03B9\u03C1\u03CE\u03BD",
      "menu.array.delete column": "\u0394\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE \u03C3\u03C4\u03AE\u03BB\u03B7\u03C2",
      "menu.array.delete columns": "\u0394\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE \u03B5\u03C0\u03B9\u03BB\u03B5\u03B3\u03BC\u03AD\u03BD\u03C9\u03BD \u03C3\u03C4\u03B7\u03BB\u03CE\u03BD",
      "submenu.array.insert separator": "\u0395\u03B9\u03C3\u03B1\u03B3\u03C9\u03B3\u03AE \u03B4\u03B9\u03B1\u03C7\u03C9\u03C1\u03B9\u03C3\u03C4\u03B9\u03BA\u03BF\u03CD",
      "menu.insert table": "\u0395\u03B9\u03C3\u03B1\u03B3\u03C9\u03B3\u03AE \u03C0\u03AF\u03BD\u03B1\u03BA\u03B1",
      "submenu.table style": "\u03A3\u03C4\u03C5\u03BB \u03C0\u03AF\u03BD\u03B1\u03BA\u03B1"
    },
    // Spanish
    es: {
      "keyboard.tooltip.functions": "Funciones",
      "keyboard.tooltip.symbols": "S\xEDmbolos",
      "keyboard.tooltip.greek": "Letras griegas",
      "keyboard.tooltip.command": "Modo Comando LaTeX",
      "keyboard.tooltip.numeric": "Num\xE9rico",
      "keyboard.tooltip.alphabetic": "Letras romanas",
      "tooltip.copy to clipboard": "Copiar al portapapeles",
      "tooltip.redo": "Rehacer",
      "tooltip.toggle virtual keyboard": "Alternar teclado virtual",
      "tooltip.undo": "Deshacer",
      "menu.insert matrix": "A\xF1adir Matriz",
      "menu.insert vector": "A\xF1adir vector",
      "submenu.array.matrix delimiters": "Delimitadores de Matriz",
      "menu.array.add row above": "A\xF1adir L\xEDnea Antes",
      "menu.array.add row below": "A\xF1adir L\xEDnea Despues",
      "menu.array.add column after": "A\xF1adir Columna Despues",
      "menu.array.add column before": "A\xF1adir Columna Antes",
      "menu.array.delete row": "Borrar L\xEDnea",
      "menu.array.delete rows": "Borrar L\xEDneas Seleccionadas",
      "menu.array.delete column": "Borrar Columna",
      "menu.array.delete columns": "Borrar Columnas Seleccionadas",
      "submenu.array.insert separator": "Insertar un Separador",
      "menu.insert table": "Insertar Tabla",
      "submenu.table style": "Estilo de Tabla"
    },
    // Estonian
    et: {
      "keyboard.tooltip.functions": "Funktsioonid",
      "keyboard.tooltip.symbols": "S\xFCmbolid",
      "keyboard.tooltip.greek": "Kreeka kirjad",
      "keyboard.tooltip.command": "LaTeXi k\xE4sure\u017Eiim",
      "keyboard.tooltip.numeric": "Numbriline",
      "keyboard.tooltip.alphabetic": "Rooma kirjad",
      "tooltip.copy to clipboard": "Kopeerida l\xF5ikelauale",
      "tooltip.redo": "Tee uuesti",
      "tooltip.toggle virtual keyboard": "L\xFClitage sisse virtuaalne klaviatuur",
      "tooltip.undo": "V\xF5ta tagasi",
      "menu.insert matrix": "Sisesta maatriks",
      "menu.insert vector": "Sisesta vektor",
      "submenu.array.matrix delimiters": "Maatriksi eraldajad",
      "menu.array.add row above": "Lisa rida p\xE4rast",
      "menu.array.add row below": "Lisa rida enne",
      "menu.array.add column after": "Lisa veerg p\xE4rast",
      "menu.array.add column before": "Lisa veerg enne",
      "menu.array.delete row": "Kustuta rida",
      "menu.array.delete rows": "Kustuta valitud read",
      "menu.array.delete column": "Kustuta veerg",
      "menu.array.delete columns": "Kustuta valitud veerud",
      "submenu.array.insert separator": "Sisestage eraldaja",
      "menu.insert table": "Sisesta tabeli",
      "submenu.table style": "Tabeli stiilis"
    },
    // Farsi
    fa: {
      "keyboard.tooltip.functions": "\u062A\u0648\u0627\u0628\u0639",
      "keyboard.tooltip.symbols": "\u0646\u0645\u0627\u062F\u0647\u0627",
      "keyboard.tooltip.greek": "\u062D\u0631\u0648\u0641 \u06CC\u0648\u0646\u0627\u0646\u06CC",
      "keyboard.tooltip.command": "\u062D\u0627\u0644\u062A \u062F\u0633\u062A\u0648\u0631 \u0644\u0627\u062A\u06A9",
      "keyboard.tooltip.numeric": "\u0639\u062F\u062F\u06CC",
      "keyboard.tooltip.alphabetic": "\u062D\u0631\u0648\u0641 \u0631\u0648\u0645\u06CC",
      "tooltip.copy to clipboard": "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E\u0628\u0648\u0631\u062F",
      "tooltip.redo": "\u0628\u0627\u0632\u06AF\u0634\u062A \u0628\u0647 \u0628\u0639\u062F",
      "tooltip.toggle virtual keyboard": "\u0646\u0645\u0627\u06CC\u0634/\u0646\u0647\u0641\u062A\u0646 \u06A9\u06CC\u0628\u0648\u0631\u062F \u0645\u062C\u0627\u0632\u06CC",
      "tooltip.undo": "\u0628\u0627\u0632\u06AF\u0634\u062A \u0628\u0647 \u0642\u0628\u0644",
      "menu.insert matrix": "\u0645\u0627\u062A\u0631\u06CC\u0633 \u0631\u0627 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F",
      "menu.insert vector": "\u062F\u0631\u062C \u0628\u0631\u062F\u0627\u0631",
      "submenu.array.matrix delimiters": "\u0645\u0631\u0632\u0647\u0627\u06CC \u0645\u0627\u062A\u0631\u06CC\u0633",
      "menu.array.add row above": "\u0628\u0639\u062F \u0627\u0632 \u0622\u0646 \u0631\u062F\u06CC\u0641 \u0627\u0636\u0627\u0641\u0647 \u06A9\u0646\u06CC\u062F",
      "menu.array.add row below": "\u0631\u062F\u06CC\u0641 \u0631\u0627 \u0642\u0628\u0644 \u0627\u0636\u0627\u0641\u0647 \u06A9\u0646\u06CC\u062F",
      "menu.array.add column after": "\u0627\u0636\u0627\u0641\u0647 \u06A9\u0631\u062F\u0646 \u0633\u062A\u0648\u0646 \u0628\u0639\u062F",
      "menu.array.add column before": "\u0633\u062A\u0648\u0646 \u0642\u0628\u0644 \u0631\u0627 \u0627\u0636\u0627\u0641\u0647 \u06A9\u0646\u06CC\u062F",
      "menu.array.delete row": "\u0631\u062F\u06CC\u0641 \u0631\u0627 \u062D\u0630\u0641 \u06A9\u0646\u06CC\u062F",
      "menu.array.delete rows": "\u0631\u062F\u06CC\u0641 \u0647\u0627\u06CC \u0627\u0646\u062A\u062E\u0627\u0628 \u0634\u062F\u0647 \u0631\u0627 \u062D\u0630\u0641 \u06A9\u0646\u06CC\u062F",
      "menu.array.delete column": "\u062D\u0630\u0641 \u0633\u062A\u0648\u0646",
      "menu.array.delete columns": "\u0633\u062A\u0648\u0646 \u0647\u0627\u06CC \u0627\u0646\u062A\u062E\u0627\u0628 \u0634\u062F\u0647 \u0631\u0627 \u062D\u0630\u0641 \u06A9\u0646\u06CC\u062F",
      "submenu.array.insert separator": "\u062F\u0631\u062C \u062C\u062F\u0627 \u06A9\u0646\u0646\u062F\u0647",
      "menu.insert table": "\u0642\u0631\u0627\u0631 \u062F\u0627\u062F\u0646 \u062C\u062F\u0648\u0644",
      "submenu.table style": "\u0633\u0628\u06A9 \u0645\u06CC\u0632"
    },
    // Finnish
    fi: {
      "keyboard.tooltip.functions": "Toiminnot",
      "keyboard.tooltip.symbols": "Symbolit",
      "keyboard.tooltip.greek": "Kreikkalaiset kirjeet",
      "keyboard.tooltip.command": "LaTeX-komentotila",
      "keyboard.tooltip.numeric": "Numeerinen",
      "keyboard.tooltip.alphabetic": "Roomalaiset kirjeet",
      "tooltip.copy to clipboard": "Kopioi leikep\xF6yd\xE4lle",
      "tooltip.redo": "Tee uudelleen",
      "tooltip.toggle virtual keyboard": "Vaihda virtuaalin\xE4pp\xE4imist\xF6",
      "tooltip.undo": "Kumoa",
      "menu.insert matrix": "Lis\xE4\xE4 matriisi",
      "menu.insert vector": "Lis\xE4\xE4 vektori",
      "submenu.array.matrix delimiters": "Matriisin erottimet",
      "menu.array.add row above": "Lis\xE4\xE4 rivi j\xE4lkeen",
      "menu.array.add row below": "Lis\xE4\xE4 rivi ennen",
      "menu.array.add column after": "Lis\xE4\xE4 sarake j\xE4lkeen",
      "menu.array.add column before": "Lis\xE4\xE4 sarake ennen",
      "menu.array.delete row": "Poista rivi",
      "menu.array.delete rows": "Poista valitut rivit",
      "menu.array.delete column": "Poista sarake",
      "menu.array.delete columns": "Poista valitut sarakkeet",
      "submenu.array.insert separator": "Aseta erotin",
      "menu.insert table": "Lis\xE4\xE4 taulukko",
      "submenu.table style": "Taulukon tyyli"
    },
    // French
    fr: {
      "keyboard.tooltip.functions": "Fonctions",
      "keyboard.tooltip.symbols": "Symboles",
      "keyboard.tooltip.greek": "Lettres grecques",
      "keyboard.tooltip.command": "Mode de commandes LaTeX",
      "keyboard.tooltip.numeric": "Num\xE9rique",
      "keyboard.tooltip.alphabetic": "Lettres romaines",
      "tooltip.copy to clipboard": "Copier dans le presse-papiers",
      "tooltip.redo": "R\xE9tablir",
      "tooltip.toggle virtual keyboard": "Afficher/Masquer le clavier virtuel",
      "tooltip.undo": "Annuler",
      "menu.insert matrix": "Ins\xE9rer une Matrice",
      "menu.insert vector": "Ins\xE9rer un Vecteur",
      "submenu.array.matrix delimiters": "D\xE9limiteurs de la Matrice",
      "menu.array.add row above": "Ajouter une Ligne Avant",
      "menu.array.add row below": "Ajouter une Ligne Apr\xE8s",
      "menu.array.add column before": "Ajouter une Colonne Avant",
      "menu.array.add column after": "Ajouter une Colonne Apr\xE8s",
      "menu.array.delete row": "Enlever une Ligne",
      "menu.array.delete rows": "Enlever les Lignes S\xE9lection\xE9es",
      "menu.array.delete column": "Enlever une Colone",
      "menu.array.delete columns": "Enlever les Colonnes S\xE9lection\xE9es",
      "submenu.array.insert separator": "Ins\xE9rer un S\xE9parateur",
      "menu.insert table": "Ins\xE9rer une Table",
      "submenu.table style": "Style de la  Table"
    },
    // Irish
    ga: {
      "keyboard.tooltip.functions": "Feidhmeanna",
      "keyboard.tooltip.symbols": "Siombail\xED",
      "keyboard.tooltip.greek": "Litreacha na Gr\xE9ige",
      "keyboard.tooltip.command": "M\xF3d Ord\xFA LaTeX",
      "keyboard.tooltip.numeric": "Uimhri\xFAil",
      "keyboard.tooltip.alphabetic": "Litreacha R\xF3mh\xE1nacha",
      "tooltip.copy to clipboard": "C\xF3ipe\xE1il chuig an Ghearrthaisce",
      "tooltip.redo": "Athdh\xE9an",
      "tooltip.toggle virtual keyboard": "M\xE9archl\xE1ir F\xEDor\xFAil a Fh\xE1il",
      "tooltip.undo": "Cealaigh",
      "menu.insert matrix": "Cuir isteach Maitr\xEDs",
      "menu.insert vector": "Cuir isteach Veicteoir",
      "submenu.array.matrix delimiters": "Delimiters Maitr\xEDs",
      "menu.array.add row above": "Cuir Rae Tar \xE9is",
      "menu.array.add row below": "Cuir Rae Roimh",
      "menu.array.add column after": "Cuir Col\xFAn Tar \xE9is",
      "menu.array.add column before": "Cuir Col\xFAn Roimh",
      "menu.array.delete row": "Scrios Rae",
      "menu.array.delete rows": "Scrios Sraitheanna Roghnaithe",
      "menu.array.delete column": "Scrios Col\xFAn",
      "menu.array.delete columns": "Scrios Col\xFAin Roghnaithe",
      "submenu.array.insert separator": "Cuir Deighilteoir isteach",
      "menu.insert table": "Ions\xE1igh T\xE1bla",
      "submenu.table style": "St\xEDl T\xE1bla"
    },
    // Hebrew (Israel)
    he: {
      "keyboard.tooltip.functions": "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D5\u05EA",
      "keyboard.tooltip.symbols": "\u05E1\u05DE\u05DC\u05D9\u05DD",
      "keyboard.tooltip.greek": "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05D9\u05D5\u05D5\u05E0\u05D9\u05D5\u05EA",
      "keyboard.tooltip.command": "\u05DE\u05E6\u05D1 \u05E4\u05E7\u05D5\u05D3\u05D4 \u05DC\u05D8\u05E7\u05E1",
      "keyboard.tooltip.numeric": "\u05DE\u05E1\u05E4\u05E8\u05D9",
      "keyboard.tooltip.alphabetic": "\u05DE\u05DB\u05EA\u05D1\u05D9\u05DD \u05E8\u05D5\u05DE\u05D9\u05D9\u05DD",
      "tooltip.copy to clipboard": "\u05D4\u05E2\u05EA\u05E7 \u05DC\u05DC\u05D5\u05D7",
      "tooltip.redo": "\u05DC\u05B7\u05E2\u05B2\u05E9\u05C2\u05D5\u05B9\u05EA \u05E9\u05C1\u05D5\u05BC\u05D1",
      "tooltip.toggle virtual keyboard": "\u05D4\u05D7\u05DC\u05E3 \u05D0\u05EA \u05D4\u05DE\u05E7\u05DC\u05D3\u05EA \u05D4\u05D5\u05D5\u05D9\u05E8\u05D8\u05D5\u05D0\u05DC\u05D9\u05EA",
      "tooltip.undo": "\u05DC\u05D1\u05D8\u05DC",
      "menu.insert matrix": "\u05D4\u05DB\u05E0\u05E1 \u05DE\u05D8\u05E8\u05D9\u05E7\u05E1",
      "menu.insert vector": "\u05D4\u05DB\u05E0\u05E1 \u05D5\u05E7\u05D8\u05D5\u05E8",
      "submenu.array.matrix delimiters": "\u05DE\u05E4\u05E8\u05D9\u05D3\u05D9 \u05DE\u05D8\u05E8\u05D9\u05E7\u05E1",
      "menu.array.add row above": "\u05D4\u05D5\u05E1\u05E3 \u05E9\u05D5\u05E8\u05D4 \u05D0\u05D7\u05E8\u05D9",
      "menu.array.add row below": "\u05D4\u05D5\u05E1\u05E3 \u05E9\u05D5\u05E8\u05D4 \u05DC\u05E4\u05E0\u05D9",
      "menu.array.add column after": "\u05D4\u05D5\u05E1\u05E3 \u05E2\u05DE\u05D5\u05D3\u05D4 \u05D0\u05D7\u05E8\u05D9",
      "menu.array.add column before": "\u05D4\u05D5\u05E1\u05E3 \u05E2\u05DE\u05D5\u05D3\u05D4 \u05DC\u05E4\u05E0\u05D9",
      "menu.array.delete row": "\u05DE\u05D7\u05E7 \u05E9\u05D5\u05E8\u05D4",
      "menu.array.delete rows": "\u05DE\u05D7\u05E7 \u05E9\u05D5\u05E8\u05D5\u05EA \u05E9\u05E0\u05D1\u05D7\u05E8\u05D5",
      "menu.array.delete column": "\u05DE\u05D7\u05E7 \u05E2\u05DE\u05D5\u05D3\u05D4",
      "menu.array.delete columns": "\u05DE\u05D7\u05E7 \u05E2\u05DE\u05D5\u05D3\u05D5\u05EA \u05E9\u05E0\u05D1\u05D7\u05E8\u05D5",
      "submenu.array.insert separator": "\u05D4\u05DB\u05E0\u05E1 \u05DE\u05E4\u05E8\u05D9\u05D3",
      "menu.insert table": "\u05D4\u05DB\u05E0\u05E1 \u05D8\u05D1\u05DC\u05D4",
      "submenu.table style": "\u05D8\u05D1\u05DC\u05D4 \u05E1\u05B4\u05D2\u05B0\u05E0\u05D5\u05B9\u05DF"
    },
    // Croatian
    hr: {
      "keyboard.tooltip.functions": "Funkcije",
      "keyboard.tooltip.symbols": "Simboli",
      "keyboard.tooltip.greek": "Gr\u010Dka slova",
      "keyboard.tooltip.command": "LaTeX naredbeni na\u010Din",
      "keyboard.tooltip.numeric": "Numeri\u010Dki",
      "keyboard.tooltip.alphabetic": "Rimska slova",
      "tooltip.copy to clipboard": "Kopirati u me\u0111uspremnik",
      "tooltip.redo": "Ponovi",
      "tooltip.toggle virtual keyboard": "Uklju\u010Di / isklju\u010Di virtualnu tipkovnicu",
      "tooltip.undo": "Poni\u0161ti",
      "menu.insert matrix": "Umetni matricu",
      "menu.insert vector": "Umetni vektor",
      "submenu.array.matrix delimiters": "Matri\u010Dni razdjelnici",
      "menu.array.add row above": "Dodaj redak nakon",
      "menu.array.add row below": "Dodaj redak prije",
      "menu.array.add column after": "Dodaj stupac nakon",
      "menu.array.add column before": "Dodaj stupac prije",
      "menu.array.delete row": "Izbri\u0161i redak",
      "menu.array.delete rows": "Izbri\u0161i odabrane retke",
      "menu.array.delete column": "Izbri\u0161i stupac",
      "menu.array.delete columns": "Izbri\u0161i odabrane stupce",
      "submenu.array.insert separator": "Umetni separator",
      "menu.insert table": "Umetni tablicu",
      "submenu.table style": "Stil tabele"
    },
    /// Indonesian
    id: {
      "keyboard.tooltip.functions": "Fungsi",
      "keyboard.tooltip.symbols": "Simbol",
      "keyboard.tooltip.greek": "Huruf Yunani",
      "keyboard.tooltip.command": "Mode Perintah LaTeX",
      "keyboard.tooltip.numeric": "Numerik",
      "keyboard.tooltip.alphabetic": "Surat Romawi",
      "tooltip.copy to clipboard": "Menyalin ke clipboard",
      "tooltip.redo": "Mengulangi",
      "tooltip.toggle virtual keyboard": "Alihkan Keyboard Virtual",
      "tooltip.undo": "Membuka",
      "menu.insert matrix": "Sisipkan Matriks",
      "menu.insert vector": "Sisipkan Vektor",
      "submenu.array.matrix delimiters": "Pembatas Matriks",
      "menu.array.add row above": "Tambahkan Baris Setelah",
      "menu.array.add row below": "Tambahkan Baris Sebelumnya",
      "menu.array.add column after": "Tambahkan Kolom Setelah",
      "menu.array.add column before": "Tambahkan Kolom Sebelumnya",
      "menu.array.delete row": "Hapus Baris",
      "menu.array.delete rows": "Hapus Baris yang Dipilih",
      "menu.array.delete column": "Hapus Kolom",
      "menu.array.delete columns": "Hapus Kolom yang Dipilih",
      "submenu.array.insert separator": "Sisipkan Pemisah",
      "menu.insert table": "Sisipkan Tabel",
      "submenu.table style": "Gaya Tabel"
    },
    // Hindi (India)
    hi: {
      "keyboard.tooltip.functions": "\u0915\u093E\u0930\u094D\u092F\u094B\u0902",
      "keyboard.tooltip.symbols": "\u092A\u094D\u0930\u0924\u0940\u0915",
      "keyboard.tooltip.greek": "\u0917\u094D\u0930\u0940\u0915 \u0905\u0915\u094D\u0937\u0930",
      "keyboard.tooltip.command": "\u0932\u093E\u091F\u0947\u0915\u094D\u0938 \u0915\u092E\u093E\u0902\u0921 \u092E\u094B\u0921",
      "keyboard.tooltip.numeric": "\u0938\u0902\u0916\u094D\u092F\u093E\u0924\u094D\u092E\u0915",
      "keyboard.tooltip.alphabetic": "\u0930\u094B\u092E\u0928 \u092A\u0924\u094D\u0930",
      "tooltip.copy to clipboard": "\u0915\u094D\u0932\u093F\u092A\u092C\u094B\u0930\u094D\u0921 \u092A\u0930 \u0915\u0949\u092A\u0940 \u0915\u0930\u0947\u0902",
      "tooltip.redo": "\u092B\u093F\u0930 \u0938\u0947 \u0915\u0930\u0947\u0902",
      "tooltip.toggle virtual keyboard": "\u0935\u0930\u094D\u091A\u0941\u0905\u0932 \u0915\u0940\u092C\u094B\u0930\u094D\u0921 \u091F\u0949\u0917\u0932 \u0915\u0930\u0947\u0902",
      "tooltip.undo": "\u092A\u0942\u0930\u094D\u0935\u0935\u0924",
      "menu.insert matrix": "\u092E\u0948\u091F\u094D\u0930\u093F\u0915\u094D\u0938 \u0921\u093E\u0932\u0947\u0902",
      "menu.insert vector": "\u0935\u0947\u0915\u094D\u091F\u0930 \u0921\u093E\u0932\u0947\u0902",
      "submenu.array.matrix delimiters": "\u092E\u0948\u091F\u094D\u0930\u093F\u0915\u094D\u0938 \u0938\u0940\u092E\u093E\u0902\u0915\u0915",
      "menu.array.add row above": "\u092C\u093E\u0926 \u092E\u0947\u0902 \u092A\u0902\u0915\u094D\u0924\u093F \u091C\u094B\u0921\u093C\u0947\u0902",
      "menu.array.add row below": "\u092A\u0939\u0932\u0947 \u092A\u0902\u0915\u094D\u0924\u093F \u091C\u094B\u0921\u093C\u0947\u0902",
      "menu.array.add column after": "\u092C\u093E\u0926 \u092E\u0947\u0902 \u0915\u0949\u0932\u092E \u091C\u094B\u0921\u093C\u0947\u0902",
      "menu.array.add column before": "\u092A\u0939\u0932\u0947 \u0915\u0949\u0932\u092E \u091C\u094B\u0921\u093C\u0947\u0902",
      "menu.array.delete row": "\u092A\u0902\u0915\u094D\u0924\u093F \u0915\u094B \u0939\u091F\u093E\u090F\u0902",
      "menu.array.delete rows": "\u091A\u092F\u0928\u093F\u0924 \u092A\u0902\u0915\u094D\u0924\u093F\u092F\u094B\u0902 \u0915\u094B \u0939\u091F\u093E\u090F\u0902",
      "menu.array.delete column": "\u0915\u0949\u0932\u092E \u0939\u091F\u093E\u090F\u0902",
      "menu.array.delete columns": "\u091A\u092F\u0928\u093F\u0924 \u0915\u0949\u0932\u092E \u0939\u091F\u093E\u090F\u0902",
      "submenu.array.insert separator": "\u0935\u093F\u092D\u093E\u091C\u0915 \u0921\u093E\u0932\u0947\u0902",
      "menu.insert table": "\u091F\u0947\u092C\u0932 \u0907\u0902\u0938\u0930\u094D\u091F \u0915\u0930\u0947\u0902",
      "submenu.table style": "\u091F\u0947\u092C\u0932 \u0938\u094D\u091F\u093E\u0907\u0932"
    },
    // Hungarian
    hu: {
      "keyboard.tooltip.functions": "Funkci\xF3k",
      "keyboard.tooltip.symbols": "Szimb\xF3lumok",
      "keyboard.tooltip.greek": "G\xF6r\xF6g levelek",
      "keyboard.tooltip.command": "LaTeX Parancs m\xF3d",
      "keyboard.tooltip.numeric": "Numerikus",
      "keyboard.tooltip.alphabetic": "R\xF3mai levelek",
      "tooltip.copy to clipboard": "M\xE1solja a v\xE1g\xF3lapra",
      "tooltip.redo": "\xDAjra",
      "tooltip.toggle virtual keyboard": "V\xE1lt\xE1s a virtu\xE1lis billenty\u0171zetre",
      "tooltip.undo": "Visszavon\xE1s",
      "menu.insert matrix": "Helyezze be a M\xE1trixot",
      "menu.insert vector": "Vektor besz\xFAr\xE1sa",
      "submenu.array.matrix delimiters": "M\xE1trixhat\xE1rol\xF3k",
      "menu.array.add row above": "Sor hozz\xE1ad\xE1sa ut\xE1n",
      "menu.array.add row below": "Add Add Sor el\u0151tt",
      "menu.array.add column after": "Oszlop hozz\xE1ad\xE1sa ut\xE1n",
      "menu.array.add column before": "Add oszlop el\u0151tt",
      "menu.array.delete row": "Sor t\xF6rl\xE9se",
      "menu.array.delete rows": "Kijel\xF6lt sorok t\xF6rl\xE9se",
      "menu.array.delete column": "Oszlop t\xF6rl\xE9se",
      "menu.array.delete columns": "A kijel\xF6lt oszlopok t\xF6rl\xE9se",
      "submenu.array.insert separator": "Helyezze be az elv\xE1laszt\xF3t",
      "menu.insert table": "Helyezze be a t\xE1bl\xE1zatot",
      "submenu.table style": "T\xE1bl\xE1zatos st\xEDlus"
    },
    // Italian
    it: {
      "keyboard.tooltip.functions": "Funzioni",
      "keyboard.tooltip.symbols": "Simboli",
      "keyboard.tooltip.greek": "Lettere greche",
      "keyboard.tooltip.command": "Modalit\xE0 di comando LaTeX",
      "keyboard.tooltip.numeric": "Numerico",
      "keyboard.tooltip.alphabetic": "Lettere romane",
      "tooltip.copy to clipboard": "Copia negli appunti",
      "tooltip.redo": "Rifare",
      "tooltip.toggle virtual keyboard": "Attiva / disattiva la tastiera virtuale",
      "tooltip.undo": "Disfare",
      "menu.insert matrix": "Inserisci una Matrice",
      "menu.insert vector": "Inserisci Vettore",
      "submenu.array.matrix delimiters": "Delimitatori di Matrice",
      "menu.array.add row above": "Aggiungi una Riga Prima",
      "menu.array.add row below": "Aggiungi una Riga Dopo",
      "menu.array.add column before": "Aggiungi una Colonna Prima",
      "menu.array.add column after": "Aggiungi una Colonna Dopo",
      "menu.array.delete row": "Rimuovi una Riga",
      "menu.array.delete rows": "Rimuovi le Righe Selezionate",
      "menu.array.delete column": "Rimuovi una Colonna",
      "menu.array.delete columns": "Rimuovi le Colonne Selezionate",
      "submenu.array.insert separator": "Inserisci un Separatore",
      "menu.insert table": "Inserisci Tabella",
      "submenu.table style": "Stile tabella"
    },
    // Icelandic
    is: {
      "keyboard.tooltip.functions": "A\xF0ger\xF0ir",
      "keyboard.tooltip.symbols": "T\xE1kn",
      "keyboard.tooltip.greek": "Gr\xEDsk br\xE9f",
      "keyboard.tooltip.command": "LaTeX stj\xF3rnunarstilling",
      "keyboard.tooltip.numeric": "T\xF6lulegt",
      "keyboard.tooltip.alphabetic": "R\xF3mversk br\xE9f",
      "tooltip.copy to clipboard": "Afrita\xF0u \xE1 klemmuspjald",
      "tooltip.redo": "Endurtaka",
      "tooltip.toggle virtual keyboard": "Skiptu um s\xFDndarlyklabor\xF0",
      "tooltip.undo": "Afturkalla",
      "menu.insert matrix": "Settu fylki inn",
      "menu.insert vector": "Settu inn Vector",
      "submenu.array.matrix delimiters": "Matrix afm\xF6rkun",
      "menu.array.add row above": "B\xE6ta vi\xF0 r\xF6\xF0 \xE1 eftir",
      "menu.array.add row below": "B\xE6ta vi\xF0 r\xF6\xF0 \xE1\xF0ur",
      "menu.array.add column after": "B\xE6ta vi\xF0 d\xE1lki \xE1 eftir",
      "menu.array.add column before": "B\xE6ta vi\xF0 d\xE1lki \xE1\xF0ur",
      "menu.array.delete row": "Ey\xF0a r\xF6\xF0",
      "menu.array.delete rows": "Ey\xF0a v\xF6ldum l\xEDnum",
      "menu.array.delete column": "Ey\xF0a d\xE1lki",
      "menu.array.delete columns": "Ey\xF0a v\xF6ldum d\xE1lkum",
      "submenu.array.insert separator": "Settu skiljuna \xED",
      "menu.insert table": "Settu inn t\xF6flu",
      "submenu.table style": "T\xF6flu st\xEDl"
    },
    // Japanese
    ja: {
      "keyboard.tooltip.functions": "\u95A2\u6570",
      "keyboard.tooltip.symbols": "\u30B7\u30F3\u30DC\u30EB",
      "keyboard.tooltip.greek": "\u30AE\u30EA\u30B7\u30E3\u6587\u5B57",
      "keyboard.tooltip.command": "\u30E9\u30C6\u30C3\u30AF\u30B9\u30B3\u30DE\u30F3\u30C9\u30E2\u30FC\u30C9",
      "keyboard.tooltip.numeric": "\u6570\u5024",
      "keyboard.tooltip.alphabetic": "\u30ED\u30FC\u30DE\u5B57",
      "tooltip.copy to clipboard": "\u30AF\u30EA\u30C3\u30D7\u30DC\u30FC\u30C9\u306B\u30B3\u30D4\u30FC",
      "tooltip.redo": "\u3084\u308A\u76F4\u3057",
      "tooltip.toggle virtual keyboard": "\u4EEE\u60F3\u30AD\u30FC\u30DC\u30FC\u30C9\u306E\u5207\u308A\u66FF\u3048",
      "tooltip.undo": "\u5143\u306B\u623B\u3059",
      "menu.insert matrix": "\u30DE\u30C8\u30EA\u30C3\u30AF\u30B9\u3092\u633F\u5165",
      "menu.insert vector": "\u30D9\u30AF\u30C8\u30EB\u3092\u633F\u5165",
      "submenu.array.matrix delimiters": "\u884C\u5217\u533A\u5207\u308A\u6587\u5B57",
      "menu.array.add row above": "\u5F8C\u306B\u884C\u3092\u8FFD\u52A0",
      "menu.array.add row below": "\u524D\u306B\u884C\u3092\u8FFD\u52A0",
      "menu.array.add column after": "\u5F8C\u306B\u5217\u3092\u8FFD\u52A0",
      "menu.array.add column before": "\u524D\u306B\u5217\u3092\u8FFD\u52A0",
      "menu.array.delete row": "\u884C\u3092\u524A\u9664",
      "menu.array.delete rows": "\u9078\u629E\u3057\u305F\u884C\u3092\u524A\u9664\u3059\u308B",
      "menu.array.delete column": "\u5217\u3092\u524A\u9664",
      "menu.array.delete columns": "\u9078\u629E\u3057\u305F\u5217\u3092\u524A\u9664\u3059\u308B",
      "submenu.array.insert separator": "\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC\u3092\u633F\u5165",
      "menu.insert table": "\u30C6\u30FC\u30D6\u30EB\u3092\u633F\u5165",
      "submenu.table style": "\u30C6\u30FC\u30D6\u30EB\u30B9\u30BF\u30A4\u30EB"
    },
    // Korean
    ko: {
      "keyboard.tooltip.functions": "\uAE30\uB2A5",
      "keyboard.tooltip.symbols": "\uAE30\uD638",
      "keyboard.tooltip.greek": "\uADF8\uB9AC\uC2A4 \uBB38\uC790",
      "keyboard.tooltip.command": "\uC720\uC561 \uBA85\uB839 \uBAA8\uB4DC",
      "keyboard.tooltip.numeric": "\uC22B\uC790",
      "keyboard.tooltip.alphabetic": "\uB85C\uB9C8 \uBB38\uC790",
      "tooltip.copy to clipboard": "\uD074\uB9BD \uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
      "tooltip.redo": "\uB2E4\uC2DC \uD558\uB2E4",
      "tooltip.toggle virtual keyboard": "\uAC00\uC0C1 \uD0A4\uBCF4\uB4DC \uC804\uD658",
      "tooltip.undo": "\uC2E4\uD589 \uCDE8\uC18C",
      "menu.insert matrix": "\uB9E4\uD2B8\uB9AD\uC2A4 \uC0BD\uC785",
      "menu.insert vector": "\uBCA1\uD130 \uC0BD\uC785",
      "submenu.array.matrix delimiters": "\uD589\uB82C \uAD6C\uBD84 \uAE30\uD638",
      "menu.array.add row above": "\uB4A4\uC5D0 \uD589 \uCD94\uAC00",
      "menu.array.add row below": "\uC55E\uC5D0 \uD589 \uCD94\uAC00",
      "menu.array.add column after": "\uB4A4\uC5D0 \uC5F4 \uCD94\uAC00",
      "menu.array.add column before": "\uC55E\uC5D0 \uC5F4 \uCD94\uAC00",
      "menu.array.delete row": "\uD589 \uC0AD\uC81C",
      "menu.array.delete rows": "\uC120\uD0DD\uD55C \uD589 \uC0AD\uC81C",
      "menu.array.delete column": "\uC5F4 \uC0AD\uC81C",
      "menu.array.delete columns": "\uC120\uD0DD\uD55C \uC5F4 \uC0AD\uC81C",
      "submenu.array.insert separator": "\uAD6C\uBD84\uC790 \uC0BD\uC785",
      "menu.insert table": "\uD45C \uC0BD\uC785",
      "submenu.table style": "\uD14C\uC774\uBE14 \uC2A4\uD0C0\uC77C"
    },
    // Lettish
    lv: {
      "keyboard.tooltip.functions": "Funkcijas",
      "keyboard.tooltip.symbols": "Simboli",
      "keyboard.tooltip.greek": "Grie\u0137u burti",
      "keyboard.tooltip.command": "LaTeX komandu re\u017E\u012Bms",
      "keyboard.tooltip.numeric": "Ciparu skaitlis",
      "keyboard.tooltip.alphabetic": "Romie\u0161u v\u0113stules",
      "tooltip.copy to clipboard": "Kop\u0113t starpliktuv\u0113",
      "tooltip.redo": "P\u0101rtais\u012Bt",
      "tooltip.toggle virtual keyboard": "P\u0101rsl\u0113gt virtu\u0101lo tastat\u016Bru",
      "tooltip.undo": "Atsaukt",
      "menu.insert matrix": "Ievietojiet matricu",
      "menu.insert vector": "Ievietot vektoru",
      "submenu.array.matrix delimiters": "Matricas norobe\u017Eot\u0101ji",
      "menu.array.add row above": "Pievienot rindu p\u0113c",
      "menu.array.add row below": "Pievienot rindu pirms",
      "menu.array.add column after": "Pievienot kolonnu p\u0113c",
      "menu.array.add column before": "Pievienot kolonnu pirms",
      "menu.array.delete row": "Dz\u0113st rindu",
      "menu.array.delete rows": "Dz\u0113st atlas\u012Bt\u0101s rindas",
      "menu.array.delete column": "Dz\u0113st kolonnu",
      "menu.array.delete columns": "Dz\u0113st atlas\u012Bt\u0101s kolonnas",
      "submenu.array.insert separator": "Ievietojiet atdal\u012Bt\u0101ju",
      "menu.insert table": "Ievietojiet tabulu",
      "submenu.table style": "Galda stils"
    },
    // Lithuanian
    lt: {
      "keyboard.tooltip.functions": "Funkcijos",
      "keyboard.tooltip.symbols": "Simboliai",
      "keyboard.tooltip.greek": "Graiki\u0161kos raid\u0117s",
      "keyboard.tooltip.command": "LaTeX komand\u0173 re\u017Eimas",
      "keyboard.tooltip.numeric": "Skaitmeninis",
      "keyboard.tooltip.alphabetic": "Romos lai\u0161kai",
      "tooltip.copy to clipboard": "Nukopijuoti \u012F i\u0161karpin\u0119",
      "tooltip.redo": "Perdaryti",
      "tooltip.toggle virtual keyboard": "Perjungti virtuali\u0105j\u0105 klaviat\u016Br\u0105",
      "tooltip.undo": "At\u0161aukti",
      "menu.insert matrix": "Ievietojiet matricu",
      "menu.insert vector": "Ievietot vektoru",
      "submenu.array.matrix delimiters": "Matricas norobe\u017Eot\u0101ji",
      "menu.array.add row above": "Pievienot rindu p\u0113c",
      "menu.array.add row below": "Pievienot rindu pirms",
      "menu.array.add column after": "Pievienot kolonnu p\u0113c",
      "menu.array.add column before": "Pievienot kolonnu pirms",
      "menu.array.delete row": "Dz\u0113st rindu",
      "menu.array.delete rows": "Dz\u0113st atlas\u012Bt\u0101s rindas",
      "menu.array.delete column": "Dz\u0113st kolonnu",
      "menu.array.delete columns": "Dz\u0113st atlas\u012Bt\u0101s kolonnas",
      "submenu.array.insert separator": "Ievietojiet atdal\u012Bt\u0101ju",
      "menu.insert table": "Ievietojiet tabulu",
      "submenu.table style": "Tabulas stili"
    },
    /// Luxembourgish
    lu: {
      "keyboard.tooltip.functions": "Funktiounen",
      "keyboard.tooltip.symbols": "Symboler",
      "keyboard.tooltip.greek": "Griichesch Br\xE9iwer",
      "keyboard.tooltip.command": "LaTeX Kommando Modus",
      "keyboard.tooltip.numeric": "Numeresch",
      "keyboard.tooltip.alphabetic": "R\xE9imesch Br\xE9iwer",
      "tooltip.copy to clipboard": "Kop\xE9iert op Clipboard",
      "tooltip.redo": "Nees nei maachen",
      "tooltip.toggle virtual keyboard": "Wiesselt Virtuell Tastatur",
      "tooltip.undo": "Undoen",
      "menu.insert matrix": "Matrix asetzen",
      "menu.insert vector": "Insert Vector",
      "submenu.array.matrix delimiters": "Matrix Ofgrenzer",
      "menu.array.add row above": "Dob\xE4izemaachen Rei No",
      "menu.array.add row below": "F\xFC\xFCgt Rei vir",
      "menu.array.add column after": "Dob\xE4izemaachen Kolonn No",
      "menu.array.add column before": "Kolonn derb\xE4i Virun",
      "menu.array.delete row": "Rad l\xE4schen",
      "menu.array.delete rows": "L\xE4scht Ausgewielte Reien",
      "menu.array.delete column": "L\xE4scht Kolonn",
      "menu.array.delete columns": "L\xE4scht Ausgewielte Kolonnen",
      "submenu.array.insert separator": "Insert Separator",
      "menu.insert table": "D\xEBsch anzeginn",
      "submenu.table style": "D\xEBsch Style"
    },
    // Dutch
    nl: {
      "keyboard.tooltip.functions": "Functies",
      "keyboard.tooltip.symbols": "Symbolen",
      "keyboard.tooltip.greek": "Griekse letters",
      "keyboard.tooltip.command": "LaTeX commando mode",
      "keyboard.tooltip.numeric": "Numeriek",
      "keyboard.tooltip.alphabetic": "Romeinse letters",
      "tooltip.copy to clipboard": "Kopi\xEBren naar klembord",
      "tooltip.redo": "Opnieuw",
      "tooltip.toggle virtual keyboard": "Schakel naar virtueel toetsenbord",
      "tooltip.undo": "Ongedaan maken",
      "menu.insert matrix": "Matrix invoegen",
      "menu.insert vector": "Vector invoegen",
      "submenu.array.matrix delimiters": "Matrixscheidingstekens",
      "menu.array.add row above": "Rij toevoegen na",
      "menu.array.add row below": "Rij toevoegen eerder",
      "menu.array.add column after": "Kolom toevoegen na",
      "menu.array.add column before": "Kolom toevoegen voor",
      "menu.array.delete row": "Verwijder rij",
      "menu.array.delete rows": "Geselecteerde rijen verwijderen",
      "menu.array.delete column": "Kolom verwijderen",
      "menu.array.delete columns": "Geselecteerde kolommen verwijderen",
      "submenu.array.insert separator": "Scheidingsteken invoegen",
      "menu.insert table": "Tabel invoegen",
      "submenu.table style": "Tabelstijl"
    },
    // Norwegian
    no: {
      "keyboard.tooltip.functions": "Funksjoner",
      "keyboard.tooltip.symbols": "Symboler",
      "keyboard.tooltip.greek": "Greske bokstaver",
      "keyboard.tooltip.command": "LaTeX kommandomodus",
      "keyboard.tooltip.numeric": "Numerisk",
      "keyboard.tooltip.alphabetic": "Romerske bokstaver",
      "tooltip.copy to clipboard": "Kopiere til utklippstavle",
      "tooltip.redo": "Gj\xF8re om",
      "tooltip.toggle virtual keyboard": "Bytt virtuelt tastatur",
      "tooltip.undo": "Angre",
      "menu.insert matrix": "Sett inn matrise",
      "menu.insert vector": "Sett inn vektor",
      "submenu.array.matrix delimiters": "Matrix avgrensere",
      "menu.array.add row above": "Legg til rad etter",
      "menu.array.add row below": "Legg til rad f\xF8r",
      "menu.array.add column after": "Legg til kolonne etter",
      "menu.array.add column before": "Legg til kolonne f\xF8r",
      "menu.array.delete row": "Slett rad",
      "menu.array.delete rows": "Slett valgte rader",
      "menu.array.delete column": "Slett kolonne",
      "menu.array.delete columns": "Slett valgte kolonner",
      "submenu.array.insert separator": "Sett inn skilletegn",
      "menu.insert table": "Sett inn tabell",
      "submenu.table style": "Tabellstil"
    },
    // Macedonian
    mk: {
      "keyboard.tooltip.functions": "\u0424\u0443\u043D\u043A\u0446\u0438\u0438",
      "keyboard.tooltip.symbols": "\u0421\u0438\u043C\u0431\u043E\u043B\u0438",
      "keyboard.tooltip.greek": "\u0413\u0440\u0447\u043A\u0438 \u0431\u0443\u043A\u0432\u0438",
      "keyboard.tooltip.command": "\u0420\u0435\u0436\u0438\u043C \u043D\u0430 \u043A\u043E\u043C\u0430\u043D\u0434\u0430 \u0432\u043E \u043B\u0430\u0442\u0435\u043A\u0441",
      "keyboard.tooltip.numeric": "\u041D\u0443\u043C\u0435\u0440\u0438\u0447\u043A\u0438",
      "keyboard.tooltip.alphabetic": "\u0420\u0438\u043C\u0441\u043A\u0438 \u043F\u0438\u0441\u043C\u0430",
      "tooltip.copy to clipboard": "\u041A\u043E\u043F\u0438\u0440\u0430\u0458\u0442\u0435 \u0432\u043E \u043A\u043B\u0438\u043F\u0431\u043E\u0440\u0434",
      "tooltip.redo": "\u041F\u043E\u0432\u0442\u043E\u0440\u043D\u043E",
      "tooltip.toggle virtual keyboard": "\u0412\u043A\u043B\u0443\u0447\u0435\u0442\u0435 \u0458\u0430 \u0432\u0438\u0440\u0442\u0443\u0435\u043B\u043D\u0430\u0442\u0430 \u0442\u0430\u0441\u0442\u0430\u0442\u0443\u0440\u0430",
      "tooltip.undo": "\u0412\u0440\u0430\u0442\u0438",
      "menu.insert matrix": "\u0412\u043C\u0435\u0442\u043D\u0435\u0442\u0435 \u043C\u0430\u0442\u0440\u0438\u0446\u0430",
      "menu.insert vector": "\u0412\u043C\u0435\u0442\u043D\u0438 \u0432\u0435\u043A\u0442\u043E\u0440",
      "submenu.array.matrix delimiters": "\u0420\u0430\u0437\u0433\u0440\u0430\u043D\u0438\u0447\u0443\u0432\u0430\u0447\u0438 \u043D\u0430 \u043C\u0430\u0442\u0440\u0438\u0446\u0430",
      "menu.array.add row above": "\u0414\u043E\u0434\u0430\u0434\u0435\u0442\u0435 \u0440\u0435\u0434 \u043F\u043E\u0441\u043B\u0435",
      "menu.array.add row below": "\u0414\u043E\u0434\u0430\u0434\u0438 \u0440\u0435\u0434 \u043F\u0440\u0435\u0434 \u0442\u043E\u0430",
      "menu.array.add column after": "\u0414\u043E\u0434\u0430\u0434\u0435\u0442\u0435 \u043A\u043E\u043B\u043E\u043D\u0430 \u043F\u043E\u0441\u043B\u0435",
      "menu.array.add column before": "\u0414\u043E\u0434\u0430\u0434\u0435\u0442\u0435 \u043A\u043E\u043B\u043E\u043D\u0430 \u043F\u0440\u0435\u0434 \u0442\u043E\u0430",
      "menu.array.delete row": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u0433\u043E \u0440\u0435\u0434\u043E\u0442",
      "menu.array.delete rows": "\u0418\u0437\u0431\u0440\u0438\u0448\u0435\u0442\u0435 \u0433\u0438 \u0438\u0437\u0431\u0440\u0430\u043D\u0438\u0442\u0435 \u0440\u0435\u0434\u043E\u0432\u0438",
      "menu.array.delete column": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u0458\u0430 \u043A\u043E\u043B\u043E\u043D\u0430\u0442\u0430",
      "menu.array.delete columns": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u0458\u0430 \u043A\u043E\u043B\u043E\u043D\u0430\u0442\u0430",
      "submenu.array.insert separator": "\u0412\u043C\u0435\u0442\u043D\u0435\u0442\u0435 \u0441\u0435\u043F\u0430\u0440\u0430\u0442\u043E\u0440",
      "menu.insert table": "\u0412\u043C\u0435\u0442\u043D\u0438 \u0442\u0430\u0431\u0435\u043B\u0430",
      "submenu.table style": "\u0422\u0430\u0431\u0435\u043B\u0430 \u0441\u0442\u0438\u043B"
    },
    // Polish
    pl: {
      "keyboard.tooltip.functions": "Funkcje",
      "keyboard.tooltip.symbols": "Symbolika",
      "keyboard.tooltip.greek": "Litery greckie",
      "keyboard.tooltip.command": "Tryb polece\u0144 LaTeX",
      "keyboard.tooltip.numeric": "Numeryczne",
      "keyboard.tooltip.alphabetic": "Litery rzymskie",
      "tooltip.copy to clipboard": "Kopiuj do Schowka",
      "tooltip.redo": "Przywr\xF3\u0107",
      "tooltip.toggle virtual keyboard": "Prze\u0142\u0105cz wirtualn\u0105 klawiatur\u0119",
      "tooltip.undo": "Cofnij",
      "menu.insert matrix": "Wstaw macierz",
      "menu.insert vector": "Wstaw wektor",
      "submenu.array.matrix delimiters": "Ograniczniki macierzy",
      "menu.array.add row above": "Dodaj wiersz po",
      "menu.array.add row below": "Dodaj wiersz przed",
      "menu.array.add column after": "Dodaj kolumn\u0119 po",
      "menu.array.add column before": "Dodaj kolumn\u0119 przed",
      "menu.array.delete row": "Usu\u0144 wiersz",
      "menu.array.delete rows": "Usu\u0144 wybrane wiersze",
      "menu.array.delete column": "Usu\u0144 kolumn\u0119",
      "menu.array.delete columns": "Usu\u0144 wybrane kolumny",
      "submenu.array.insert separator": "Wstaw separator",
      "menu.insert table": "Wype\u0142nij tabel\u0119",
      "submenu.table style": "Styl tabel\u0119"
    },
    // Portuguese
    pt: {
      "keyboard.tooltip.functions": "Functions",
      "keyboard.tooltip.symbols": "S\xEDmbolos",
      "keyboard.tooltip.greek": "Letras gregas",
      "keyboard.tooltip.command": "Modo de Comando LaTeX",
      "keyboard.tooltip.numeric": "Num\xE9rico",
      "keyboard.tooltip.alphabetic": "Letras romanas",
      "tooltip.copy to clipboard": "Copiar para \xE1rea de transfer\xEAncia",
      "tooltip.redo": "Refazer",
      "tooltip.toggle virtual keyboard": "Alternar teclado virtual",
      "tooltip.undo": "Desfazer",
      "menu.insert matrix": "Inserir Matriz",
      "menu.insert vector": "Inserir vetor",
      "submenu.array.matrix delimiters": "Delimitadores de matriz",
      "menu.array.add row above": "Adicionar linha depois",
      "menu.array.add row below": "Adicionar linha antes",
      "menu.array.add column after": "Adicionar coluna depois",
      "menu.array.add column before": "Adicionar coluna antes",
      "menu.array.delete row": "Excluir linha",
      "menu.array.delete rows": "Excluir linhas selecionadas",
      "menu.array.delete column": "Apagar Coluna",
      "menu.array.delete columns": "Excluir Colunas Selecionadas",
      "submenu.array.insert separator": "Inserir Separador",
      "menu.insert table": "Insira a tabela",
      "submenu.table style": "Estilo tabela"
    },
    //Romaninan
    ro: {
      "keyboard.tooltip.functions": "Func\u021Bii",
      "keyboard.tooltip.symbols": "Simboluri",
      "keyboard.tooltip.greek": "Scrisori grece\u0219ti",
      "keyboard.tooltip.command": "Modul de comand\u0103 latex",
      "keyboard.tooltip.numeric": "Numeric",
      "keyboard.tooltip.alphabetic": "Scrisori romane",
      "tooltip.copy to clipboard": "Copia\u021Bi \xEEn clipboard",
      "tooltip.redo": "A reface",
      "tooltip.toggle virtual keyboard": "Comuta\u021Bi tastatura virtual\u0103",
      "tooltip.undo": "Anula",
      "menu.insert matrix": "Introduce\u021Bi Matrix",
      "menu.insert vector": "Insera\u021Bi Vector",
      "submenu.array.matrix delimiters": "Delimitatori de matrice",
      "menu.array.add row above": "Ad\u0103uga\u021Bi r\xE2ndul dup\u0103",
      "menu.array.add row below": "Ad\u0103uga\u021Bi r\xE2ndul \xEEnainte",
      "menu.array.add column after": "Ad\u0103uga\u021Bi o coloan\u0103 dup\u0103",
      "menu.array.add column before": "Ad\u0103uga\u021Bi o coloan\u0103 \xEEnainte",
      "menu.array.delete row": "\u0218terge\u021Bi r\xE2ndul",
      "menu.array.delete rows": "\u0218terge\u021Bi r\xE2ndurile selectate",
      "menu.array.delete column": "\u0218terge\u021Bi coloana",
      "menu.array.delete columns": "\u0218terge\u021Bi coloanele selectate",
      "submenu.array.insert separator": "Introduce\u021Bi separatorul",
      "menu.insert table": "Introduce\u021Bi tabelul",
      "submenu.table style": "Table style"
    },
    // Russian
    ru: {
      "keyboard.tooltip.functions": "\u0424\u0443\u043D\u043A\u0446\u0438\u0438",
      "keyboard.tooltip.symbols": "\u0421\u0438\u043C\u0432\u043E\u043B\u044B",
      "keyboard.tooltip.greek": "\u0413\u0440\u0435\u0447\u0435\u0441\u043A\u0438\u0435 \u0431\u0443\u043A\u0432\u044B",
      "keyboard.tooltip.command": "\u0420\u0435\u0436\u0438\u043C \u043A\u043E\u043C\u0430\u043D\u0434\u043D\u043E\u0439 \u0441\u0442\u0440\u043E\u043A\u0438 \u041B\u0430\u0442\u0435\u043A\u0441",
      "keyboard.tooltip.numeric": "\u0447\u0438\u0441\u043B\u043E\u0432\u043E\u0439",
      "keyboard.tooltip.alphabetic": "\u041B\u0430\u0442\u0438\u043D\u0441\u043A\u0438\u0435 \u0431\u0443\u043A\u0432\u044B",
      "tooltip.copy to clipboard": "\u0421\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430",
      "tooltip.redo": "\u043F\u0435\u0440\u0435\u0434\u0435\u043B\u044B\u0432\u0430\u0442\u044C",
      "tooltip.toggle virtual keyboard": "\u041F\u0435\u0440\u0435\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0432\u0438\u0440\u0442\u0443\u0430\u043B\u044C\u043D\u0443\u044E \u043A\u043B\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0443",
      "tooltip.undo": "\u0440\u0430\u0441\u0441\u0442\u0435\u0433\u0438\u0432\u0430\u0442\u044C",
      "menu.insert matrix": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u043C\u0430\u0442\u0440\u0438\u0446\u0443",
      "menu.insert vector": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0432\u0435\u043A\u0442\u043E\u0440",
      "submenu.array.matrix delimiters": "\u041C\u0430\u0442\u0440\u0438\u0447\u043D\u044B\u0435 \u0440\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u0438",
      "menu.array.add row above": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u0440\u043E\u043A\u0443 \u043F\u043E\u0441\u043B\u0435",
      "menu.array.add row below": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u0440\u043E\u043A\u0443 \u043F\u0435\u0440\u0435\u0434",
      "menu.array.add column after": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u043E\u043B\u0431\u0435\u0446 \u043F\u043E\u0441\u043B\u0435",
      "menu.array.add column before": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u043E\u043B\u0431\u0435\u0446 \u043F\u0435\u0440\u0435\u0434",
      "menu.array.delete row": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0441\u0442\u0440\u043E\u043A\u0443",
      "menu.array.delete rows": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435 \u0441\u0442\u0440\u043E\u043A\u0438",
      "menu.array.delete column": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0441\u0442\u043E\u043B\u0431\u0435\u0446",
      "menu.array.delete columns": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435 \u0441\u0442\u043E\u043B\u0431\u0446\u044B",
      "submenu.array.insert separator": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0440\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C",
      "menu.insert table": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0442\u0430\u0431\u043B\u0438\u0446\u0443",
      "submenu.table style": "\u0422\u0430\u0431\u043B\u0438\u0447\u043D\u044B\u0439 \u0441\u0442\u0438\u043B\u044C"
    },
    // Slovak
    sk: {
      "keyboard.tooltip.functions": "Functions",
      "keyboard.tooltip.symbols": "Symboly",
      "keyboard.tooltip.greek": "Gr\xE9cke listy",
      "keyboard.tooltip.command": "Pr\xEDkazov\xFD re\u017Eim LaTeX",
      "keyboard.tooltip.numeric": "Numerick\xE9",
      "keyboard.tooltip.alphabetic": "R\xEDmske listy",
      "tooltip.copy to clipboard": "Skop\xEDrova\u0165 do schr\xE1nky",
      "tooltip.redo": "Znova",
      "tooltip.toggle virtual keyboard": "Prepn\xFA\u0165 virtu\xE1lnu kl\xE1vesnicu",
      "tooltip.undo": "Vr\xE1tenie sp\xE4\u0165",
      "menu.insert matrix": "Vlo\u017Ete maticu",
      "menu.insert vector": "Vlo\u017Ete vektor",
      "submenu.array.matrix delimiters": "Odde\u013Eova\u010De mat\xEDc",
      "menu.array.add row above": "Pridajte riadok za",
      "menu.array.add row below": "Pridajte riadok pred",
      "menu.array.add column after": "Prida\u0165 st\u013Apec za",
      "menu.array.add column before": "Pridajte st\u013Apec predt\xFDm",
      "menu.array.delete row": "Odstr\xE1ni\u0165 riadok",
      "menu.array.delete rows": "Odstr\xE1ni\u0165 vybrat\xE9 riadky",
      "menu.array.delete column": "Odstr\xE1ni\u0165 st\u013Apec",
      "menu.array.delete columns": "Odstr\xE1ni\u0165 vybrat\xE9 st\u013Apce",
      "submenu.array.insert separator": "Vlo\u017Ete odde\u013Eova\u010D",
      "menu.insert table": "Vlo\u017Ete tabu\u013Eku",
      "submenu.table style": "\u0160t\xFDl tabu\u013Eky"
    },
    // Slovenian
    sl: {
      "keyboard.tooltip.functions": "Funkcije",
      "keyboard.tooltip.symbols": "Simboli",
      "keyboard.tooltip.greek": "Gr\u0161ka pisma",
      "keyboard.tooltip.command": "Ukazni na\u010Din LaTeX",
      "keyboard.tooltip.numeric": "\u0160tevilsko",
      "keyboard.tooltip.alphabetic": "Rimska pisma",
      "tooltip.copy to clipboard": "Kopirati v odlo\u017Ei\u0161\u010De",
      "tooltip.redo": "Ponovi",
      "tooltip.toggle virtual keyboard": "Preklop navidezne tipkovnice",
      "tooltip.undo": "Razveljavi",
      "menu.insert matrix": "Vstavi matrico",
      "menu.insert vector": "Vstavi vektor",
      "submenu.array.matrix delimiters": "Matri\u010Dni lo\u010Devalniki",
      "menu.array.add row above": "Dodaj vrstico po",
      "menu.array.add row below": "Dodaj vrstico prej",
      "menu.array.add column after": "Dodaj stolpec po",
      "menu.array.add column before": "Dodaj stolpec prej",
      "menu.array.delete row": "Izbri\u0161i vrstico",
      "menu.array.delete rows": "Izbri\u0161i izbrane vrstice",
      "menu.array.delete column": "Izbri\u0161i stolpec",
      "menu.array.delete columns": "Izbri\u0161i izbrane stolpce",
      "submenu.array.insert separator": "Vstavi lo\u010Dilo",
      "menu.insert table": "Vstavi tabelo",
      "submenu.table style": "Tabela slog"
    },
    /// Albanian
    sq: {
      "keyboard.tooltip.functions": "Funksione",
      "keyboard.tooltip.symbols": "Simbolet",
      "keyboard.tooltip.greek": "Letrat Greke",
      "keyboard.tooltip.command": "Modaliteti i komand\xEBs latex",
      "keyboard.tooltip.numeric": "Numerike",
      "keyboard.tooltip.alphabetic": "Letrat romake",
      "tooltip.copy to clipboard": "Kopjoni n\xEB Clipboard",
      "tooltip.redo": "Riparo",
      "tooltip.toggle virtual keyboard": "Aktivizo tastier\xEBn virtuale",
      "tooltip.undo": "Zhb\xEBj",
      "menu.insert matrix": "Vendosni Matric\xEBn",
      "menu.insert vector": "Vendos vektorin",
      "submenu.array.matrix delimiters": "P\xEBrcaktuesit e matric\xEBs",
      "menu.array.add row above": "Shto Rreshtin Pas",
      "menu.array.add row below": "Shto Rreshtin Para",
      "menu.array.add column after": "Shto kolon\xEBn pas",
      "menu.array.add column before": "Shto kolon\xEBn para",
      "menu.array.delete row": "Fshi Rreshtin",
      "menu.array.delete rows": "Fshi rreshtat e zgjedhur",
      "menu.array.delete column": "Fshi kolon\xEBn",
      "menu.array.delete columns": "Fshi kolonat e zgjedhura",
      "submenu.array.insert separator": "Vendos Ndar\xEBsin",
      "menu.insert table": "Vendos tabel\xEBn",
      "submenu.table style": "Stili tabel\xEBn"
    },
    // Serbian
    sr: {
      "keyboard.tooltip.functions": "\u0424\u0443\u043D\u043A\u0446\u0438\u0458\u0435",
      "keyboard.tooltip.symbols": "\u0421\u0438\u043C\u0431\u043E\u043B\u0438",
      "keyboard.tooltip.greek": "\u0413\u0440\u0435\u0435\u043A \u041B\u0435\u0442\u0442\u0435\u0440\u0441",
      "keyboard.tooltip.command": "\u041B\u0430\u0422\u0435\u041A\u0441 \u043A\u043E\u043C\u0430\u043D\u0434\u043D\u0438 \u0440\u0435\u0436\u0438\u043C",
      "keyboard.tooltip.numeric": "\u041D\u0443\u043C\u0435\u0440\u0438\u0447\u043A\u0438",
      "keyboard.tooltip.alphabetic": "\u0420\u0438\u043C\u0441\u043A\u0430 \u043F\u0438\u0441\u043C\u0430",
      "tooltip.copy to clipboard": "\u041A\u043E\u043F\u0438\u0440\u0430\u0458\u0442\u0435 \u0443 \u043C\u0435\u0452\u0443\u0441\u043F\u0440\u0435\u043C\u043D\u0438\u043A",
      "tooltip.redo": "\u041F\u043E\u043D\u043E\u0432\u0438",
      "tooltip.toggle virtual keyboard": "\u0423\u043A\u0459\u0443\u0447\u0438 / \u0438\u0441\u043A\u0459\u0443\u0447\u0438 \u0432\u0438\u0440\u0442\u0443\u0435\u043B\u043D\u0443 \u0442\u0430\u0441\u0442\u0430\u0442\u0443\u0440\u0443",
      "tooltip.undo": "\u041E\u043F\u043E\u0437\u043E\u0432\u0438",
      "menu.insert matrix": "\u0423\u043C\u0435\u0442\u043D\u0438 \u043C\u0430\u0442\u0440\u0438\u0446\u0443",
      "menu.insert vector": "\u0423\u043C\u0435\u0442\u043D\u0438 \u0432\u0435\u043A\u0442\u043E\u0440",
      "submenu.array.matrix delimiters": "\u041C\u0430\u0442\u0440\u0438\u043A \u0414\u0435\u043B\u0438\u043C\u0438\u0442\u0435\u0440\u0441",
      "menu.array.add row above": "\u0414\u043E\u0434\u0430\u0458 \u0440\u0435\u0434 \u043F\u043E\u0441\u043B\u0435",
      "menu.array.add row below": "\u0414\u043E\u0434\u0430\u0458 \u0440\u0435\u0434 \u043F\u0440\u0435",
      "menu.array.add column after": "\u0414\u043E\u0434\u0430\u0458 \u043A\u043E\u043B\u043E\u043D\u0443 \u043F\u043E\u0441\u043B\u0435",
      "menu.array.add column before": "\u0414\u043E\u0434\u0430\u0458 \u043A\u043E\u043B\u043E\u043D\u0443 \u043F\u0440\u0435",
      "menu.array.delete row": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u0440\u0435\u0434",
      "menu.array.delete rows": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u0438\u0437\u0430\u0431\u0440\u0430\u043D\u0435 \u0440\u0435\u0434\u043E\u0432\u0435",
      "menu.array.delete column": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u043A\u043E\u043B\u043E\u043D\u0443",
      "menu.array.delete columns": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u0438\u0437\u0430\u0431\u0440\u0430\u043D\u0435 \u043A\u043E\u043B\u043E\u043D\u0435",
      "submenu.array.insert separator": "\u0423\u043C\u0435\u0442\u043D\u0438 \u0441\u0435\u043F\u0430\u0440\u0430\u0442\u043E\u0440",
      "menu.insert table": "\u0423\u0431\u0430\u0446\u0438 \u0442\u0430\u0431\u0435\u043B\u0443",
      "submenu.table style": "\u0422\u0430\u0431\u0435\u043B\u0430\u0440\u043D\u0438 \u0441\u0442\u0438\u043B"
    },
    // Swedish
    sv: {
      "keyboard.tooltip.functions": "Funktioner",
      "keyboard.tooltip.symbols": "Symboler",
      "keyboard.tooltip.greek": "Grekiska bokst\xE4ver",
      "keyboard.tooltip.command": "LaTeX kommandol\xE4ge",
      "keyboard.tooltip.numeric": "Numerisk",
      "keyboard.tooltip.alphabetic": "Romerska bokst\xE4ver",
      "tooltip.copy to clipboard": "Kopiera till Urklipp",
      "tooltip.redo": "G\xF6ra om",
      "tooltip.toggle virtual keyboard": "V\xE4xla virtuellt tangentbord",
      "tooltip.undo": "\xC5ngra",
      "menu.insert matrix": "S\xE4tt in matris",
      "menu.insert vector": "Infoga vektor",
      "submenu.array.matrix delimiters": "Matrisavgr\xE4nsare",
      "menu.array.add row above": "L\xE4gg till rad efter",
      "menu.array.add row below": "L\xE4gg till rad f\xF6re",
      "menu.array.add column after": "L\xE4gg till kolumn efter",
      "menu.array.add column before": "L\xE4gg till kolumn f\xF6re",
      "menu.array.delete row": "Radera rad",
      "menu.array.delete rows": "Ta bort valda rader",
      "menu.array.delete column": "Ta bort kolumn",
      "menu.array.delete columns": "Ta bort valda kolumner",
      "submenu.array.insert separator": "S\xE4tt i separator",
      "menu.insert table": "Infoga tabell",
      "submenu.table style": "Tabellstil"
    },
    // Thai
    th: {
      "keyboard.tooltip.functions": "\u0E1F\u0E31\u0E07\u0E01\u0E4C\u0E0A\u0E31\u0E48\u0E19",
      "keyboard.tooltip.symbols": "\u0E2A\u0E31\u0E0D\u0E25\u0E31\u0E01\u0E29\u0E13\u0E4C",
      "keyboard.tooltip.greek": "\u0E2D\u0E31\u0E01\u0E29\u0E23\u0E01\u0E23\u0E35\u0E01",
      "keyboard.tooltip.command": "\u0E42\u0E2B\u0E21\u0E14\u0E04\u0E33\u0E2A\u0E31\u0E48\u0E07 \u0E19\u0E49\u0E33\u0E22\u0E32\u0E07",
      "keyboard.tooltip.numeric": "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
      "keyboard.tooltip.alphabetic": "\u0E2D\u0E31\u0E01\u0E29\u0E23\u0E42\u0E23\u0E21\u0E31\u0E19",
      "tooltip.copy to clipboard": "\u0E04\u0E31\u0E14\u0E25\u0E2D\u0E01\u0E44\u0E1B\u0E17\u0E35\u0E48\u0E04\u0E25\u0E34\u0E1B\u0E1A\u0E2D\u0E23\u0E4C\u0E14",
      "tooltip.redo": "\u0E17\u0E33\u0E0B\u0E49\u0E33",
      "tooltip.toggle virtual keyboard": "\u0E2A\u0E25\u0E31\u0E1A\u0E41\u0E1B\u0E49\u0E19\u0E1E\u0E34\u0E21\u0E1E\u0E4C\u0E40\u0E2A\u0E21\u0E37\u0E2D\u0E19",
      "tooltip.undo": "\u0E40\u0E25\u0E34\u0E01\u0E17\u0E33",
      "menu.insert matrix": "\u0E41\u0E17\u0E23\u0E01\u0E40\u0E21\u0E17\u0E23\u0E34\u0E01\u0E0B\u0E4C",
      "menu.insert vector": "\u0E41\u0E17\u0E23\u0E01\u0E40\u0E27\u0E01\u0E40\u0E15\u0E2D\u0E23\u0E4C",
      "submenu.array.matrix delimiters": "\u0E15\u0E31\u0E27\u0E04\u0E31\u0E48\u0E19\u0E40\u0E21\u0E17\u0E23\u0E34\u0E01\u0E0B\u0E4C",
      "menu.array.add row above": "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E41\u0E16\u0E27\u0E2B\u0E25\u0E31\u0E07",
      "menu.array.add row below": "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E41\u0E16\u0E27\u0E01\u0E48\u0E2D\u0E19",
      "menu.array.add column after": "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E04\u0E2D\u0E25\u0E31\u0E21\u0E19\u0E4C\u0E2B\u0E25\u0E31\u0E07",
      "menu.array.add column before": "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E04\u0E2D\u0E25\u0E31\u0E21\u0E19\u0E4C\u0E01\u0E48\u0E2D\u0E19",
      "menu.array.delete row": "\u0E25\u0E1A\u0E41\u0E16\u0E27",
      "menu.array.delete rows": "\u0E25\u0E1A\u0E41\u0E16\u0E27\u0E17\u0E35\u0E48\u0E40\u0E25\u0E37\u0E2D\u0E01",
      "menu.array.delete column": "\u0E25\u0E1A\u0E04\u0E2D\u0E25\u0E31\u0E21\u0E19\u0E4C",
      "menu.array.delete columns": "\u0E25\u0E1A\u0E04\u0E2D\u0E25\u0E31\u0E21\u0E19\u0E4C\u0E17\u0E35\u0E48\u0E40\u0E25\u0E37\u0E2D\u0E01",
      "submenu.array.insert separator": "\u0E15\u0E31\u0E27\u0E04\u0E31\u0E48\u0E19\u0E41\u0E17\u0E23\u0E01",
      "menu.insert table": "\u0E41\u0E17\u0E23\u0E01\u0E15\u0E32\u0E23\u0E32\u0E07",
      "submenu.table style": "\u0E2A\u0E44\u0E15\u0E25\u0E4C\u0E15\u0E32\u0E23\u0E32\u0E07"
    },
    // Turkish
    tr: {
      "keyboard.tooltip.functions": "Fonksiyonlar",
      "keyboard.tooltip.symbols": "Semboller",
      "keyboard.tooltip.greek": "Yunan harfleri",
      "keyboard.tooltip.command": "LaTeX Komut Modu",
      "keyboard.tooltip.numeric": "Say\u0131sal",
      "keyboard.tooltip.alphabetic": "Roma Harfleri",
      "tooltip.copy to clipboard": "Panoya kopyala",
      "tooltip.redo": "Yeniden yap",
      "tooltip.toggle virtual keyboard": "Sanal Klavyeyi A\xE7/Kapat",
      "tooltip.undo": "Geri alma",
      "menu.insert matrix": "Matris Ekle",
      "menu.insert vector": "Vekt\xF6r Ekle",
      "submenu.array.matrix delimiters": "Matris S\u0131n\u0131rlay\u0131c\u0131lar",
      "menu.array.add row above": "Sat\u0131rdan Sonra Ekle",
      "menu.array.add row below": "\xD6nce Sat\u0131r Ekle",
      "menu.array.add column after": "Sonra S\xFCtun Ekle",
      "menu.array.add column before": "\xD6nce S\xFCtun Ekle",
      "menu.array.delete row": "S\u0131ray\u0131 sil",
      "menu.array.delete rows": "Se\xE7ili Sat\u0131rlar\u0131 Sil",
      "menu.array.delete column": "S\xFCtunu Sil",
      "menu.array.delete columns": "Se\xE7ili S\xFCtunlar\u0131 Sil",
      "submenu.array.insert separator": "Ay\u0131r\u0131c\u0131 Ekle",
      "menu.insert table": "Tablo Ekle",
      "submenu.table style": "Tablo Stili"
    },
    //Ukrainian
    uk: {
      "keyboard.tooltip.functions": "\u0424\u0443\u043D\u043A\u0446\u0456\u0457",
      "keyboard.tooltip.symbols": "\u0421\u0438\u043C\u0432\u043E\u043B\u0438",
      "keyboard.tooltip.greek": "\u0413\u0440\u0435\u0446\u044C\u043A\u0456 \u043B\u0456\u0442\u0435\u0440\u0438",
      "keyboard.tooltip.command": "\u041A\u043E\u043C\u0430\u043D\u0434\u043D\u0438\u0439 \u0440\u0435\u0436\u0438\u043C \u043B\u0430\u0442\u0435\u043A\u0441\u0443",
      "keyboard.tooltip.numeric": "\u0427\u0438\u0441\u043B\u043E\u0432\u0438\u0439",
      "keyboard.tooltip.alphabetic": "\u0420\u0438\u043C\u0441\u044C\u043A\u0456 \u043B\u0456\u0442\u0435\u0440\u0438",
      "tooltip.copy to clipboard": "\u041A\u043E\u043F\u0456\u044E\u0432\u0430\u0442\u0438 \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0456\u043D\u0443",
      "tooltip.redo": "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0438",
      "tooltip.toggle virtual keyboard": "\u041F\u0435\u0440\u0435\u043A\u043B\u044E\u0447\u0438\u0442\u0438 \u0432\u0456\u0440\u0442\u0443\u0430\u043B\u044C\u043D\u0443 \u043A\u043B\u0430\u0432\u0456\u0430\u0442\u0443\u0440\u0443",
      "tooltip.undo": "\u0421\u043A\u0430\u0441\u0443\u0432\u0430\u0442\u0438",
      "menu.insert matrix": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u0438 \u043C\u0430\u0442\u0440\u0438\u0446\u044E",
      "menu.insert vector": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u0438 \u0432\u0435\u043A\u0442\u043E\u0440",
      "submenu.array.matrix delimiters": "\u041C\u0430\u0442\u0440\u0438\u0447\u043D\u0456 \u0440\u043E\u0437\u0434\u0456\u043B\u044C\u043D\u0438\u043A\u0438",
      "menu.array.add row above": "\u0414\u043E\u0434\u0430\u0442\u0438 \u0440\u044F\u0434\u043E\u043A \u043F\u0456\u0441\u043B\u044F",
      "menu.array.add row below": "\u0414\u043E\u0434\u0430\u0442\u0438 \u0440\u044F\u0434\u043E\u043A \u0434\u043E",
      "menu.array.add column after": "\u0414\u043E\u0434\u0430\u0442\u0438 \u0441\u0442\u043E\u0432\u043F\u0435\u0446\u044C \u043F\u0456\u0441\u043B\u044F",
      "menu.array.add column before": "\u0414\u043E\u0434\u0430\u0442\u0438 \u0441\u0442\u043E\u0432\u043F\u0435\u0446\u044C \u043F\u0435\u0440\u0435\u0434",
      "menu.array.delete row": "\u0412\u0438\u0434\u0430\u043B\u0438\u0442\u0438 \u0440\u044F\u0434\u043E\u043A",
      "menu.array.delete rows": "\u0412\u0438\u0434\u0430\u043B\u0438\u0442\u0438 \u0432\u0438\u0431\u0440\u0430\u043D\u0456 \u0440\u044F\u0434\u043A\u0438",
      "menu.array.delete column": "\u0412\u0438\u0434\u0430\u043B\u0438\u0442\u0438 \u0441\u0442\u043E\u0432\u043F\u0435\u0446\u044C",
      "menu.array.delete columns": "\u0412\u0438\u0434\u0430\u043B\u0438\u0442\u0438 \u0432\u0438\u0431\u0440\u0430\u043D\u0456 \u0441\u0442\u043E\u0432\u043F\u0446\u0456",
      "submenu.array.insert separator": "\u0412\u0441\u0442\u0430\u0432\u0442\u0435 \u0440\u043E\u0437\u0434\u0456\u043B\u044C\u043D\u0438\u043A",
      "menu.insert table": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u0438 \u0442\u0430\u0431\u043B\u0438\u0446\u044E",
      "submenu.table style": "\u0421\u0442\u0438\u043B\u044C \u0442\u0430\u0431\u043B\u0438\u0446\u0456"
    },
    //Vietnamese
    vi: {
      "keyboard.tooltip.functions": "Ch\u1EE9c n\u0103ng",
      "keyboard.tooltip.symbols": "K\xFD hi\u1EC7u",
      "keyboard.tooltip.greek": "Ch\u1EEF Hy L\u1EA1p",
      "keyboard.tooltip.command": "Ch\u1EBF \u0111\u1ED9 l\u1EC7nh LaTeX",
      "keyboard.tooltip.numeric": "S\u1ED1",
      "keyboard.tooltip.alphabetic": "Ch\u1EEF c\xE1i La m\xE3",
      "tooltip.copy to clipboard": "Sao ch\xE9p v\xE0o clipboard",
      "tooltip.redo": "L\xE0m l\u1EA1i",
      "tooltip.toggle virtual keyboard": "Chuy\u1EC3n \u0111\u1ED5i b\xE0n ph\xEDm \u1EA3o",
      "tooltip.undo": "Ho\xE0n t\xE1c",
      "menu.insert matrix": "Ch\xE8n ma tr\u1EADn",
      "menu.insert vector": "Insert Vector",
      "submenu.array.matrix delimiters": "D\u1EA5u ph\xE2n c\xE1ch ma tr\u1EADn",
      "menu.array.add row above": "Th\xEAm h\xE0ng sau",
      "menu.array.add row below": "Th\xEAm h\xE0ng tr\u01B0\u1EDBc",
      "menu.array.add column after": "Th\xEAm c\u1ED9t sau",
      "menu.array.add column before": "Th\xEAm c\u1ED9t tr\u01B0\u1EDBc",
      "menu.array.delete row": "X\xF3a h\xE0ng",
      "menu.array.delete rows": "X\xF3a h\xE0ng \u0111\xE3 ch\u1ECDn",
      "menu.array.delete column": "X\xF3a c\u1ED9t",
      "menu.array.delete columns": "X\xF3a c\xE1c c\u1ED9t \u0111\xE3 ch\u1ECDn",
      "submenu.array.insert separator": "Ch\xE8n d\u1EA5u ph\xE2n c\xE1ch",
      "menu.insert table": "Ch\xE8n b\u1EA3ng",
      "submenu.table style": "Ki\u1EC3u b\u1EA3ng"
    },
    // Simplified Chinese
    zh_cn: {
      "keyboard.tooltip.functions": "\u804C\u80FD",
      "keyboard.tooltip.symbols": "\u7B26\u53F7",
      "keyboard.tooltip.greek": "\u5E0C\u814A\u5B57\u6BCD",
      "keyboard.tooltip.command": "\u4E73\u80F6 \u547D\u4EE4\u6A21\u5F0F",
      "keyboard.tooltip.numeric": "\u6570\u5B57",
      "keyboard.tooltip.alphabetic": "\u7F57\u9A6C\u5B57\u6BCD",
      "tooltip.copy to clipboard": "\u590D\u5236\u5230\u526A\u8D34\u677F",
      "tooltip.redo": "\u91CD\u505A",
      "tooltip.toggle virtual keyboard": "\u5207\u6362\u865A\u62DF\u952E\u76D8",
      "tooltip.undo": "\u64A4\u6D88",
      "menu.insert matrix": "\u63D2\u5165\u77E9\u9635",
      "menu.insert vector": "\u63D2\u5165\u5411\u91CF",
      "submenu.array.matrix delimiters": "\u77E9\u9635\u5206\u9694\u7B26",
      "menu.array.add row above": "\u5728\u540E\u9762\u6DFB\u52A0\u884C",
      "menu.array.add row below": "\u5728\u524D\u9762\u6DFB\u52A0\u884C",
      "menu.array.add column after": "\u5728\u540E\u9762\u6DFB\u52A0\u5217r",
      "menu.array.add column before": "\u5728\u524D\u9762\u6DFB\u52A0\u5217",
      "menu.array.delete row": "\u5220\u9664\u884C",
      "menu.array.delete rows": "\u5220\u9664\u9009\u5B9A\u884C",
      "menu.array.delete column": "\u5220\u9664\u5217",
      "menu.array.delete columns": "\u5220\u9664\u9009\u5B9A\u7684\u5217",
      "submenu.array.insert separator": "\u63D2\u5165\u5206\u9694\u7B26",
      "menu.insert table": "\u63D2\u5165\u8868\u683C",
      "submenu.table style": "\u8868\u683C\u6837\u5F0F"
    },
    // Traditional Chinese
    zh_tw: {
      "keyboard.tooltip.functions": "\u8077\u80FD",
      "keyboard.tooltip.symbols": "\u7B26\u865F",
      "keyboard.tooltip.greek": "\u5E0C\u81D8\u5B57\u6BCD",
      "keyboard.tooltip.command": "\u4E73\u81A0\u547D\u4EE4\u6A21\u5F0F",
      "keyboard.tooltip.numeric": "\u6578\u5B57",
      "keyboard.tooltip.alphabetic": "\u7F85\u99AC\u5B57\u6BCD",
      "tooltip.copy to clipboard": "\u8907\u88FD\u5230\u526A\u8CBC\u677F",
      "tooltip.redo": "\u91CD\u505A",
      "tooltip.toggle virtual keyboard": "\u5207\u63DB\u865B\u64EC\u9375\u76E4",
      "tooltip.undo": "\u64A4\u6D88",
      "menu.insert matrix": "\u63D2\u5165\u77E9\u9663",
      "menu.insert vector": "\u63D2\u5165\u5411\u91CF",
      "submenu.array.matrix delimiters": "\u77E9\u9663\u5206\u9694\u7B26",
      "menu.array.add row above": "\u5728\u5F8C\u9762\u6DFB\u52A0\u884C",
      "menu.array.add row below": "\u5728\u524D\u9762\u6DFB\u52A0\u884C",
      "menu.array.add column after": "\u5728\u5F8C\u9762\u6DFB\u52A0\u5217",
      "menu.array.add column before": "\u5728\u524D\u9762\u6DFB\u52A0\u5217",
      "menu.array.delete row": "\u522A\u9664\u884C",
      "menu.array.delete rows": "\u522A\u9664\u9078\u5B9A\u884C",
      "menu.array.delete column": "\u522A\u9664\u5217",
      "menu.array.delete columns": "\u522A\u9664\u9078\u5B9A\u7684\u5217",
      "submenu.array.insert separator": "\u63D2\u5165\u5206\u9694\u7B26",
      "menu.insert table": "\u63D2\u5165\u8868\u683C",
      "submenu.table style": "\u8868\u683C\u6A23\u5F0F"
    }
  };

  // src/common/capabilities.ts
  function isBrowser() {
    return "window" in globalThis && "document" in globalThis;
  }
  function throwIfNotInBrowser() {
    if (!isBrowser()) {
      throw new Error(
        "<math-field> is an interactive component that needs to run in a browser environment\nIf you are using nextjs, see https://nextjs.org/docs/advanced-features/dynamic-import#with-no-ssr"
      );
    }
  }
  function isTouchCapable() {
    if ("matchMedia" in window)
      return window.matchMedia("(any-pointer: coarse)").matches;
    return "ontouchstart" in window || navigator.maxTouchPoints > 0;
  }
  function canVibrate() {
    return typeof navigator.vibrate === "function";
  }
  function osPlatform() {
    var _a3, _b3;
    if (!isBrowser())
      return "other";
    const platform2 = (_b3 = (_a3 = navigator["userAgentData"]) == null ? void 0 : _a3.platform) != null ? _b3 : navigator.platform;
    if (/^mac/i.test(platform2)) {
      if (navigator.maxTouchPoints === 5)
        return "ios";
      return "macos";
    }
    if (/^win/i.test(platform2))
      return "windows";
    if (/android/i.test(navigator.userAgent))
      return "android";
    if (/iphone|ipod|ipad/i.test(navigator.userAgent))
      return "ios";
    if (/\bcros\b/i.test(navigator.userAgent))
      return "chromeos";
    return "other";
  }
  function supportRegexPropertyEscape() {
    if (!isBrowser())
      return true;
    if (/firefox/i.test(navigator.userAgent)) {
      const m = navigator.userAgent.match(/firefox\/(\d+)/i);
      if (!m)
        return false;
      const version2 = parseInt(m[1]);
      return version2 >= 78;
    }
    if (/trident/i.test(navigator.userAgent))
      return false;
    if (/edge/i.test(navigator.userAgent)) {
      const m = navigator.userAgent.match(/edg\/(\d+)/i);
      if (!m)
        return false;
      const version2 = parseInt(m[1]);
      return version2 >= 79;
    }
    return true;
  }

  // src/core/l10n.ts
  var l10n = {
    strings: STRINGS,
    _locale: "",
    //  Important! Set the locale to empty so it can be determined at runtime
    // Add getter and setter for the _locale property of l10n
    get locale() {
      if (!l10n._locale)
        l10n._locale = isBrowser() ? navigator.language.slice(0, 5) : "en";
      return l10n._locale;
    },
    set locale(value) {
      l10n._locale = value;
    },
    /*
     * Two forms for this function:
     * - merge(locale, strings)
     * Merge a dictionary of keys -> values for the specified locale
     * - merge(strings)
     * Merge a dictionary of locale code -> dictionary of keys -> values
     *
     */
    merge(locale, strings) {
      if (locale && strings) {
        const savedLocale = l10n._locale;
        l10n.locale = locale;
        l10n.strings[locale] = __spreadValues(__spreadValues({}, l10n.strings[locale]), strings);
        l10n.locale = savedLocale;
      } else if (locale && !strings) {
        for (const l of Object.keys(
          locale
        ))
          l10n.merge(l, locale[l]);
      }
    }
  };
  function localize(key) {
    if (key === void 0)
      return void 0;
    const language = l10n.locale.slice(0, 2);
    let result = "";
    if (l10n.strings[l10n.locale])
      result = l10n.strings[l10n.locale][key];
    if (!result && l10n.strings[language])
      result = l10n.strings[language][key];
    if (!result)
      result = l10n.strings.en[key];
    if (!result)
      return void 0;
    return result;
  }

  // src/core/color.ts
  var MATHEMATICA_COLORS = {
    m0: "#3F3D99",
    // Strong blue
    m1: "#993D71",
    // Strong cerise
    m2: "#998B3D",
    // Strong gold
    m3: "#3D9956",
    // Malachite green
    m4: "#3D5A99",
    // Strong cobalt blue
    m5: "#993D90",
    // Strong orchid
    m6: "#996D3D",
    // Strong orange
    m7: "#43993D",
    // Strong sap green
    m8: "#3D7999",
    // Cornflower blue
    m9: "#843D99"
    // Mulberry
  };
  var MATLAB_COLORS = {
    blue: "#0072BD",
    // [0, 0.4470, 0.7410]             blue
    orange: "#D95319",
    // [0.8500, 0.3250, 0.0980]        orange
    yellow: "#EDB120",
    // [0.9290, 0.6940, 0.1250]       yellow
    purple: "#7E2F8E",
    // [0.4940, 0.1840, 0.5560]       purple
    green: "#77AC30",
    // [0.4660, 0.6740, 0.1880]       green
    cyan: "#4DBEEE",
    // [0.3010, 0.7450, 0.9330]       cyan
    red: "#A2142F"
    // [0.6350, 0.0780, 0.1840]	    dark red
  };
  var BACKGROUND_COLORS = {
    "red": "#fbbbb6",
    "orange": "#ffe0c2",
    "yellow": "#fff1c2",
    "lime": "#d0e8b9",
    "green": "#bceac4",
    "teal": "#b9f1f1",
    "blue": "#b6d9fb",
    "indigo": "#d1c2f0",
    "purple": "#e3baf8",
    "magenta": "#f9c8e0",
    "black": "#353535",
    "dark-grey": "#8C8C8C",
    "grey": "#D0D0D0",
    "light-grey": "#F0F0F0",
    "white": "#ffffff"
  };
  var FOREGROUND_COLORS = {
    "red": "#d7170b",
    //<- 700, 500 ->'#f21c0d'
    "orange": "#fe8a2b",
    "yellow": "#ffc02b",
    // <- 600, 500 -> '#ffcf33',
    "lime": "#63b215",
    "green": "#21ba3a",
    "teal": "#17cfcf",
    "blue": "#0d80f2",
    "indigo": "#63c",
    "purple": "#a219e6",
    "magenta": "#eb4799",
    "black": "#000",
    "dark-grey": "#666",
    "grey": "#A6A6A6",
    "light-grey": "#d4d5d2",
    "white": "#ffffff"
  };
  var DVIPS_TO_CHROMATIC = {
    Red: "red",
    Orange: "orange",
    Yellow: "yellow",
    LimeGreen: "lime",
    Green: "green",
    TealBlue: "teal",
    Blue: "blue",
    Violet: "indigo",
    Purple: "purple",
    Magenta: "magenta",
    Black: "black",
    Gray: "grey",
    White: "white"
  };
  var DVIPS_COLORS = {
    Apricot: "#FBB982",
    Aquamarine: "#00B5BE",
    Bittersweet: "#C04F17",
    Black: "#221E1F",
    // Indeed.
    Blue: "#2D2F92",
    BlueGreen: "#00B3B8",
    BlueViolet: "#473992",
    BrickRed: "#B6321C",
    Brown: "#792500",
    BurntOrange: "#F7921D",
    CadetBlue: "#74729A",
    CarnationPink: "#F282B4",
    Cerulean: "#00A2E3",
    CornflowerBlue: "#41B0E4",
    Cyan: "#00AEEF",
    Dandelion: "#FDBC42",
    DarkOrchid: "#A4538A",
    Emerald: "#00A99D",
    ForestGreen: "#009B55",
    Fuchsia: "#8C368C",
    Goldenrod: "#FFDF42",
    Gray: "#949698",
    Green: "#00A64F",
    GreenYellow: "#DFE674",
    JungleGreen: "#00A99A",
    Lavender: "#F49EC4",
    Limegreen: "#8DC73E",
    Magenta: "#EC008C",
    Mahogany: "#A9341F",
    Maroon: "#AF3235",
    Melon: "#F89E7B",
    MidnightBlue: "#006795",
    Mulberry: "#A93C93",
    NavyBlue: "#006EB8",
    OliveGreen: "#3C8031",
    Orange: "#F58137",
    OrangeRed: "#ED135A",
    Orchid: "#AF72B0",
    Peach: "#F7965A",
    Periwinkle: "#7977B8",
    PineGreen: "#008B72",
    Plum: "#92268F",
    ProcessBlue: "#00B0F0",
    Purple: "#99479B",
    RawSienna: "#974006",
    Red: "#ED1B23",
    RedOrange: "#F26035",
    RedViolet: "#A1246B",
    Rhodamine: "#EF559F",
    RoyalBlue: "#0071BC",
    RoyalPurple: "#613F99",
    RubineRed: "#ED017D",
    Salmon: "#F69289",
    SeaGreen: "#3FBC9D",
    Sepia: "#671800",
    SkyBlue: "#46C5DD",
    SpringGreen: "#C6DC67",
    Tan: "#DA9D76",
    TealBlue: "#00AEB3",
    Thistle: "#D883B7",
    Turquoise: "#00B4CE",
    Violet: "#58429B",
    VioletRed: "#EF58A0",
    White: "#FFFFFF",
    WildStrawberry: "#EE2967",
    Yellow: "#FFF200",
    YellowGreen: "#98CC70",
    YellowOrange: "#FAA21A"
  };
  function defaultColorMap(s) {
    var _a3, _b3, _c2, _d2, _e, _f;
    const colorSpec = s.split("!");
    let baseRed;
    let baseGreen;
    let baseBlue;
    let red = 255;
    let green = 255;
    let blue = 255;
    let mix = -1;
    const complementary = colorSpec.length > 0 && colorSpec[0].startsWith("-");
    if (complementary)
      colorSpec[0] = colorSpec[0].slice(1);
    for (let i = 0; i < colorSpec.length; i++) {
      baseRed = red;
      baseGreen = green;
      baseBlue = blue;
      const colorName = (_a3 = colorSpec[i].trim().match(/^([A-Za-z\d]+)/)) == null ? void 0 : _a3[1];
      const lcColorName = colorName == null ? void 0 : colorName.toLowerCase();
      const color = !colorName ? colorSpec[i].trim() : (_f = (_e = (_d2 = (_c2 = (_b3 = FOREGROUND_COLORS[lcColorName]) != null ? _b3 : FOREGROUND_COLORS[DVIPS_TO_CHROMATIC[colorName]]) != null ? _c2 : MATLAB_COLORS[colorName]) != null ? _d2 : DVIPS_COLORS[colorName]) != null ? _e : MATHEMATICA_COLORS[colorName]) != null ? _f : colorSpec[i].trim();
      let m = color.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i);
      if ((m == null ? void 0 : m[1]) && m[2] && m[3]) {
        red = Math.max(0, Math.min(255, Number.parseInt(m[1], 16)));
        green = Math.max(0, Math.min(255, Number.parseInt(m[2], 16)));
        blue = Math.max(0, Math.min(255, Number.parseInt(m[3], 16)));
      } else {
        m = color.match(/^#([\da-f]{3})$/i);
        if (m == null ? void 0 : m[1]) {
          const r1 = Number.parseInt(m[1][0], 16);
          const g1 = Number.parseInt(m[1][1], 16);
          const b1 = Number.parseInt(m[1][2], 16);
          red = Math.max(0, Math.min(255, r1 * 16 + r1));
          green = Math.max(0, Math.min(255, g1 * 16 + g1));
          blue = Math.max(0, Math.min(255, b1 * 16 + b1));
        } else {
          m = color.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
          if ((m == null ? void 0 : m[1]) && m[2] && m[3]) {
            red = Math.max(0, Math.min(255, Number.parseInt(m[1])));
            green = Math.max(0, Math.min(255, Number.parseInt(m[2])));
            blue = Math.max(0, Math.min(255, Number.parseInt(m[3])));
          } else
            return void 0;
        }
      }
      if (mix >= 0) {
        red = (1 - mix) * red + mix * baseRed;
        green = (1 - mix) * green + mix * baseGreen;
        blue = (1 - mix) * blue + mix * baseBlue;
        mix = -1;
      }
      if (i + 1 < colorSpec.length)
        mix = Math.max(0, Math.min(100, Number.parseInt(colorSpec[++i]))) / 100;
    }
    if (mix >= 0) {
      red = mix * red + (1 - mix) * baseRed;
      green = mix * green + (1 - mix) * baseGreen;
      blue = mix * blue + (1 - mix) * baseBlue;
    }
    if (complementary) {
      red = 255 - red;
      green = 255 - green;
      blue = 255 - blue;
    }
    return "#" + ("00" + Math.round(red).toString(16)).slice(-2) + ("00" + Math.round(green).toString(16)).slice(-2) + ("00" + Math.round(blue).toString(16)).slice(-2);
  }
  function defaultBackgroundColorMap(s) {
    var _a3, _b3;
    s = s.trim();
    return (_b3 = (_a3 = BACKGROUND_COLORS[s.toLowerCase()]) != null ? _a3 : BACKGROUND_COLORS[DVIPS_TO_CHROMATIC[s]]) != null ? _b3 : defaultColorMap(s);
  }
  function parseHex(hex) {
    if (!hex)
      return void 0;
    if (hex[0] !== "#")
      return void 0;
    hex = hex.slice(1);
    let result;
    if (hex.length <= 4) {
      result = {
        r: parseInt(hex[0] + hex[0], 16),
        g: parseInt(hex[1] + hex[1], 16),
        b: parseInt(hex[2] + hex[2], 16)
      };
      if (hex.length === 4)
        result.a = parseInt(hex[3] + hex[3], 16) / 255;
    } else {
      result = {
        r: parseInt(hex[0] + hex[1], 16),
        g: parseInt(hex[2] + hex[3], 16),
        b: parseInt(hex[4] + hex[5], 16)
      };
      if (hex.length === 8)
        result.a = parseInt(hex[6] + hex[7], 16) / 255;
    }
    if (result && result.a === void 0)
      result.a = 1;
    return result;
  }
  function hueToRgbChannel(t1, t2, hue) {
    if (hue < 0)
      hue += 6;
    if (hue >= 6)
      hue -= 6;
    if (hue < 1)
      return (t2 - t1) * hue + t1;
    else if (hue < 3)
      return t2;
    else if (hue < 4)
      return (t2 - t1) * (4 - hue) + t1;
    return t1;
  }
  function hslToRgb(hsl) {
    let [hue, sat, light] = [hsl.h, hsl.s, hsl.l];
    hue = (hue + 360) % 360 / 60;
    light = Math.max(0, Math.min(light, 1));
    sat = Math.max(0, Math.min(sat, 1));
    const t2 = light <= 0.5 ? light * (sat + 1) : light + sat - light * sat;
    const t1 = light * 2 - t2;
    return {
      r: Math.round(255 * hueToRgbChannel(t1, t2, hue + 2)),
      g: Math.round(255 * hueToRgbChannel(t1, t2, hue)),
      b: Math.round(255 * hueToRgbChannel(t1, t2, hue - 2))
    };
  }
  function clampByte(v) {
    if (v < 0)
      return 0;
    if (v > 255)
      return 255;
    return Math.round(v);
  }
  function rgbToHexstring(rgb) {
    const { r, g, b } = rgb;
    let hexString = ((1 << 24) + (clampByte(r) << 16) + (clampByte(g) << 8) + clampByte(b)).toString(16).slice(1);
    if (hexString[0] === hexString[1] && hexString[2] === hexString[3] && hexString[4] === hexString[5] && hexString[6] === hexString[7])
      hexString = hexString[0] + hexString[2] + hexString[4];
    return "#" + hexString;
  }
  function rgbToHsl(rgb) {
    let { r, g, b } = rgb;
    r = r / 255;
    g = g / 255;
    b = b / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min)
      h = 0;
    else if (r === max)
      h = (g - b) / delta;
    else if (g === max)
      h = 2 + (b - r) / delta;
    else if (b === max)
      h = 4 + (r - g) / delta;
    h = Math.min(h * 60, 360);
    if (h < 0)
      h += 360;
    const l = (min + max) / 2;
    if (max === min)
      s = 0;
    else if (l <= 0.5)
      s = delta / (max + min);
    else
      s = delta / (2 - max - min);
    return { h, s, l };
  }
  function highlight(color) {
    let rgb = parseHex(color);
    if (!rgb)
      return color;
    let { h, s, l } = rgbToHsl(rgb);
    s += 0.1;
    l -= 0.1;
    return rgbToHexstring(hslToRgb({ h, s, l }));
  }

  // src/core/font-metrics-data.ts
  var M6 = [0, 0.69444, 0, 0];
  var M11 = [0, 0.61111, 0, 0];
  var M15 = [0.25, 0.75, 0, 0];
  var M7 = [0, 0.44444, 0, 0];
  var M4 = [0, 0.68611, 0, 0];
  var M16 = [0.19444, 0.69444, 0, 0];
  var M9 = [0, 0.68333, 0, 0];
  var M1 = [0, 0.68889, 0, 0];
  var M21 = [0, 0.69141, 0, 0];
  var M0 = [0, 0, 0, 0];
  var M5 = [0, 0.64444, 0, 0];
  var M3 = [0, 0.69224, 0, 0];
  var M8 = [0.19444, 0.44444, 0, 0];
  var M19 = [0.65002, 1.15, 0, 0];
  var M20 = [0, 0.55556, 0, 0];
  var M10 = [0.35001, 0.85, 0, 0];
  var M12 = [1.25003, 1.75, 0, 0];
  var M13 = [0.95003, 1.45, 0, 0];
  var M14 = [0, 0.75, 0, 0];
  var M22 = [0, 0.47534, 0, 0];
  var M17 = [0.25001, 0.75, 0, 0];
  var M18 = [0.55001, 1.05, 0, 0];
  var M2 = [0.16667, 0.68889, 0, 0];
  var M23 = [0.08167, 0.58167, 0, 0];
  var font_metrics_data_default = {
    "AMS-Regular": {
      "32": M0,
      "65": M1,
      "66": M1,
      "67": M1,
      "68": M1,
      "69": M1,
      "70": M1,
      "71": M1,
      "72": M1,
      "73": M1,
      "74": M2,
      "75": M1,
      "76": M1,
      "77": M1,
      "78": M1,
      "79": M2,
      "80": M1,
      "81": M2,
      "82": M1,
      "83": M1,
      "84": M1,
      "85": M1,
      "86": M1,
      "87": M1,
      "88": M1,
      "89": M1,
      "90": M1,
      "107": M1,
      "160": M0,
      "165": [0, 0.675, 0.025, 0],
      "174": [0.15559, 0.69224, 0, 0],
      "240": M1,
      "295": M1,
      "710": [0, 0.825, 0, 0],
      "732": [0, 0.9, 0, 0],
      "770": [0, 0.825, 0, 0],
      "771": [0, 0.9, 0, 0],
      "989": M23,
      "1008": [0, 0.43056, 0.04028, 0],
      "8245": [0, 0.54986, 0, 0],
      "8463": M1,
      "8487": M1,
      "8498": M1,
      "8502": M1,
      "8503": M1,
      "8504": M1,
      "8513": M1,
      "8592": [-0.03598, 0.46402, 0, 0],
      "8594": [-0.03598, 0.46402, 0, 0],
      "8602": [-0.13313, 0.36687, 0, 0],
      "8603": [-0.13313, 0.36687, 0, 0],
      "8606": [0.01354, 0.52239, 0, 0],
      "8608": [0.01354, 0.52239, 0, 0],
      "8610": [0.01354, 0.52239, 0, 0],
      "8611": [0.01354, 0.52239, 0, 0],
      "8619": [0, 0.54986, 0, 0],
      "8620": [0, 0.54986, 0, 0],
      "8621": [-0.13313, 0.37788, 0, 0],
      "8622": [-0.13313, 0.36687, 0, 0],
      "8624": M3,
      "8625": M3,
      "8630": [0, 0.43056, 0, 0],
      "8631": [0, 0.43056, 0, 0],
      "8634": [0.08198, 0.58198, 0, 0],
      "8635": [0.08198, 0.58198, 0, 0],
      "8638": [0.19444, 0.69224, 0, 0],
      "8639": [0.19444, 0.69224, 0, 0],
      "8642": [0.19444, 0.69224, 0, 0],
      "8643": [0.19444, 0.69224, 0, 0],
      "8644": [0.1808, 0.675, 0, 0],
      "8646": [0.1808, 0.675, 0, 0],
      "8647": [0.1808, 0.675, 0, 0],
      "8648": [0.19444, 0.69224, 0, 0],
      "8649": [0.1808, 0.675, 0, 0],
      "8650": [0.19444, 0.69224, 0, 0],
      "8651": [0.01354, 0.52239, 0, 0],
      "8652": [0.01354, 0.52239, 0, 0],
      "8653": [-0.13313, 0.36687, 0, 0],
      "8654": [-0.13313, 0.36687, 0, 0],
      "8655": [-0.13313, 0.36687, 0, 0],
      "8666": [0.13667, 0.63667, 0, 0],
      "8667": [0.13667, 0.63667, 0, 0],
      "8669": [-0.13313, 0.37788, 0, 0],
      "8672": [-0.064, 0.437, 0, 0],
      "8674": [-0.064, 0.437, 0, 0],
      "8705": [0, 0.825, 0, 0],
      "8708": M1,
      "8709": M23,
      "8717": [0, 0.43056, 0, 0],
      "8722": [-0.03598, 0.46402, 0, 0],
      "8724": [0.08198, 0.69224, 0, 0],
      "8726": M23,
      "8733": M3,
      "8736": M3,
      "8737": M3,
      "8738": [0.03517, 0.52239, 0, 0],
      "8739": M23,
      "8740": [0.25142, 0.74111, 0, 0],
      "8741": M23,
      "8742": [0.25142, 0.74111, 0, 0],
      "8756": M3,
      "8757": M3,
      "8764": [-0.13313, 0.36687, 0, 0],
      "8765": [-0.13313, 0.37788, 0, 0],
      "8769": [-0.13313, 0.36687, 0, 0],
      "8770": [-0.03625, 0.46375, 0, 0],
      "8774": [0.30274, 0.79383, 0, 0],
      "8776": [-0.01688, 0.48312, 0, 0],
      "8778": M23,
      "8782": [0.06062, 0.54986, 0, 0],
      "8783": [0.06062, 0.54986, 0, 0],
      "8785": [0.08198, 0.58198, 0, 0],
      "8786": [0.08198, 0.58198, 0, 0],
      "8787": [0.08198, 0.58198, 0, 0],
      "8790": M3,
      "8791": [0.22958, 0.72958, 0, 0],
      "8796": [0.08198, 0.91667, 0, 0],
      "8806": [0.25583, 0.75583, 0, 0],
      "8807": [0.25583, 0.75583, 0, 0],
      "8808": [0.25142, 0.75726, 0, 0],
      "8809": [0.25142, 0.75726, 0, 0],
      "8812": [0.25583, 0.75583, 0, 0],
      "8814": [0.20576, 0.70576, 0, 0],
      "8815": [0.20576, 0.70576, 0, 0],
      "8816": [0.30274, 0.79383, 0, 0],
      "8817": [0.30274, 0.79383, 0, 0],
      "8818": [0.22958, 0.72958, 0, 0],
      "8819": [0.22958, 0.72958, 0, 0],
      "8822": [0.1808, 0.675, 0, 0],
      "8823": [0.1808, 0.675, 0, 0],
      "8828": [0.13667, 0.63667, 0, 0],
      "8829": [0.13667, 0.63667, 0, 0],
      "8830": [0.22958, 0.72958, 0, 0],
      "8831": [0.22958, 0.72958, 0, 0],
      "8832": [0.20576, 0.70576, 0, 0],
      "8833": [0.20576, 0.70576, 0, 0],
      "8840": [0.30274, 0.79383, 0, 0],
      "8841": [0.30274, 0.79383, 0, 0],
      "8842": [0.13597, 0.63597, 0, 0],
      "8843": [0.13597, 0.63597, 0, 0],
      "8847": [0.03517, 0.54986, 0, 0],
      "8848": [0.03517, 0.54986, 0, 0],
      "8858": [0.08198, 0.58198, 0, 0],
      "8859": [0.08198, 0.58198, 0, 0],
      "8861": [0.08198, 0.58198, 0, 0],
      "8862": [0, 0.675, 0, 0],
      "8863": [0, 0.675, 0, 0],
      "8864": [0, 0.675, 0, 0],
      "8865": [0, 0.675, 0, 0],
      "8872": M3,
      "8873": M3,
      "8874": M3,
      "8876": M1,
      "8877": M1,
      "8878": M1,
      "8879": M1,
      "8882": [0.03517, 0.54986, 0, 0],
      "8883": [0.03517, 0.54986, 0, 0],
      "8884": [0.13667, 0.63667, 0, 0],
      "8885": [0.13667, 0.63667, 0, 0],
      "8888": [0, 0.54986, 0, 0],
      "8890": [0.19444, 0.43056, 0, 0],
      "8891": [0.19444, 0.69224, 0, 0],
      "8892": [0.19444, 0.69224, 0, 0],
      "8901": [0, 0.54986, 0, 0],
      "8903": M23,
      "8905": M23,
      "8906": M23,
      "8907": M3,
      "8908": M3,
      "8909": [-0.03598, 0.46402, 0, 0],
      "8910": [0, 0.54986, 0, 0],
      "8911": [0, 0.54986, 0, 0],
      "8912": [0.03517, 0.54986, 0, 0],
      "8913": [0.03517, 0.54986, 0, 0],
      "8914": [0, 0.54986, 0, 0],
      "8915": [0, 0.54986, 0, 0],
      "8916": M3,
      "8918": [0.0391, 0.5391, 0, 0],
      "8919": [0.0391, 0.5391, 0, 0],
      "8920": [0.03517, 0.54986, 0, 0],
      "8921": [0.03517, 0.54986, 0, 0],
      "8922": [0.38569, 0.88569, 0, 0],
      "8923": [0.38569, 0.88569, 0, 0],
      "8926": [0.13667, 0.63667, 0, 0],
      "8927": [0.13667, 0.63667, 0, 0],
      "8928": [0.30274, 0.79383, 0, 0],
      "8929": [0.30274, 0.79383, 0, 0],
      "8934": [0.23222, 0.74111, 0, 0],
      "8935": [0.23222, 0.74111, 0, 0],
      "8936": [0.23222, 0.74111, 0, 0],
      "8937": [0.23222, 0.74111, 0, 0],
      "8938": [0.20576, 0.70576, 0, 0],
      "8939": [0.20576, 0.70576, 0, 0],
      "8940": [0.30274, 0.79383, 0, 0],
      "8941": [0.30274, 0.79383, 0, 0],
      "8994": [0.19444, 0.69224, 0, 0],
      "8995": [0.19444, 0.69224, 0, 0],
      "9416": [0.15559, 0.69224, 0, 0],
      "9484": M3,
      "9488": M3,
      "9492": [0, 0.37788, 0, 0],
      "9496": [0, 0.37788, 0, 0],
      "9585": [0.19444, 0.68889, 0, 0],
      "9586": [0.19444, 0.74111, 0, 0],
      "9632": [0, 0.675, 0, 0],
      "9633": [0, 0.675, 0, 0],
      "9650": [0, 0.54986, 0, 0],
      "9651": [0, 0.54986, 0, 0],
      "9654": [0.03517, 0.54986, 0, 0],
      "9660": [0, 0.54986, 0, 0],
      "9661": [0, 0.54986, 0, 0],
      "9664": [0.03517, 0.54986, 0, 0],
      "9674": [0.11111, 0.69224, 0, 0],
      "9733": [0.19444, 0.69224, 0, 0],
      "10003": M3,
      "10016": M3,
      "10731": [0.11111, 0.69224, 0, 0],
      "10846": [0.19444, 0.75583, 0, 0],
      "10877": [0.13667, 0.63667, 0, 0],
      "10878": [0.13667, 0.63667, 0, 0],
      "10885": [0.25583, 0.75583, 0, 0],
      "10886": [0.25583, 0.75583, 0, 0],
      "10887": [0.13597, 0.63597, 0, 0],
      "10888": [0.13597, 0.63597, 0, 0],
      "10889": [0.26167, 0.75726, 0, 0],
      "10890": [0.26167, 0.75726, 0, 0],
      "10891": [0.48256, 0.98256, 0, 0],
      "10892": [0.48256, 0.98256, 0, 0],
      "10901": [0.13667, 0.63667, 0, 0],
      "10902": [0.13667, 0.63667, 0, 0],
      "10933": [0.25142, 0.75726, 0, 0],
      "10934": [0.25142, 0.75726, 0, 0],
      "10935": [0.26167, 0.75726, 0, 0],
      "10936": [0.26167, 0.75726, 0, 0],
      "10937": [0.26167, 0.75726, 0, 0],
      "10938": [0.26167, 0.75726, 0, 0],
      "10949": [0.25583, 0.75583, 0, 0],
      "10950": [0.25583, 0.75583, 0, 0],
      "10955": [0.28481, 0.79383, 0, 0],
      "10956": [0.28481, 0.79383, 0, 0],
      "57350": M23,
      "57351": M23,
      "57352": M23,
      "57353": [0, 0.43056, 0.04028, 0],
      "57356": [0.25142, 0.75726, 0, 0],
      "57357": [0.25142, 0.75726, 0, 0],
      "57358": [0.41951, 0.91951, 0, 0],
      "57359": [0.30274, 0.79383, 0, 0],
      "57360": [0.30274, 0.79383, 0, 0],
      "57361": [0.41951, 0.91951, 0, 0],
      "57366": [0.25142, 0.75726, 0, 0],
      "57367": [0.25142, 0.75726, 0, 0],
      "57368": [0.25142, 0.75726, 0, 0],
      "57369": [0.25142, 0.75726, 0, 0],
      "57370": [0.13597, 0.63597, 0, 0],
      "57371": [0.13597, 0.63597, 0, 0]
    },
    "Caligraphic-Regular": {
      "32": M0,
      "65": [0, 0.68333, 0, 0.19445],
      "66": [0, 0.68333, 0.03041, 0.13889],
      "67": [0, 0.68333, 0.05834, 0.13889],
      "68": [0, 0.68333, 0.02778, 0.08334],
      "69": [0, 0.68333, 0.08944, 0.11111],
      "70": [0, 0.68333, 0.09931, 0.11111],
      "71": [0.09722, 0.68333, 0.0593, 0.11111],
      "72": [0, 0.68333, 965e-5, 0.11111],
      "73": [0, 0.68333, 0.07382, 0],
      "74": [0.09722, 0.68333, 0.18472, 0.16667],
      "75": [0, 0.68333, 0.01445, 0.05556],
      "76": [0, 0.68333, 0, 0.13889],
      "77": [0, 0.68333, 0, 0.13889],
      "78": [0, 0.68333, 0.14736, 0.08334],
      "79": [0, 0.68333, 0.02778, 0.11111],
      "80": [0, 0.68333, 0.08222, 0.08334],
      "81": [0.09722, 0.68333, 0, 0.11111],
      "82": [0, 0.68333, 0, 0.08334],
      "83": [0, 0.68333, 0.075, 0.13889],
      "84": [0, 0.68333, 0.25417, 0],
      "85": [0, 0.68333, 0.09931, 0.08334],
      "86": [0, 0.68333, 0.08222, 0],
      "87": [0, 0.68333, 0.08222, 0.08334],
      "88": [0, 0.68333, 0.14643, 0.13889],
      "89": [0.09722, 0.68333, 0.08222, 0.08334],
      "90": [0, 0.68333, 0.07944, 0.13889],
      "160": M0
    },
    "Fraktur-Regular": {
      "32": M0,
      "33": M21,
      "34": M21,
      "38": M21,
      "39": M21,
      "40": [0.24982, 0.74947, 0, 0],
      "41": [0.24982, 0.74947, 0, 0],
      "42": [0, 0.62119, 0, 0],
      "43": [0.08319, 0.58283, 0, 0],
      "44": [0, 0.10803, 0, 0],
      "45": [0.08319, 0.58283, 0, 0],
      "46": [0, 0.10803, 0, 0],
      "47": [0.24982, 0.74947, 0, 0],
      "48": M22,
      "49": M22,
      "50": M22,
      "51": [0.18906, 0.47534, 0, 0],
      "52": [0.18906, 0.47534, 0, 0],
      "53": [0.18906, 0.47534, 0, 0],
      "54": M21,
      "55": [0.18906, 0.47534, 0, 0],
      "56": M21,
      "57": [0.18906, 0.47534, 0, 0],
      "58": M22,
      "59": [0.12604, 0.47534, 0, 0],
      "61": [-0.13099, 0.36866, 0, 0],
      "63": M21,
      "65": M21,
      "66": M21,
      "67": M21,
      "68": M21,
      "69": M21,
      "70": [0.12604, 0.69141, 0, 0],
      "71": M21,
      "72": [0.06302, 0.69141, 0, 0],
      "73": M21,
      "74": [0.12604, 0.69141, 0, 0],
      "75": M21,
      "76": M21,
      "77": M21,
      "78": M21,
      "79": M21,
      "80": [0.18906, 0.69141, 0, 0],
      "81": [0.03781, 0.69141, 0, 0],
      "82": M21,
      "83": M21,
      "84": M21,
      "85": M21,
      "86": M21,
      "87": M21,
      "88": M21,
      "89": [0.18906, 0.69141, 0, 0],
      "90": [0.12604, 0.69141, 0, 0],
      "91": [0.24982, 0.74947, 0, 0],
      "93": [0.24982, 0.74947, 0, 0],
      "94": M21,
      "97": M22,
      "98": M21,
      "99": M22,
      "100": [0, 0.62119, 0, 0],
      "101": M22,
      "102": [0.18906, 0.69141, 0, 0],
      "103": [0.18906, 0.47534, 0, 0],
      "104": [0.18906, 0.69141, 0, 0],
      "105": M21,
      "106": M21,
      "107": M21,
      "108": M21,
      "109": M22,
      "110": M22,
      "111": M22,
      "112": [0.18906, 0.52396, 0, 0],
      "113": [0.18906, 0.47534, 0, 0],
      "114": M22,
      "115": M22,
      "116": [0, 0.62119, 0, 0],
      "117": M22,
      "118": [0, 0.52396, 0, 0],
      "119": [0, 0.52396, 0, 0],
      "120": [0.18906, 0.47534, 0, 0],
      "121": [0.18906, 0.47534, 0, 0],
      "122": [0.18906, 0.47534, 0, 0],
      "160": M0,
      "8216": M21,
      "8217": M21,
      "58112": [0, 0.62119, 0, 0],
      "58113": [0, 0.62119, 0, 0],
      "58114": [0.18906, 0.69141, 0, 0],
      "58115": [0.18906, 0.69141, 0, 0],
      "58116": [0.18906, 0.47534, 0, 0],
      "58117": M21,
      "58118": [0, 0.62119, 0, 0],
      "58119": M22
    },
    "Main-Bold": {
      "32": M0,
      "33": M6,
      "34": M6,
      "35": M16,
      "36": [0.05556, 0.75, 0, 0],
      "37": [0.05556, 0.75, 0, 0],
      "38": M6,
      "39": M6,
      "40": M15,
      "41": M15,
      "42": M14,
      "43": [0.13333, 0.63333, 0, 0],
      "44": [0.19444, 0.15556, 0, 0],
      "45": M7,
      "46": [0, 0.15556, 0, 0],
      "47": M15,
      "48": M5,
      "49": M5,
      "50": M5,
      "51": M5,
      "52": M5,
      "53": M5,
      "54": M5,
      "55": M5,
      "56": M5,
      "57": M5,
      "58": M7,
      "59": M8,
      "60": [0.08556, 0.58556, 0, 0],
      "61": [-0.10889, 0.39111, 0, 0],
      "62": [0.08556, 0.58556, 0, 0],
      "63": M6,
      "64": M6,
      "65": M4,
      "66": M4,
      "67": M4,
      "68": M4,
      "69": M4,
      "70": M4,
      "71": M4,
      "72": M4,
      "73": M4,
      "74": M4,
      "75": M4,
      "76": M4,
      "77": M4,
      "78": M4,
      "79": M4,
      "80": M4,
      "81": [0.19444, 0.68611, 0, 0],
      "82": M4,
      "83": M4,
      "84": M4,
      "85": M4,
      "86": [0, 0.68611, 0.01597, 0],
      "87": [0, 0.68611, 0.01597, 0],
      "88": M4,
      "89": [0, 0.68611, 0.02875, 0],
      "90": M4,
      "91": M15,
      "92": M15,
      "93": M15,
      "94": M6,
      "95": [0.31, 0.13444, 0.03194, 0],
      "97": M7,
      "98": M6,
      "99": M7,
      "100": M6,
      "101": M7,
      "102": [0, 0.69444, 0.10903, 0],
      "103": [0.19444, 0.44444, 0.01597, 0],
      "104": M6,
      "105": M6,
      "106": M16,
      "107": M6,
      "108": M6,
      "109": M7,
      "110": M7,
      "111": M7,
      "112": M8,
      "113": M8,
      "114": M7,
      "115": M7,
      "116": [0, 0.63492, 0, 0],
      "117": M7,
      "118": [0, 0.44444, 0.01597, 0],
      "119": [0, 0.44444, 0.01597, 0],
      "120": M7,
      "121": [0.19444, 0.44444, 0.01597, 0],
      "122": M7,
      "123": M15,
      "124": M15,
      "125": M15,
      "126": [0.35, 0.34444, 0, 0],
      "160": M0,
      "163": M6,
      "168": M6,
      "172": M7,
      "176": M6,
      "177": [0.13333, 0.63333, 0, 0],
      "184": [0.17014, 0, 0, 0],
      "198": M4,
      "215": [0.13333, 0.63333, 0, 0],
      "216": [0.04861, 0.73472, 0, 0],
      "223": M6,
      "230": M7,
      "247": [0.13333, 0.63333, 0, 0],
      "248": [0.09722, 0.54167, 0, 0],
      "305": M7,
      "338": M4,
      "339": M7,
      "567": M8,
      "710": M6,
      "711": [0, 0.63194, 0, 0],
      "713": [0, 0.59611, 0, 0],
      "714": M6,
      "715": M6,
      "728": M6,
      "729": M6,
      "730": M6,
      "732": M6,
      "733": M6,
      "915": M4,
      "916": M4,
      "920": M4,
      "923": M4,
      "926": M4,
      "928": M4,
      "931": M4,
      "933": M4,
      "934": M4,
      "936": M4,
      "937": M4,
      "8211": [0, 0.44444, 0.03194, 0],
      "8212": [0, 0.44444, 0.03194, 0],
      "8216": M6,
      "8217": M6,
      "8220": M6,
      "8221": M6,
      "8224": M16,
      "8225": M16,
      "8242": M20,
      "8407": [0, 0.72444, 0.15486, 0],
      "8463": M6,
      "8465": M6,
      "8467": M6,
      "8472": M8,
      "8476": M6,
      "8501": M6,
      "8592": [-0.10889, 0.39111, 0, 0],
      "8593": M16,
      "8594": [-0.10889, 0.39111, 0, 0],
      "8595": M16,
      "8596": [-0.10889, 0.39111, 0, 0],
      "8597": M15,
      "8598": M16,
      "8599": M16,
      "8600": M16,
      "8601": M16,
      "8636": [-0.10889, 0.39111, 0, 0],
      "8637": [-0.10889, 0.39111, 0, 0],
      "8640": [-0.10889, 0.39111, 0, 0],
      "8641": [-0.10889, 0.39111, 0, 0],
      "8656": [-0.10889, 0.39111, 0, 0],
      "8657": M16,
      "8658": [-0.10889, 0.39111, 0, 0],
      "8659": M16,
      "8660": [-0.10889, 0.39111, 0, 0],
      "8661": M15,
      "8704": M6,
      "8706": [0, 0.69444, 0.06389, 0],
      "8707": M6,
      "8709": [0.05556, 0.75, 0, 0],
      "8711": M4,
      "8712": [0.08556, 0.58556, 0, 0],
      "8715": [0.08556, 0.58556, 0, 0],
      "8722": [0.13333, 0.63333, 0, 0],
      "8723": [0.13333, 0.63333, 0, 0],
      "8725": M15,
      "8726": M15,
      "8727": [-0.02778, 0.47222, 0, 0],
      "8728": [-0.02639, 0.47361, 0, 0],
      "8729": [-0.02639, 0.47361, 0, 0],
      "8730": [0.18, 0.82, 0, 0],
      "8733": M7,
      "8734": M7,
      "8736": M3,
      "8739": M15,
      "8741": M15,
      "8743": M20,
      "8744": M20,
      "8745": M20,
      "8746": M20,
      "8747": [0.19444, 0.69444, 0.12778, 0],
      "8764": [-0.10889, 0.39111, 0, 0],
      "8768": M16,
      "8771": [222e-5, 0.50222, 0, 0],
      "8776": [0.02444, 0.52444, 0, 0],
      "8781": [222e-5, 0.50222, 0, 0],
      "8801": [222e-5, 0.50222, 0, 0],
      "8804": [0.19667, 0.69667, 0, 0],
      "8805": [0.19667, 0.69667, 0, 0],
      "8810": [0.08556, 0.58556, 0, 0],
      "8811": [0.08556, 0.58556, 0, 0],
      "8826": [0.08556, 0.58556, 0, 0],
      "8827": [0.08556, 0.58556, 0, 0],
      "8834": [0.08556, 0.58556, 0, 0],
      "8835": [0.08556, 0.58556, 0, 0],
      "8838": [0.19667, 0.69667, 0, 0],
      "8839": [0.19667, 0.69667, 0, 0],
      "8846": M20,
      "8849": [0.19667, 0.69667, 0, 0],
      "8850": [0.19667, 0.69667, 0, 0],
      "8851": M20,
      "8852": M20,
      "8853": [0.13333, 0.63333, 0, 0],
      "8854": [0.13333, 0.63333, 0, 0],
      "8855": [0.13333, 0.63333, 0, 0],
      "8856": [0.13333, 0.63333, 0, 0],
      "8857": [0.13333, 0.63333, 0, 0],
      "8866": M6,
      "8867": M6,
      "8868": M6,
      "8869": M6,
      "8900": [-0.02639, 0.47361, 0, 0],
      "8901": [-0.02639, 0.47361, 0, 0],
      "8902": [-0.02778, 0.47222, 0, 0],
      "8968": M15,
      "8969": M15,
      "8970": M15,
      "8971": M15,
      "8994": [-0.13889, 0.36111, 0, 0],
      "8995": [-0.13889, 0.36111, 0, 0],
      "9651": M16,
      "9657": [-0.02778, 0.47222, 0, 0],
      "9661": M16,
      "9667": [-0.02778, 0.47222, 0, 0],
      "9711": M16,
      "9824": [0.12963, 0.69444, 0, 0],
      "9825": [0.12963, 0.69444, 0, 0],
      "9826": [0.12963, 0.69444, 0, 0],
      "9827": [0.12963, 0.69444, 0, 0],
      "9837": M14,
      "9838": M16,
      "9839": M16,
      "10216": M15,
      "10217": M15,
      "10815": M4,
      "10927": [0.19667, 0.69667, 0, 0],
      "10928": [0.19667, 0.69667, 0, 0],
      "57376": M16
    },
    "Main-BoldItalic": {
      "32": M0,
      "33": [0, 0.69444, 0.11417, 0],
      "34": [0, 0.69444, 0.07939, 0],
      "35": [0.19444, 0.69444, 0.06833, 0],
      "37": [0.05556, 0.75, 0.12861, 0],
      "38": [0, 0.69444, 0.08528, 0],
      "39": [0, 0.69444, 0.12945, 0],
      "40": [0.25, 0.75, 0.15806, 0],
      "41": [0.25, 0.75, 0.03306, 0],
      "42": [0, 0.75, 0.14333, 0],
      "43": [0.10333, 0.60333, 0.03306, 0],
      "44": [0.19444, 0.14722, 0, 0],
      "45": [0, 0.44444, 0.02611, 0],
      "46": [0, 0.14722, 0, 0],
      "47": [0.25, 0.75, 0.15806, 0],
      "48": [0, 0.64444, 0.13167, 0],
      "49": [0, 0.64444, 0.13167, 0],
      "50": [0, 0.64444, 0.13167, 0],
      "51": [0, 0.64444, 0.13167, 0],
      "52": [0.19444, 0.64444, 0.13167, 0],
      "53": [0, 0.64444, 0.13167, 0],
      "54": [0, 0.64444, 0.13167, 0],
      "55": [0.19444, 0.64444, 0.13167, 0],
      "56": [0, 0.64444, 0.13167, 0],
      "57": [0, 0.64444, 0.13167, 0],
      "58": [0, 0.44444, 0.06695, 0],
      "59": [0.19444, 0.44444, 0.06695, 0],
      "61": [-0.10889, 0.39111, 0.06833, 0],
      "63": [0, 0.69444, 0.11472, 0],
      "64": [0, 0.69444, 0.09208, 0],
      "65": M4,
      "66": [0, 0.68611, 0.0992, 0],
      "67": [0, 0.68611, 0.14208, 0],
      "68": [0, 0.68611, 0.09062, 0],
      "69": [0, 0.68611, 0.11431, 0],
      "70": [0, 0.68611, 0.12903, 0],
      "71": [0, 0.68611, 0.07347, 0],
      "72": [0, 0.68611, 0.17208, 0],
      "73": [0, 0.68611, 0.15681, 0],
      "74": [0, 0.68611, 0.145, 0],
      "75": [0, 0.68611, 0.14208, 0],
      "76": M4,
      "77": [0, 0.68611, 0.17208, 0],
      "78": [0, 0.68611, 0.17208, 0],
      "79": [0, 0.68611, 0.09062, 0],
      "80": [0, 0.68611, 0.0992, 0],
      "81": [0.19444, 0.68611, 0.09062, 0],
      "82": [0, 0.68611, 0.02559, 0],
      "83": [0, 0.68611, 0.11264, 0],
      "84": [0, 0.68611, 0.12903, 0],
      "85": [0, 0.68611, 0.17208, 0],
      "86": [0, 0.68611, 0.18625, 0],
      "87": [0, 0.68611, 0.18625, 0],
      "88": [0, 0.68611, 0.15681, 0],
      "89": [0, 0.68611, 0.19803, 0],
      "90": [0, 0.68611, 0.14208, 0],
      "91": [0.25, 0.75, 0.1875, 0],
      "93": [0.25, 0.75, 0.09972, 0],
      "94": [0, 0.69444, 0.06709, 0],
      "95": [0.31, 0.13444, 0.09811, 0],
      "97": [0, 0.44444, 0.09426, 0],
      "98": [0, 0.69444, 0.07861, 0],
      "99": [0, 0.44444, 0.05222, 0],
      "100": [0, 0.69444, 0.10861, 0],
      "101": [0, 0.44444, 0.085, 0],
      "102": [0.19444, 0.69444, 0.21778, 0],
      "103": [0.19444, 0.44444, 0.105, 0],
      "104": [0, 0.69444, 0.09426, 0],
      "105": [0, 0.69326, 0.11387, 0],
      "106": [0.19444, 0.69326, 0.1672, 0],
      "107": [0, 0.69444, 0.11111, 0],
      "108": [0, 0.69444, 0.10861, 0],
      "109": [0, 0.44444, 0.09426, 0],
      "110": [0, 0.44444, 0.09426, 0],
      "111": [0, 0.44444, 0.07861, 0],
      "112": [0.19444, 0.44444, 0.07861, 0],
      "113": [0.19444, 0.44444, 0.105, 0],
      "114": [0, 0.44444, 0.11111, 0],
      "115": [0, 0.44444, 0.08167, 0],
      "116": [0, 0.63492, 0.09639, 0],
      "117": [0, 0.44444, 0.09426, 0],
      "118": [0, 0.44444, 0.11111, 0],
      "119": [0, 0.44444, 0.11111, 0],
      "120": [0, 0.44444, 0.12583, 0],
      "121": [0.19444, 0.44444, 0.105, 0],
      "122": [0, 0.44444, 0.13889, 0],
      "126": [0.35, 0.34444, 0.11472, 0],
      "160": M0,
      "168": [0, 0.69444, 0.11473, 0],
      "176": M6,
      "184": [0.17014, 0, 0, 0],
      "198": [0, 0.68611, 0.11431, 0],
      "216": [0.04861, 0.73472, 0.09062, 0],
      "223": [0.19444, 0.69444, 0.09736, 0],
      "230": [0, 0.44444, 0.085, 0],
      "248": [0.09722, 0.54167, 0.09458, 0],
      "305": [0, 0.44444, 0.09426, 0],
      "338": [0, 0.68611, 0.11431, 0],
      "339": [0, 0.44444, 0.085, 0],
      "567": [0.19444, 0.44444, 0.04611, 0],
      "710": [0, 0.69444, 0.06709, 0],
      "711": [0, 0.63194, 0.08271, 0],
      "713": [0, 0.59444, 0.10444, 0],
      "714": [0, 0.69444, 0.08528, 0],
      "715": M6,
      "728": [0, 0.69444, 0.10333, 0],
      "729": [0, 0.69444, 0.12945, 0],
      "730": M6,
      "732": [0, 0.69444, 0.11472, 0],
      "733": [0, 0.69444, 0.11472, 0],
      "915": [0, 0.68611, 0.12903, 0],
      "916": M4,
      "920": [0, 0.68611, 0.09062, 0],
      "923": M4,
      "926": [0, 0.68611, 0.15092, 0],
      "928": [0, 0.68611, 0.17208, 0],
      "931": [0, 0.68611, 0.11431, 0],
      "933": [0, 0.68611, 0.10778, 0],
      "934": [0, 0.68611, 0.05632, 0],
      "936": [0, 0.68611, 0.10778, 0],
      "937": [0, 0.68611, 0.0992, 0],
      "8211": [0, 0.44444, 0.09811, 0],
      "8212": [0, 0.44444, 0.09811, 0],
      "8216": [0, 0.69444, 0.12945, 0],
      "8217": [0, 0.69444, 0.12945, 0],
      "8220": [0, 0.69444, 0.16772, 0],
      "8221": [0, 0.69444, 0.07939, 0]
    },
    "Main-Italic": {
      "32": M0,
      "33": [0, 0.69444, 0.12417, 0],
      "34": [0, 0.69444, 0.06961, 0],
      "35": [0.19444, 0.69444, 0.06616, 0],
      "37": [0.05556, 0.75, 0.13639, 0],
      "38": [0, 0.69444, 0.09694, 0],
      "39": [0, 0.69444, 0.12417, 0],
      "40": [0.25, 0.75, 0.16194, 0],
      "41": [0.25, 0.75, 0.03694, 0],
      "42": [0, 0.75, 0.14917, 0],
      "43": [0.05667, 0.56167, 0.03694, 0],
      "44": [0.19444, 0.10556, 0, 0],
      "45": [0, 0.43056, 0.02826, 0],
      "46": [0, 0.10556, 0, 0],
      "47": [0.25, 0.75, 0.16194, 0],
      "48": [0, 0.64444, 0.13556, 0],
      "49": [0, 0.64444, 0.13556, 0],
      "50": [0, 0.64444, 0.13556, 0],
      "51": [0, 0.64444, 0.13556, 0],
      "52": [0.19444, 0.64444, 0.13556, 0],
      "53": [0, 0.64444, 0.13556, 0],
      "54": [0, 0.64444, 0.13556, 0],
      "55": [0.19444, 0.64444, 0.13556, 0],
      "56": [0, 0.64444, 0.13556, 0],
      "57": [0, 0.64444, 0.13556, 0],
      "58": [0, 0.43056, 0.0582, 0],
      "59": [0.19444, 0.43056, 0.0582, 0],
      "61": [-0.13313, 0.36687, 0.06616, 0],
      "63": [0, 0.69444, 0.1225, 0],
      "64": [0, 0.69444, 0.09597, 0],
      "65": M9,
      "66": [0, 0.68333, 0.10257, 0],
      "67": [0, 0.68333, 0.14528, 0],
      "68": [0, 0.68333, 0.09403, 0],
      "69": [0, 0.68333, 0.12028, 0],
      "70": [0, 0.68333, 0.13305, 0],
      "71": [0, 0.68333, 0.08722, 0],
      "72": [0, 0.68333, 0.16389, 0],
      "73": [0, 0.68333, 0.15806, 0],
      "74": [0, 0.68333, 0.14028, 0],
      "75": [0, 0.68333, 0.14528, 0],
      "76": M9,
      "77": [0, 0.68333, 0.16389, 0],
      "78": [0, 0.68333, 0.16389, 0],
      "79": [0, 0.68333, 0.09403, 0],
      "80": [0, 0.68333, 0.10257, 0],
      "81": [0.19444, 0.68333, 0.09403, 0],
      "82": [0, 0.68333, 0.03868, 0],
      "83": [0, 0.68333, 0.11972, 0],
      "84": [0, 0.68333, 0.13305, 0],
      "85": [0, 0.68333, 0.16389, 0],
      "86": [0, 0.68333, 0.18361, 0],
      "87": [0, 0.68333, 0.18361, 0],
      "88": [0, 0.68333, 0.15806, 0],
      "89": [0, 0.68333, 0.19383, 0],
      "90": [0, 0.68333, 0.14528, 0],
      "91": [0.25, 0.75, 0.1875, 0],
      "93": [0.25, 0.75, 0.10528, 0],
      "94": [0, 0.69444, 0.06646, 0],
      "95": [0.31, 0.12056, 0.09208, 0],
      "97": [0, 0.43056, 0.07671, 0],
      "98": [0, 0.69444, 0.06312, 0],
      "99": [0, 0.43056, 0.05653, 0],
      "100": [0, 0.69444, 0.10333, 0],
      "101": [0, 0.43056, 0.07514, 0],
      "102": [0.19444, 0.69444, 0.21194, 0],
      "103": [0.19444, 0.43056, 0.08847, 0],
      "104": [0, 0.69444, 0.07671, 0],
      "105": [0, 0.65536, 0.1019, 0],
      "106": [0.19444, 0.65536, 0.14467, 0],
      "107": [0, 0.69444, 0.10764, 0],
      "108": [0, 0.69444, 0.10333, 0],
      "109": [0, 0.43056, 0.07671, 0],
      "110": [0, 0.43056, 0.07671, 0],
      "111": [0, 0.43056, 0.06312, 0],
      "112": [0.19444, 0.43056, 0.06312, 0],
      "113": [0.19444, 0.43056, 0.08847, 0],
      "114": [0, 0.43056, 0.10764, 0],
      "115": [0, 0.43056, 0.08208, 0],
      "116": [0, 0.61508, 0.09486, 0],
      "117": [0, 0.43056, 0.07671, 0],
      "118": [0, 0.43056, 0.10764, 0],
      "119": [0, 0.43056, 0.10764, 0],
      "120": [0, 0.43056, 0.12042, 0],
      "121": [0.19444, 0.43056, 0.08847, 0],
      "122": [0, 0.43056, 0.12292, 0],
      "126": [0.35, 0.31786, 0.11585, 0],
      "160": M0,
      "168": [0, 0.66786, 0.10474, 0],
      "176": M6,
      "184": [0.17014, 0, 0, 0],
      "198": [0, 0.68333, 0.12028, 0],
      "216": [0.04861, 0.73194, 0.09403, 0],
      "223": [0.19444, 0.69444, 0.10514, 0],
      "230": [0, 0.43056, 0.07514, 0],
      "248": [0.09722, 0.52778, 0.09194, 0],
      "338": [0, 0.68333, 0.12028, 0],
      "339": [0, 0.43056, 0.07514, 0],
      "710": [0, 0.69444, 0.06646, 0],
      "711": [0, 0.62847, 0.08295, 0],
      "713": [0, 0.56167, 0.10333, 0],
      "714": [0, 0.69444, 0.09694, 0],
      "715": M6,
      "728": [0, 0.69444, 0.10806, 0],
      "729": [0, 0.66786, 0.11752, 0],
      "730": M6,
      "732": [0, 0.66786, 0.11585, 0],
      "733": [0, 0.69444, 0.1225, 0],
      "915": [0, 0.68333, 0.13305, 0],
      "916": M9,
      "920": [0, 0.68333, 0.09403, 0],
      "923": M9,
      "926": [0, 0.68333, 0.15294, 0],
      "928": [0, 0.68333, 0.16389, 0],
      "931": [0, 0.68333, 0.12028, 0],
      "933": [0, 0.68333, 0.11111, 0],
      "934": [0, 0.68333, 0.05986, 0],
      "936": [0, 0.68333, 0.11111, 0],
      "937": [0, 0.68333, 0.10257, 0],
      "8211": [0, 0.43056, 0.09208, 0],
      "8212": [0, 0.43056, 0.09208, 0],
      "8216": [0, 0.69444, 0.12417, 0],
      "8217": [0, 0.69444, 0.12417, 0],
      "8220": [0, 0.69444, 0.1685, 0],
      "8221": [0, 0.69444, 0.06961, 0],
      "8463": M1
    },
    "Main-Regular": {
      "32": M0,
      "33": M6,
      "34": M6,
      "35": M16,
      "36": [0.05556, 0.75, 0, 0],
      "37": [0.05556, 0.75, 0, 0],
      "38": M6,
      "39": M6,
      "40": M15,
      "41": M15,
      "42": M14,
      "43": [0.08333, 0.58333, 0, 0],
      "44": [0.19444, 0.10556, 0, 0],
      "45": [0, 0.43056, 0, 0],
      "46": [0, 0.10556, 0, 0],
      "47": M15,
      "48": M5,
      "49": M5,
      "50": M5,
      "51": M5,
      "52": M5,
      "53": M5,
      "54": M5,
      "55": M5,
      "56": M5,
      "57": M5,
      "58": [0, 0.43056, 0, 0],
      "59": [0.19444, 0.43056, 0, 0],
      "60": [0.0391, 0.5391, 0, 0],
      "61": [-0.13313, 0.36687, 0, 0],
      "62": [0.0391, 0.5391, 0, 0],
      "63": M6,
      "64": M6,
      "65": M9,
      "66": M9,
      "67": M9,
      "68": M9,
      "69": M9,
      "70": M9,
      "71": M9,
      "72": M9,
      "73": M9,
      "74": M9,
      "75": M9,
      "76": M9,
      "77": M9,
      "78": M9,
      "79": M9,
      "80": M9,
      "81": [0.19444, 0.68333, 0, 0],
      "82": M9,
      "83": M9,
      "84": M9,
      "85": M9,
      "86": [0, 0.68333, 0.01389, 0],
      "87": [0, 0.68333, 0.01389, 0],
      "88": M9,
      "89": [0, 0.68333, 0.025, 0],
      "90": M9,
      "91": M15,
      "92": M15,
      "93": M15,
      "94": M6,
      "95": [0.31, 0.12056, 0.02778, 0],
      "97": [0, 0.43056, 0, 0],
      "98": M6,
      "99": [0, 0.43056, 0, 0],
      "100": M6,
      "101": [0, 0.43056, 0, 0],
      "102": [0, 0.69444, 0.07778, 0],
      "103": [0.19444, 0.43056, 0.01389, 0],
      "104": M6,
      "105": [0, 0.66786, 0, 0],
      "106": [0.19444, 0.66786, 0, 0],
      "107": M6,
      "108": M6,
      "109": [0, 0.43056, 0, 0],
      "110": [0, 0.43056, 0, 0],
      "111": [0, 0.43056, 0, 0],
      "112": [0.19444, 0.43056, 0, 0],
      "113": [0.19444, 0.43056, 0, 0],
      "114": [0, 0.43056, 0, 0],
      "115": [0, 0.43056, 0, 0],
      "116": [0, 0.61508, 0, 0],
      "117": [0, 0.43056, 0, 0],
      "118": [0, 0.43056, 0.01389, 0],
      "119": [0, 0.43056, 0.01389, 0],
      "120": [0, 0.43056, 0, 0],
      "121": [0.19444, 0.43056, 0.01389, 0],
      "122": [0, 0.43056, 0, 0],
      "123": M15,
      "124": M15,
      "125": M15,
      "126": [0.35, 0.31786, 0, 0],
      "160": M0,
      "163": M6,
      "167": M16,
      "168": [0, 0.66786, 0, 0],
      "172": [0, 0.43056, 0, 0],
      "176": M6,
      "177": [0.08333, 0.58333, 0, 0],
      "182": M16,
      "184": [0.17014, 0, 0, 0],
      "198": M9,
      "215": [0.08333, 0.58333, 0, 0],
      "216": [0.04861, 0.73194, 0, 0],
      "223": M6,
      "230": [0, 0.43056, 0, 0],
      "247": [0.08333, 0.58333, 0, 0],
      "248": [0.09722, 0.52778, 0, 0],
      "305": [0, 0.43056, 0, 0],
      "338": M9,
      "339": [0, 0.43056, 0, 0],
      "567": [0.19444, 0.43056, 0, 0],
      "710": M6,
      "711": [0, 0.62847, 0, 0],
      "713": [0, 0.56778, 0, 0],
      "714": M6,
      "715": M6,
      "728": M6,
      "729": [0, 0.66786, 0, 0],
      "730": M6,
      "732": [0, 0.66786, 0, 0],
      "733": M6,
      "915": M9,
      "916": M9,
      "920": M9,
      "923": M9,
      "926": M9,
      "928": M9,
      "931": M9,
      "933": M9,
      "934": M9,
      "936": M9,
      "937": M9,
      "8211": [0, 0.43056, 0.02778, 0],
      "8212": [0, 0.43056, 0.02778, 0],
      "8216": M6,
      "8217": M6,
      "8220": M6,
      "8221": M6,
      "8224": M16,
      "8225": M16,
      "8230": [0, 0.12, 0, 0],
      "8242": M20,
      "8407": [0, 0.71444, 0.15382, 0],
      "8463": M1,
      "8465": M6,
      "8467": [0, 0.69444, 0, 0.11111],
      "8472": [0.19444, 0.43056, 0, 0.11111],
      "8476": M6,
      "8501": M6,
      "8592": [-0.13313, 0.36687, 0, 0],
      "8593": M16,
      "8594": [-0.13313, 0.36687, 0, 0],
      "8595": M16,
      "8596": [-0.13313, 0.36687, 0, 0],
      "8597": M15,
      "8598": M16,
      "8599": M16,
      "8600": M16,
      "8601": M16,
      "8614": [0.011, 0.511, 0, 0],
      "8617": [0.011, 0.511, 0, 0],
      "8618": [0.011, 0.511, 0, 0],
      "8636": [-0.13313, 0.36687, 0, 0],
      "8637": [-0.13313, 0.36687, 0, 0],
      "8640": [-0.13313, 0.36687, 0, 0],
      "8641": [-0.13313, 0.36687, 0, 0],
      "8652": [0.011, 0.671, 0, 0],
      "8656": [-0.13313, 0.36687, 0, 0],
      "8657": M16,
      "8658": [-0.13313, 0.36687, 0, 0],
      "8659": M16,
      "8660": [-0.13313, 0.36687, 0, 0],
      "8661": M15,
      "8704": M6,
      "8706": [0, 0.69444, 0.05556, 0.08334],
      "8707": M6,
      "8709": [0.05556, 0.75, 0, 0],
      "8711": M9,
      "8712": [0.0391, 0.5391, 0, 0],
      "8715": [0.0391, 0.5391, 0, 0],
      "8722": [0.08333, 0.58333, 0, 0],
      "8723": [0.08333, 0.58333, 0, 0],
      "8725": M15,
      "8726": M15,
      "8727": [-0.03472, 0.46528, 0, 0],
      "8728": [-0.05555, 0.44445, 0, 0],
      "8729": [-0.05555, 0.44445, 0, 0],
      "8730": [0.2, 0.8, 0, 0],
      "8733": [0, 0.43056, 0, 0],
      "8734": [0, 0.43056, 0, 0],
      "8736": M3,
      "8739": M15,
      "8741": M15,
      "8743": M20,
      "8744": M20,
      "8745": M20,
      "8746": M20,
      "8747": [0.19444, 0.69444, 0.11111, 0],
      "8764": [-0.13313, 0.36687, 0, 0],
      "8768": M16,
      "8771": [-0.03625, 0.46375, 0, 0],
      "8773": [-0.022, 0.589, 0, 0],
      "8776": [-0.01688, 0.48312, 0, 0],
      "8781": [-0.03625, 0.46375, 0, 0],
      "8784": [-0.133, 0.67, 0, 0],
      "8801": [-0.03625, 0.46375, 0, 0],
      "8804": [0.13597, 0.63597, 0, 0],
      "8805": [0.13597, 0.63597, 0, 0],
      "8810": [0.0391, 0.5391, 0, 0],
      "8811": [0.0391, 0.5391, 0, 0],
      "8826": [0.0391, 0.5391, 0, 0],
      "8827": [0.0391, 0.5391, 0, 0],
      "8834": [0.0391, 0.5391, 0, 0],
      "8835": [0.0391, 0.5391, 0, 0],
      "8838": [0.13597, 0.63597, 0, 0],
      "8839": [0.13597, 0.63597, 0, 0],
      "8846": M20,
      "8849": [0.13597, 0.63597, 0, 0],
      "8850": [0.13597, 0.63597, 0, 0],
      "8851": M20,
      "8852": M20,
      "8853": [0.08333, 0.58333, 0, 0],
      "8854": [0.08333, 0.58333, 0, 0],
      "8855": [0.08333, 0.58333, 0, 0],
      "8856": [0.08333, 0.58333, 0, 0],
      "8857": [0.08333, 0.58333, 0, 0],
      "8866": M6,
      "8867": M6,
      "8868": M6,
      "8869": M6,
      "8872": [0.249, 0.75, 0, 0],
      "8900": [-0.05555, 0.44445, 0, 0],
      "8901": [-0.05555, 0.44445, 0, 0],
      "8902": [-0.03472, 0.46528, 0, 0],
      "8904": [5e-3, 0.505, 0, 0],
      "8942": [0.03, 0.9, 0, 0],
      "8943": [-0.19, 0.31, 0, 0],
      "8945": [-0.1, 0.82, 0, 0],
      "8968": M15,
      "8969": M15,
      "8970": M15,
      "8971": M15,
      "8994": [-0.14236, 0.35764, 0, 0],
      "8995": [-0.14236, 0.35764, 0, 0],
      "9136": [0.244, 0.744, 0, 0],
      "9137": [0.244, 0.744, 0, 0],
      "9651": M16,
      "9657": [-0.03472, 0.46528, 0, 0],
      "9661": M16,
      "9667": [-0.03472, 0.46528, 0, 0],
      "9711": M16,
      "9824": [0.12963, 0.69444, 0, 0],
      "9825": [0.12963, 0.69444, 0, 0],
      "9826": [0.12963, 0.69444, 0, 0],
      "9827": [0.12963, 0.69444, 0, 0],
      "9837": M14,
      "9838": M16,
      "9839": M16,
      "10216": M15,
      "10217": M15,
      "10222": [0.244, 0.744, 0, 0],
      "10223": [0.244, 0.744, 0, 0],
      "10229": [0.011, 0.511, 0, 0],
      "10230": [0.011, 0.511, 0, 0],
      "10231": [0.011, 0.511, 0, 0],
      "10232": [0.024, 0.525, 0, 0],
      "10233": [0.024, 0.525, 0, 0],
      "10234": [0.024, 0.525, 0, 0],
      "10236": [0.011, 0.511, 0, 0],
      "10815": M9,
      "10927": [0.13597, 0.63597, 0, 0],
      "10928": [0.13597, 0.63597, 0, 0],
      "57376": M16
    },
    "Math-BoldItalic": {
      "32": M0,
      "48": M7,
      "49": M7,
      "50": M7,
      "51": M8,
      "52": M8,
      "53": M8,
      "54": M5,
      "55": M8,
      "56": M5,
      "57": M8,
      "65": M4,
      "66": [0, 0.68611, 0.04835, 0],
      "67": [0, 0.68611, 0.06979, 0],
      "68": [0, 0.68611, 0.03194, 0],
      "69": [0, 0.68611, 0.05451, 0],
      "70": [0, 0.68611, 0.15972, 0],
      "71": M4,
      "72": [0, 0.68611, 0.08229, 0],
      "73": [0, 0.68611, 0.07778, 0],
      "74": [0, 0.68611, 0.10069, 0],
      "75": [0, 0.68611, 0.06979, 0],
      "76": M4,
      "77": [0, 0.68611, 0.11424, 0],
      "78": [0, 0.68611, 0.11424, 0],
      "79": [0, 0.68611, 0.03194, 0],
      "80": [0, 0.68611, 0.15972, 0],
      "81": [0.19444, 0.68611, 0, 0],
      "82": [0, 0.68611, 421e-5, 0],
      "83": [0, 0.68611, 0.05382, 0],
      "84": [0, 0.68611, 0.15972, 0],
      "85": [0, 0.68611, 0.11424, 0],
      "86": [0, 0.68611, 0.25555, 0],
      "87": [0, 0.68611, 0.15972, 0],
      "88": [0, 0.68611, 0.07778, 0],
      "89": [0, 0.68611, 0.25555, 0],
      "90": [0, 0.68611, 0.06979, 0],
      "97": M7,
      "98": M6,
      "99": M7,
      "100": M6,
      "101": M7,
      "102": [0.19444, 0.69444, 0.11042, 0],
      "103": [0.19444, 0.44444, 0.03704, 0],
      "104": M6,
      "105": [0, 0.69326, 0, 0],
      "106": [0.19444, 0.69326, 0.0622, 0],
      "107": [0, 0.69444, 0.01852, 0],
      "108": [0, 0.69444, 88e-4, 0],
      "109": M7,
      "110": M7,
      "111": M7,
      "112": M8,
      "113": [0.19444, 0.44444, 0.03704, 0],
      "114": [0, 0.44444, 0.03194, 0],
      "115": M7,
      "116": [0, 0.63492, 0, 0],
      "117": M7,
      "118": [0, 0.44444, 0.03704, 0],
      "119": [0, 0.44444, 0.02778, 0],
      "120": M7,
      "121": [0.19444, 0.44444, 0.03704, 0],
      "122": [0, 0.44444, 0.04213, 0],
      "160": M0,
      "915": [0, 0.68611, 0.15972, 0],
      "916": M4,
      "920": [0, 0.68611, 0.03194, 0],
      "923": M4,
      "926": [0, 0.68611, 0.07458, 0],
      "928": [0, 0.68611, 0.08229, 0],
      "931": [0, 0.68611, 0.05451, 0],
      "933": [0, 0.68611, 0.15972, 0],
      "934": M4,
      "936": [0, 0.68611, 0.11653, 0],
      "937": [0, 0.68611, 0.04835, 0],
      "945": M7,
      "946": [0.19444, 0.69444, 0.03403, 0],
      "947": [0.19444, 0.44444, 0.06389, 0],
      "948": [0, 0.69444, 0.03819, 0],
      "949": M7,
      "950": [0.19444, 0.69444, 0.06215, 0],
      "951": [0.19444, 0.44444, 0.03704, 0],
      "952": [0, 0.69444, 0.03194, 0],
      "953": M7,
      "954": M7,
      "955": M6,
      "956": M8,
      "957": [0, 0.44444, 0.06898, 0],
      "958": [0.19444, 0.69444, 0.03021, 0],
      "959": M7,
      "960": [0, 0.44444, 0.03704, 0],
      "961": M8,
      "962": [0.09722, 0.44444, 0.07917, 0],
      "963": [0, 0.44444, 0.03704, 0],
      "964": [0, 0.44444, 0.13472, 0],
      "965": [0, 0.44444, 0.03704, 0],
      "966": M8,
      "967": M8,
      "968": [0.19444, 0.69444, 0.03704, 0],
      "969": [0, 0.44444, 0.03704, 0],
      "977": M6,
      "981": M16,
      "982": [0, 0.44444, 0.03194, 0],
      "1009": M8,
      "1013": M7,
      "57649": M7,
      "57911": M8
    },
    "Math-Italic": {
      "32": M0,
      "48": [0, 0.43056, 0, 0],
      "49": [0, 0.43056, 0, 0],
      "50": [0, 0.43056, 0, 0],
      "51": [0.19444, 0.43056, 0, 0],
      "52": [0.19444, 0.43056, 0, 0],
      "53": [0.19444, 0.43056, 0, 0],
      "54": M5,
      "55": [0.19444, 0.43056, 0, 0],
      "56": M5,
      "57": [0.19444, 0.43056, 0, 0],
      "65": [0, 0.68333, 0, 0.13889],
      "66": [0, 0.68333, 0.05017, 0.08334],
      "67": [0, 0.68333, 0.07153, 0.08334],
      "68": [0, 0.68333, 0.02778, 0.05556],
      "69": [0, 0.68333, 0.05764, 0.08334],
      "70": [0, 0.68333, 0.13889, 0.08334],
      "71": [0, 0.68333, 0, 0.08334],
      "72": [0, 0.68333, 0.08125, 0.05556],
      "73": [0, 0.68333, 0.07847, 0.11111],
      "74": [0, 0.68333, 0.09618, 0.16667],
      "75": [0, 0.68333, 0.07153, 0.05556],
      "76": [0, 0.68333, 0, 0.02778],
      "77": [0, 0.68333, 0.10903, 0.08334],
      "78": [0, 0.68333, 0.10903, 0.08334],
      "79": [0, 0.68333, 0.02778, 0.08334],
      "80": [0, 0.68333, 0.13889, 0.08334],
      "81": [0.19444, 0.68333, 0, 0.08334],
      "82": [0, 0.68333, 773e-5, 0.08334],
      "83": [0, 0.68333, 0.05764, 0.08334],
      "84": [0, 0.68333, 0.13889, 0.08334],
      "85": [0, 0.68333, 0.10903, 0.02778],
      "86": [0, 0.68333, 0.22222, 0],
      "87": [0, 0.68333, 0.13889, 0],
      "88": [0, 0.68333, 0.07847, 0.08334],
      "89": [0, 0.68333, 0.22222, 0],
      "90": [0, 0.68333, 0.07153, 0.08334],
      "97": [0, 0.43056, 0, 0],
      "98": M6,
      "99": [0, 0.43056, 0, 0.05556],
      "100": [0, 0.69444, 0, 0.16667],
      "101": [0, 0.43056, 0, 0.05556],
      "102": [0.19444, 0.69444, 0.10764, 0.16667],
      "103": [0.19444, 0.43056, 0.03588, 0.02778],
      "104": M6,
      "105": [0, 0.65952, 0, 0],
      "106": [0.19444, 0.65952, 0.05724, 0],
      "107": [0, 0.69444, 0.03148, 0],
      "108": [0, 0.69444, 0.01968, 0.08334],
      "109": [0, 0.43056, 0, 0],
      "110": [0, 0.43056, 0, 0],
      "111": [0, 0.43056, 0, 0.05556],
      "112": [0.19444, 0.43056, 0, 0.08334],
      "113": [0.19444, 0.43056, 0.03588, 0.08334],
      "114": [0, 0.43056, 0.02778, 0.05556],
      "115": [0, 0.43056, 0, 0.05556],
      "116": [0, 0.61508, 0, 0.08334],
      "117": [0, 0.43056, 0, 0.02778],
      "118": [0, 0.43056, 0.03588, 0.02778],
      "119": [0, 0.43056, 0.02691, 0.08334],
      "120": [0, 0.43056, 0, 0.02778],
      "121": [0.19444, 0.43056, 0.03588, 0.05556],
      "122": [0, 0.43056, 0.04398, 0.05556],
      "160": M0,
      "915": [0, 0.68333, 0.13889, 0.08334],
      "916": [0, 0.68333, 0, 0.16667],
      "920": [0, 0.68333, 0.02778, 0.08334],
      "923": [0, 0.68333, 0, 0.16667],
      "926": [0, 0.68333, 0.07569, 0.08334],
      "928": [0, 0.68333, 0.08125, 0.05556],
      "931": [0, 0.68333, 0.05764, 0.08334],
      "933": [0, 0.68333, 0.13889, 0.05556],
      "934": [0, 0.68333, 0, 0.08334],
      "936": [0, 0.68333, 0.11, 0.05556],
      "937": [0, 0.68333, 0.05017, 0.08334],
      "945": [0, 0.43056, 37e-4, 0.02778],
      "946": [0.19444, 0.69444, 0.05278, 0.08334],
      "947": [0.19444, 0.43056, 0.05556, 0],
      "948": [0, 0.69444, 0.03785, 0.05556],
      "949": [0, 0.43056, 0, 0.08334],
      "950": [0.19444, 0.69444, 0.07378, 0.08334],
      "951": [0.19444, 0.43056, 0.03588, 0.05556],
      "952": [0, 0.69444, 0.02778, 0.08334],
      "953": [0, 0.43056, 0, 0.05556],
      "954": [0, 0.43056, 0, 0],
      "955": M6,
      "956": [0.19444, 0.43056, 0, 0.02778],
      "957": [0, 0.43056, 0.06366, 0.02778],
      "958": [0.19444, 0.69444, 0.04601, 0.11111],
      "959": [0, 0.43056, 0, 0.05556],
      "960": [0, 0.43056, 0.03588, 0],
      "961": [0.19444, 0.43056, 0, 0.08334],
      "962": [0.09722, 0.43056, 0.07986, 0.08334],
      "963": [0, 0.43056, 0.03588, 0],
      "964": [0, 0.43056, 0.1132, 0.02778],
      "965": [0, 0.43056, 0.03588, 0.02778],
      "966": [0.19444, 0.43056, 0, 0.08334],
      "967": [0.19444, 0.43056, 0, 0.05556],
      "968": [0.19444, 0.69444, 0.03588, 0.11111],
      "969": [0, 0.43056, 0.03588, 0],
      "977": [0, 0.69444, 0, 0.08334],
      "981": [0.19444, 0.69444, 0, 0.08334],
      "982": [0, 0.43056, 0.02778, 0],
      "1009": [0.19444, 0.43056, 0, 0.08334],
      "1013": [0, 0.43056, 0, 0.05556],
      "57649": [0, 0.43056, 0, 0.02778],
      "57911": [0.19444, 0.43056, 0, 0.08334]
    },
    "SansSerif-Bold": {
      "32": M0,
      "33": M6,
      "34": M6,
      "35": M16,
      "36": [0.05556, 0.75, 0, 0],
      "37": [0.05556, 0.75, 0, 0],
      "38": M6,
      "39": M6,
      "40": M15,
      "41": M15,
      "42": M14,
      "43": [0.11667, 0.61667, 0, 0],
      "44": [0.10556, 0.13056, 0, 0],
      "45": [0, 0.45833, 0, 0],
      "46": [0, 0.13056, 0, 0],
      "47": M15,
      "48": M6,
      "49": M6,
      "50": M6,
      "51": M6,
      "52": M6,
      "53": M6,
      "54": M6,
      "55": M6,
      "56": M6,
      "57": M6,
      "58": [0, 0.45833, 0, 0],
      "59": [0.10556, 0.45833, 0, 0],
      "61": [-0.09375, 0.40625, 0, 0],
      "63": M6,
      "64": M6,
      "65": M6,
      "66": M6,
      "67": M6,
      "68": M6,
      "69": M6,
      "70": M6,
      "71": M6,
      "72": M6,
      "73": M6,
      "74": M6,
      "75": M6,
      "76": M6,
      "77": M6,
      "78": M6,
      "79": M6,
      "80": M6,
      "81": [0.10556, 0.69444, 0, 0],
      "82": M6,
      "83": M6,
      "84": M6,
      "85": M6,
      "86": [0, 0.69444, 0.01528, 0],
      "87": [0, 0.69444, 0.01528, 0],
      "88": M6,
      "89": [0, 0.69444, 0.0275, 0],
      "90": M6,
      "91": M15,
      "93": M15,
      "94": M6,
      "95": [0.35, 0.10833, 0.03056, 0],
      "97": [0, 0.45833, 0, 0],
      "98": M6,
      "99": [0, 0.45833, 0, 0],
      "100": M6,
      "101": [0, 0.45833, 0, 0],
      "102": [0, 0.69444, 0.07639, 0],
      "103": [0.19444, 0.45833, 0.01528, 0],
      "104": M6,
      "105": M6,
      "106": M16,
      "107": M6,
      "108": M6,
      "109": [0, 0.45833, 0, 0],
      "110": [0, 0.45833, 0, 0],
      "111": [0, 0.45833, 0, 0],
      "112": [0.19444, 0.45833, 0, 0],
      "113": [0.19444, 0.45833, 0, 0],
      "114": [0, 0.45833, 0.01528, 0],
      "115": [0, 0.45833, 0, 0],
      "116": [0, 0.58929, 0, 0],
      "117": [0, 0.45833, 0, 0],
      "118": [0, 0.45833, 0.01528, 0],
      "119": [0, 0.45833, 0.01528, 0],
      "120": [0, 0.45833, 0, 0],
      "121": [0.19444, 0.45833, 0.01528, 0],
      "122": [0, 0.45833, 0, 0],
      "126": [0.35, 0.34444, 0, 0],
      "160": M0,
      "168": M6,
      "176": M6,
      "180": M6,
      "184": [0.17014, 0, 0, 0],
      "305": [0, 0.45833, 0, 0],
      "567": [0.19444, 0.45833, 0, 0],
      "710": M6,
      "711": [0, 0.63542, 0, 0],
      "713": [0, 0.63778, 0, 0],
      "728": M6,
      "729": M6,
      "730": M6,
      "732": M6,
      "733": M6,
      "915": M6,
      "916": M6,
      "920": M6,
      "923": M6,
      "926": M6,
      "928": M6,
      "931": M6,
      "933": M6,
      "934": M6,
      "936": M6,
      "937": M6,
      "8211": [0, 0.45833, 0.03056, 0],
      "8212": [0, 0.45833, 0.03056, 0],
      "8216": M6,
      "8217": M6,
      "8220": M6,
      "8221": M6
    },
    "SansSerif-Italic": {
      "32": M0,
      "33": [0, 0.69444, 0.05733, 0],
      "34": [0, 0.69444, 316e-5, 0],
      "35": [0.19444, 0.69444, 0.05087, 0],
      "36": [0.05556, 0.75, 0.11156, 0],
      "37": [0.05556, 0.75, 0.03126, 0],
      "38": [0, 0.69444, 0.03058, 0],
      "39": [0, 0.69444, 0.07816, 0],
      "40": [0.25, 0.75, 0.13164, 0],
      "41": [0.25, 0.75, 0.02536, 0],
      "42": [0, 0.75, 0.11775, 0],
      "43": [0.08333, 0.58333, 0.02536, 0],
      "44": [0.125, 0.08333, 0, 0],
      "45": [0, 0.44444, 0.01946, 0],
      "46": [0, 0.08333, 0, 0],
      "47": [0.25, 0.75, 0.13164, 0],
      "48": [0, 0.65556, 0.11156, 0],
      "49": [0, 0.65556, 0.11156, 0],
      "50": [0, 0.65556, 0.11156, 0],
      "51": [0, 0.65556, 0.11156, 0],
      "52": [0, 0.65556, 0.11156, 0],
      "53": [0, 0.65556, 0.11156, 0],
      "54": [0, 0.65556, 0.11156, 0],
      "55": [0, 0.65556, 0.11156, 0],
      "56": [0, 0.65556, 0.11156, 0],
      "57": [0, 0.65556, 0.11156, 0],
      "58": [0, 0.44444, 0.02502, 0],
      "59": [0.125, 0.44444, 0.02502, 0],
      "61": [-0.13, 0.37, 0.05087, 0],
      "63": [0, 0.69444, 0.11809, 0],
      "64": [0, 0.69444, 0.07555, 0],
      "65": M6,
      "66": [0, 0.69444, 0.08293, 0],
      "67": [0, 0.69444, 0.11983, 0],
      "68": [0, 0.69444, 0.07555, 0],
      "69": [0, 0.69444, 0.11983, 0],
      "70": [0, 0.69444, 0.13372, 0],
      "71": [0, 0.69444, 0.11983, 0],
      "72": [0, 0.69444, 0.08094, 0],
      "73": [0, 0.69444, 0.13372, 0],
      "74": [0, 0.69444, 0.08094, 0],
      "75": [0, 0.69444, 0.11983, 0],
      "76": M6,
      "77": [0, 0.69444, 0.08094, 0],
      "78": [0, 0.69444, 0.08094, 0],
      "79": [0, 0.69444, 0.07555, 0],
      "80": [0, 0.69444, 0.08293, 0],
      "81": [0.125, 0.69444, 0.07555, 0],
      "82": [0, 0.69444, 0.08293, 0],
      "83": [0, 0.69444, 0.09205, 0],
      "84": [0, 0.69444, 0.13372, 0],
      "85": [0, 0.69444, 0.08094, 0],
      "86": [0, 0.69444, 0.1615, 0],
      "87": [0, 0.69444, 0.1615, 0],
      "88": [0, 0.69444, 0.13372, 0],
      "89": [0, 0.69444, 0.17261, 0],
      "90": [0, 0.69444, 0.11983, 0],
      "91": [0.25, 0.75, 0.15942, 0],
      "93": [0.25, 0.75, 0.08719, 0],
      "94": [0, 0.69444, 0.0799, 0],
      "95": [0.35, 0.09444, 0.08616, 0],
      "97": [0, 0.44444, 981e-5, 0],
      "98": [0, 0.69444, 0.03057, 0],
      "99": [0, 0.44444, 0.08336, 0],
      "100": [0, 0.69444, 0.09483, 0],
      "101": [0, 0.44444, 0.06778, 0],
      "102": [0, 0.69444, 0.21705, 0],
      "103": [0.19444, 0.44444, 0.10836, 0],
      "104": [0, 0.69444, 0.01778, 0],
      "105": [0, 0.67937, 0.09718, 0],
      "106": [0.19444, 0.67937, 0.09162, 0],
      "107": [0, 0.69444, 0.08336, 0],
      "108": [0, 0.69444, 0.09483, 0],
      "109": [0, 0.44444, 0.01778, 0],
      "110": [0, 0.44444, 0.01778, 0],
      "111": [0, 0.44444, 0.06613, 0],
      "112": [0.19444, 0.44444, 0.0389, 0],
      "113": [0.19444, 0.44444, 0.04169, 0],
      "114": [0, 0.44444, 0.10836, 0],
      "115": [0, 0.44444, 0.0778, 0],
      "116": [0, 0.57143, 0.07225, 0],
      "117": [0, 0.44444, 0.04169, 0],
      "118": [0, 0.44444, 0.10836, 0],
      "119": [0, 0.44444, 0.10836, 0],
      "120": [0, 0.44444, 0.09169, 0],
      "121": [0.19444, 0.44444, 0.10836, 0],
      "122": [0, 0.44444, 0.08752, 0],
      "126": [0.35, 0.32659, 0.08826, 0],
      "160": M0,
      "168": [0, 0.67937, 0.06385, 0],
      "176": M6,
      "184": [0.17014, 0, 0, 0],
      "305": [0, 0.44444, 0.04169, 0],
      "567": [0.19444, 0.44444, 0.04169, 0],
      "710": [0, 0.69444, 0.0799, 0],
      "711": [0, 0.63194, 0.08432, 0],
      "713": [0, 0.60889, 0.08776, 0],
      "714": [0, 0.69444, 0.09205, 0],
      "715": M6,
      "728": [0, 0.69444, 0.09483, 0],
      "729": [0, 0.67937, 0.07774, 0],
      "730": M6,
      "732": [0, 0.67659, 0.08826, 0],
      "733": [0, 0.69444, 0.09205, 0],
      "915": [0, 0.69444, 0.13372, 0],
      "916": M6,
      "920": [0, 0.69444, 0.07555, 0],
      "923": M6,
      "926": [0, 0.69444, 0.12816, 0],
      "928": [0, 0.69444, 0.08094, 0],
      "931": [0, 0.69444, 0.11983, 0],
      "933": [0, 0.69444, 0.09031, 0],
      "934": [0, 0.69444, 0.04603, 0],
      "936": [0, 0.69444, 0.09031, 0],
      "937": [0, 0.69444, 0.08293, 0],
      "8211": [0, 0.44444, 0.08616, 0],
      "8212": [0, 0.44444, 0.08616, 0],
      "8216": [0, 0.69444, 0.07816, 0],
      "8217": [0, 0.69444, 0.07816, 0],
      "8220": [0, 0.69444, 0.14205, 0],
      "8221": [0, 0.69444, 316e-5, 0]
    },
    "SansSerif-Regular": {
      "32": M0,
      "33": M6,
      "34": M6,
      "35": M16,
      "36": [0.05556, 0.75, 0, 0],
      "37": [0.05556, 0.75, 0, 0],
      "38": M6,
      "39": M6,
      "40": M15,
      "41": M15,
      "42": M14,
      "43": [0.08333, 0.58333, 0, 0],
      "44": [0.125, 0.08333, 0, 0],
      "45": M7,
      "46": [0, 0.08333, 0, 0],
      "47": M15,
      "48": [0, 0.65556, 0, 0],
      "49": [0, 0.65556, 0, 0],
      "50": [0, 0.65556, 0, 0],
      "51": [0, 0.65556, 0, 0],
      "52": [0, 0.65556, 0, 0],
      "53": [0, 0.65556, 0, 0],
      "54": [0, 0.65556, 0, 0],
      "55": [0, 0.65556, 0, 0],
      "56": [0, 0.65556, 0, 0],
      "57": [0, 0.65556, 0, 0],
      "58": M7,
      "59": [0.125, 0.44444, 0, 0],
      "61": [-0.13, 0.37, 0, 0],
      "63": M6,
      "64": M6,
      "65": M6,
      "66": M6,
      "67": M6,
      "68": M6,
      "69": M6,
      "70": M6,
      "71": M6,
      "72": M6,
      "73": M6,
      "74": M6,
      "75": M6,
      "76": M6,
      "77": M6,
      "78": M6,
      "79": M6,
      "80": M6,
      "81": [0.125, 0.69444, 0, 0],
      "82": M6,
      "83": M6,
      "84": M6,
      "85": M6,
      "86": [0, 0.69444, 0.01389, 0],
      "87": [0, 0.69444, 0.01389, 0],
      "88": M6,
      "89": [0, 0.69444, 0.025, 0],
      "90": M6,
      "91": M15,
      "93": M15,
      "94": M6,
      "95": [0.35, 0.09444, 0.02778, 0],
      "97": M7,
      "98": M6,
      "99": M7,
      "100": M6,
      "101": M7,
      "102": [0, 0.69444, 0.06944, 0],
      "103": [0.19444, 0.44444, 0.01389, 0],
      "104": M6,
      "105": [0, 0.67937, 0, 0],
      "106": [0.19444, 0.67937, 0, 0],
      "107": M6,
      "108": M6,
      "109": M7,
      "110": M7,
      "111": M7,
      "112": M8,
      "113": M8,
      "114": [0, 0.44444, 0.01389, 0],
      "115": M7,
      "116": [0, 0.57143, 0, 0],
      "117": M7,
      "118": [0, 0.44444, 0.01389, 0],
      "119": [0, 0.44444, 0.01389, 0],
      "120": M7,
      "121": [0.19444, 0.44444, 0.01389, 0],
      "122": M7,
      "126": [0.35, 0.32659, 0, 0],
      "160": M0,
      "168": [0, 0.67937, 0, 0],
      "176": M6,
      "184": [0.17014, 0, 0, 0],
      "305": M7,
      "567": M8,
      "710": M6,
      "711": [0, 0.63194, 0, 0],
      "713": [0, 0.60889, 0, 0],
      "714": M6,
      "715": M6,
      "728": M6,
      "729": [0, 0.67937, 0, 0],
      "730": M6,
      "732": [0, 0.67659, 0, 0],
      "733": M6,
      "915": M6,
      "916": M6,
      "920": M6,
      "923": M6,
      "926": M6,
      "928": M6,
      "931": M6,
      "933": M6,
      "934": M6,
      "936": M6,
      "937": M6,
      "8211": [0, 0.44444, 0.02778, 0],
      "8212": [0, 0.44444, 0.02778, 0],
      "8216": M6,
      "8217": M6,
      "8220": M6,
      "8221": M6
    },
    "Script-Regular": {
      "32": M0,
      "65": [0, 0.7, 0.22925, 0],
      "66": [0, 0.7, 0.04087, 0],
      "67": [0, 0.7, 0.1689, 0],
      "68": [0, 0.7, 0.09371, 0],
      "69": [0, 0.7, 0.18583, 0],
      "70": [0, 0.7, 0.13634, 0],
      "71": [0, 0.7, 0.17322, 0],
      "72": [0, 0.7, 0.29694, 0],
      "73": [0, 0.7, 0.19189, 0],
      "74": [0.27778, 0.7, 0.19189, 0],
      "75": [0, 0.7, 0.31259, 0],
      "76": [0, 0.7, 0.19189, 0],
      "77": [0, 0.7, 0.15981, 0],
      "78": [0, 0.7, 0.3525, 0],
      "79": [0, 0.7, 0.08078, 0],
      "80": [0, 0.7, 0.08078, 0],
      "81": [0, 0.7, 0.03305, 0],
      "82": [0, 0.7, 0.06259, 0],
      "83": [0, 0.7, 0.19189, 0],
      "84": [0, 0.7, 0.29087, 0],
      "85": [0, 0.7, 0.25815, 0],
      "86": [0, 0.7, 0.27523, 0],
      "87": [0, 0.7, 0.27523, 0],
      "88": [0, 0.7, 0.26006, 0],
      "89": [0, 0.7, 0.2939, 0],
      "90": [0, 0.7, 0.24037, 0],
      "160": M0
    },
    "Size1-Regular": {
      "32": M0,
      "40": M10,
      "41": M10,
      "47": M10,
      "91": M10,
      "92": M10,
      "93": M10,
      "123": M10,
      "125": M10,
      "160": M0,
      "710": [0, 0.72222, 0, 0],
      "732": [0, 0.72222, 0, 0],
      "770": [0, 0.72222, 0, 0],
      "771": [0, 0.72222, 0, 0],
      "8214": [-99e-5, 0.601, 0, 0],
      "8593": [1e-5, 0.6, 0, 0],
      "8595": [1e-5, 0.6, 0, 0],
      "8657": [1e-5, 0.6, 0, 0],
      "8659": [1e-5, 0.6, 0, 0],
      "8719": M17,
      "8720": M17,
      "8721": M17,
      "8730": M10,
      "8739": [-599e-5, 0.606, 0, 0],
      "8741": [-599e-5, 0.606, 0, 0],
      "8747": [0.30612, 0.805, 0.19445, 0],
      "8748": [0.306, 0.805, 0.19445, 0],
      "8749": [0.306, 0.805, 0.19445, 0],
      "8750": [0.30612, 0.805, 0.19445, 0],
      "8896": M17,
      "8897": M17,
      "8898": M17,
      "8899": M17,
      "8968": M10,
      "8969": M10,
      "8970": M10,
      "8971": M10,
      "9168": [-99e-5, 0.601, 0, 0],
      "10216": M10,
      "10217": M10,
      "10752": M17,
      "10753": M17,
      "10754": M17,
      "10756": M17,
      "10758": M17
    },
    "Size2-Regular": {
      "32": M0,
      "40": M19,
      "41": M19,
      "47": M19,
      "91": M19,
      "92": M19,
      "93": M19,
      "123": M19,
      "125": M19,
      "160": M0,
      "710": M14,
      "732": M14,
      "770": M14,
      "771": M14,
      "8719": M18,
      "8720": M18,
      "8721": M18,
      "8730": M19,
      "8747": [0.86225, 1.36, 0.44445, 0],
      "8748": [0.862, 1.36, 0.44445, 0],
      "8749": [0.862, 1.36, 0.44445, 0],
      "8750": [0.86225, 1.36, 0.44445, 0],
      "8896": M18,
      "8897": M18,
      "8898": M18,
      "8899": M18,
      "8968": M19,
      "8969": M19,
      "8970": M19,
      "8971": M19,
      "10216": M19,
      "10217": M19,
      "10752": M18,
      "10753": M18,
      "10754": M18,
      "10756": M18,
      "10758": M18
    },
    "Size3-Regular": {
      "32": M0,
      "40": M13,
      "41": M13,
      "47": M13,
      "91": M13,
      "92": M13,
      "93": M13,
      "123": M13,
      "125": M13,
      "160": M0,
      "710": M14,
      "732": M14,
      "770": M14,
      "771": M14,
      "8730": M13,
      "8968": M13,
      "8969": M13,
      "8970": M13,
      "8971": M13,
      "10216": M13,
      "10217": M13
    },
    "Size4-Regular": {
      "32": M0,
      "40": M12,
      "41": M12,
      "47": M12,
      "91": M12,
      "92": M12,
      "93": M12,
      "123": M12,
      "125": M12,
      "160": M0,
      "710": [0, 0.825, 0, 0],
      "732": [0, 0.825, 0, 0],
      "770": [0, 0.825, 0, 0],
      "771": [0, 0.825, 0, 0],
      "8730": M12,
      "8968": M12,
      "8969": M12,
      "8970": M12,
      "8971": M12,
      "9115": [0.64502, 1.155, 0, 0],
      "9116": [1e-5, 0.6, 0, 0],
      "9117": [0.64502, 1.155, 0, 0],
      "9118": [0.64502, 1.155, 0, 0],
      "9119": [1e-5, 0.6, 0, 0],
      "9120": [0.64502, 1.155, 0, 0],
      "9121": [0.64502, 1.155, 0, 0],
      "9122": [-99e-5, 0.601, 0, 0],
      "9123": [0.64502, 1.155, 0, 0],
      "9124": [0.64502, 1.155, 0, 0],
      "9125": [-99e-5, 0.601, 0, 0],
      "9126": [0.64502, 1.155, 0, 0],
      "9127": [1e-5, 0.9, 0, 0],
      "9128": M19,
      "9129": [0.90001, 0, 0, 0],
      "9130": [0, 0.3, 0, 0],
      "9131": [1e-5, 0.9, 0, 0],
      "9132": M19,
      "9133": [0.90001, 0, 0, 0],
      "9143": [0.88502, 0.915, 0, 0],
      "10216": M12,
      "10217": M12,
      "57344": [-499e-5, 0.605, 0, 0],
      "57345": [-499e-5, 0.605, 0, 0],
      "57680": [0, 0.12, 0, 0],
      "57681": [0, 0.12, 0, 0],
      "57682": [0, 0.12, 0, 0],
      "57683": [0, 0.12, 0, 0]
    },
    "Typewriter-Regular": {
      "32": M0,
      "33": M11,
      "34": M11,
      "35": M11,
      "36": [0.08333, 0.69444, 0, 0],
      "37": [0.08333, 0.69444, 0, 0],
      "38": M11,
      "39": M11,
      "40": [0.08333, 0.69444, 0, 0],
      "41": [0.08333, 0.69444, 0, 0],
      "42": [0, 0.52083, 0, 0],
      "43": [-0.08056, 0.53055, 0, 0],
      "44": [0.13889, 0.125, 0, 0],
      "45": [-0.08056, 0.53055, 0, 0],
      "46": [0, 0.125, 0, 0],
      "47": [0.08333, 0.69444, 0, 0],
      "48": M11,
      "49": M11,
      "50": M11,
      "51": M11,
      "52": M11,
      "53": M11,
      "54": M11,
      "55": M11,
      "56": M11,
      "57": M11,
      "58": [0, 0.43056, 0, 0],
      "59": [0.13889, 0.43056, 0, 0],
      "60": [-0.05556, 0.55556, 0, 0],
      "61": [-0.19549, 0.41562, 0, 0],
      "62": [-0.05556, 0.55556, 0, 0],
      "63": M11,
      "64": M11,
      "65": M11,
      "66": M11,
      "67": M11,
      "68": M11,
      "69": M11,
      "70": M11,
      "71": M11,
      "72": M11,
      "73": M11,
      "74": M11,
      "75": M11,
      "76": M11,
      "77": M11,
      "78": M11,
      "79": M11,
      "80": M11,
      "81": [0.13889, 0.61111, 0, 0],
      "82": M11,
      "83": M11,
      "84": M11,
      "85": M11,
      "86": M11,
      "87": M11,
      "88": M11,
      "89": M11,
      "90": M11,
      "91": [0.08333, 0.69444, 0, 0],
      "92": [0.08333, 0.69444, 0, 0],
      "93": [0.08333, 0.69444, 0, 0],
      "94": M11,
      "95": [0.09514, 0, 0, 0],
      "96": M11,
      "97": [0, 0.43056, 0, 0],
      "98": M11,
      "99": [0, 0.43056, 0, 0],
      "100": M11,
      "101": [0, 0.43056, 0, 0],
      "102": M11,
      "103": [0.22222, 0.43056, 0, 0],
      "104": M11,
      "105": M11,
      "106": [0.22222, 0.61111, 0, 0],
      "107": M11,
      "108": M11,
      "109": [0, 0.43056, 0, 0],
      "110": [0, 0.43056, 0, 0],
      "111": [0, 0.43056, 0, 0],
      "112": [0.22222, 0.43056, 0, 0],
      "113": [0.22222, 0.43056, 0, 0],
      "114": [0, 0.43056, 0, 0],
      "115": [0, 0.43056, 0, 0],
      "116": [0, 0.55358, 0, 0],
      "117": [0, 0.43056, 0, 0],
      "118": [0, 0.43056, 0, 0],
      "119": [0, 0.43056, 0, 0],
      "120": [0, 0.43056, 0, 0],
      "121": [0.22222, 0.43056, 0, 0],
      "122": [0, 0.43056, 0, 0],
      "123": [0.08333, 0.69444, 0, 0],
      "124": [0.08333, 0.69444, 0, 0],
      "125": [0.08333, 0.69444, 0, 0],
      "126": M11,
      "127": M11,
      "160": M0,
      "176": M11,
      "184": [0.19445, 0, 0, 0],
      "305": [0, 0.43056, 0, 0],
      "567": [0.22222, 0.43056, 0, 0],
      "711": [0, 0.56597, 0, 0],
      "713": [0, 0.56555, 0, 0],
      "714": M11,
      "715": M11,
      "728": M11,
      "730": M11,
      "770": M11,
      "771": M11,
      "776": M11,
      "915": M11,
      "916": M11,
      "920": M11,
      "923": M11,
      "926": M11,
      "928": M11,
      "931": M11,
      "933": M11,
      "934": M11,
      "936": M11,
      "937": M11,
      "8216": M11,
      "8217": M11,
      "8242": M11,
      "9251": [0.11111, 0.21944, 0, 0]
    }
  };

  // src/core/font-metrics.ts
  var CJK_REGEX = /[\u3040-\u309F]|[\u30A0-\u30FF]|[\u4E00-\u9FAF]|[\uAC00-\uD7AF]/;
  var PT_PER_EM = 10;
  var AXIS_HEIGHT = 0.25;
  var BASELINE_SKIP = 1.2;
  var X_HEIGHT = 0.431;
  var FONT_METRICS = {
    slant: [0.25, 0.25, 0.25],
    space: [0, 0, 0],
    stretch: [0, 0, 0],
    shrink: [0, 0, 0],
    xHeight: [X_HEIGHT, X_HEIGHT, X_HEIGHT],
    quad: [1, 1.171, 1.472],
    extraSpace: [0, 0, 0],
    num1: [0.677, 0.732, 0.925],
    num2: [0.394, 0.384, 0.387],
    num3: [0.444, 0.471, 0.504],
    denom1: [0.686, 0.752, 1.025],
    denom2: [0.345, 0.344, 0.532],
    sup1: [0.413, 0.503, 0.504],
    sup2: [0.363, 0.431, 0.404],
    sup3: [0.289, 0.286, 0.294],
    sub1: [0.15, 0.143, 0.2],
    sub2: [0.247, 0.286, 0.4],
    supDrop: [0.386, 0.353, 0.494],
    subDrop: [0.05, 0.071, 0.1],
    delim1: [2.39, 1.7, 1.98],
    delim2: [1.01, 1.157, 1.42],
    axisHeight: [AXIS_HEIGHT, AXIS_HEIGHT, AXIS_HEIGHT],
    defaultRuleThickness: [0.04, 0.049, 0.049],
    bigOpSpacing1: [0.111, 0.111, 0.111],
    bigOpSpacing2: [0.166, 0.166, 0.166],
    bigOpSpacing3: [0.2, 0.2, 0.2],
    bigOpSpacing4: [0.6, 0.611, 0.611],
    bigOpSpacing5: [0.1, 0.143, 0.143],
    sqrtRuleThickness: [0.04, 0.04, 0.04]
  };
  var FONT_SCALE = [
    0,
    // not used
    0.5,
    // size 1 = scriptscriptstyle
    0.7,
    // size 2 = scriptstyle
    0.8,
    0.9,
    1,
    // size 5 = default
    1.2,
    1.44,
    1.728,
    2.074,
    2.488
    //size 10
  ];
  var DEFAULT_FONT_SIZE = 5;
  var extraCharacterMap = {
    "\xA0": " ",
    // NON-BREAKING SPACE is like space
    "\u200B": " ",
    // ZERO WIDTH SPACE is like space
    // Latin-1
    "\xC5": "A",
    "\xC7": "C",
    "\xD0": "D",
    "\xDE": "o",
    "\xE5": "a",
    "\xE7": "c",
    "\xF0": "d",
    "\xFE": "o",
    // Cyrillic
    "\u0410": "A",
    "\u0411": "B",
    "\u0412": "B",
    "\u0413": "F",
    "\u0414": "A",
    "\u0415": "E",
    "\u0416": "K",
    "\u0417": "3",
    "\u0418": "N",
    "\u0419": "N",
    "\u041A": "K",
    "\u041B": "N",
    "\u041C": "M",
    "\u041D": "H",
    "\u041E": "O",
    "\u041F": "N",
    "\u0420": "P",
    "\u0421": "C",
    "\u0422": "T",
    "\u0423": "y",
    "\u0424": "O",
    "\u0425": "X",
    "\u0426": "U",
    "\u0427": "h",
    "\u0428": "W",
    "\u0429": "W",
    "\u042A": "B",
    "\u042B": "X",
    "\u042C": "B",
    "\u042D": "3",
    "\u042E": "X",
    "\u042F": "R",
    "\u0430": "a",
    "\u0431": "b",
    "\u0432": "a",
    "\u0433": "r",
    "\u0434": "y",
    "\u0435": "e",
    "\u0436": "m",
    "\u0437": "e",
    "\u0438": "n",
    "\u0439": "n",
    "\u043A": "n",
    "\u043B": "n",
    "\u043C": "m",
    "\u043D": "n",
    "\u043E": "o",
    "\u043F": "n",
    "\u0440": "p",
    "\u0441": "c",
    "\u0442": "o",
    "\u0443": "y",
    "\u0444": "b",
    "\u0445": "x",
    "\u0446": "n",
    "\u0447": "n",
    "\u0448": "w",
    "\u0449": "w",
    "\u044A": "a",
    "\u044B": "m",
    "\u044C": "a",
    "\u044D": "e",
    "\u044E": "m",
    "\u044F": "r"
  };
  function getCharacterMetrics(codepoint, fontName) {
    if (codepoint === void 0)
      codepoint = 77;
    const metrics = font_metrics_data_default[fontName][codepoint];
    if (metrics) {
      return {
        defaultMetrics: false,
        depth: metrics[0],
        height: metrics[1],
        italic: metrics[2],
        skew: metrics[3]
      };
    }
    if (codepoint === 11034) {
      return {
        defaultMetrics: true,
        depth: 0.2,
        height: 0.8,
        italic: 0,
        skew: 0
      };
    }
    const char = String.fromCodePoint(codepoint);
    if (char in extraCharacterMap)
      codepoint = extraCharacterMap[char].codePointAt(0);
    else if (CJK_REGEX.test(char)) {
      codepoint = 77;
      return {
        defaultMetrics: true,
        depth: 0.2,
        height: 0.9,
        italic: 0,
        skew: 0
      };
    }
    return {
      defaultMetrics: true,
      depth: 0.2,
      height: 0.7,
      italic: 0,
      skew: 0
    };
  }

  // src/core/svg-box.ts
  var SVG_BODY = {
    // Adapted from https://github.com/KaTeX/KaTeX/blob/master/src/stretchy.js
    overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
    overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
    underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
    underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
    xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
    xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
    Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
    xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
    xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
    overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
    xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
    xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
    overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
    xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
    xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
    xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
    xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
    xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
    overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
    overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
    underbrace: [
      ["leftbraceunder", "midbraceunder", "rightbraceunder"],
      1.6,
      548
    ],
    underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
    xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
    xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
    xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
    xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
    xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
    xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
    overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
    underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
    overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
    undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
    xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
    xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
    // The next three arrows are from the mhchem package.
    // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
    // document as \xrightarrow or \xrightleftharpoons. Those have
    // min-length = 1.75em, so we set min-length on these next three to match.
    xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
    xrightequilibrium: [
      ["baraboveshortleftharpoon", "rightharpoonaboveshortbar"],
      1.75,
      716
    ],
    xleftequilibrium: [
      ["shortbaraboveleftharpoon", "shortrightharpoonabovebar"],
      1.75,
      716
    ]
  };
  var SVG_ACCENTS = {
    // ViewBoxWidth, viewBoxHeight, height
    widehat1: [1062, 239, 0.24],
    widehat2: [2364, 300, 0.3],
    widehat3: [2364, 360, 0.36],
    widehat4: [2364, 420, 0.42],
    widecheck1: [1062, 239, 0.24],
    widecheck2: [2364, 300, 0.3],
    widecheck3: [2364, 360, 0.36],
    widecheck4: [2364, 420, 0.42],
    widetilde1: [600, 260, 0.26],
    widetilde2: [1033, 286, 0.286],
    widetilde3: [2339, 306, 0.306],
    widetilde4: [2340, 312, 0.34],
    overarc: [1061, 159, 0.3],
    underarc: [1061, 159, 0.3]
  };
  var PATHS = {
    // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
    doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
    // Doublerightarrow is from glyph U+21D2 in font KaTeX Main
    doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
    // Leftarrow is from glyph U+2190 in font KaTeX Main
    leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
    // Overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
    leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
    leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
    overarc: `M529 0c179 0 524 115 524 115 5 1 9 5 9 10 0 1-1 2-1 3l-4 22c-1 5-5 9-11 9h-2s-338-93-512-92c-174 0-513 92-513 92h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13 0 0 342-115 520-115z`,
    underarc: `m 529 160
  c -179 0 -524 -115 -524 -115
  c -5 -1 -9 -5 -9 -10
  c 0 -1 1 -2 1 -3
  l 4 -22
  c 1 -5 5 -9 11 -9
  h 2
  s 338 93 512 92
  c 174 0 513 -92 513 -92
  h 2
  c 5 0 9 4 11 9
  l 5 22
  c 1 6 -2 12 -8 13
  c 0 0 -342 115 -520 115
  z
  `,
    // Overgroup is from the MnSymbol package (public domain)
    leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
    leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
    // Harpoons are from glyph U+21BD in font KaTeX Main
    leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
    leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
    leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
    leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
    // Hook is from glyph U+21A9 in font KaTeX Main
    lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
    leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
    leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
    // Tofrom is from glyph U+21C4 in font KaTeX AMS Regular
    leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
    longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
    midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
    midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
    oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
    oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
    oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
    oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
    rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
    rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
    rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
    rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
    rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
    rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
    rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
    rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
    rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
    righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
    rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
    rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
    // Twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
    twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
    twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
    // Tilde1 is a modified version of a glyph from the MnSymbol package
    widetilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
    // Ditto tilde2, tilde3, & tilde4
    widetilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
    widetilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
    widetilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
    // Vec is from glyph U+20D7 in font KaTeX Main
    vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
    // Widehat1 is a modified version of a glyph from the MnSymbol package
    widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
    // Ditto widehat2, widehat3, & widehat4
    widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
    widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
    widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
    // Widecheck paths are all inverted versions of widehat
    widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
    widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
    widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
    widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
    // The next ten paths support reaction arrows from the mhchem package.
    // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
    // baraboveleftarrow is mostly from from glyph U+2190 in font KaTeX Main
    baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
    // Rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
    rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
    // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
    // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
    baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
    rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
    shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
    shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
  };
  function svgBodyToMarkup(svgBodyName) {
    if (SVG_ACCENTS[svgBodyName]) {
      const [vbWidth, vbHeight, height2] = SVG_ACCENTS[svgBodyName];
      const result = `<span class="stretchy" style="height:${height2}em"><svg width="100%" height="${height2}em" viewBox="0 0 ${vbWidth} ${vbHeight}" preserveAspectRatio="none" ><path fill="currentcolor" d="${PATHS[svgBodyName]}"></path></svg></span>`;
      return `<span style="display:inline-block;height:${height2 / 2}em;min-width:0">${result}</span>`;
    }
    const [paths, minWidth, viewBoxHeight, align] = SVG_BODY[svgBodyName];
    let widthClasses;
    let aligns;
    const height = viewBoxHeight / 1e3;
    if (paths.length === 3) {
      widthClasses = ["slice-1-of-3", "slice-2-of-3", "slice-3-of-3"];
      aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
    } else if (paths.length === 2) {
      widthClasses = ["slice-1-of-2", "slice-2-of-2"];
      aligns = ["xMinYMin", "xMaxYMin"];
    } else {
      widthClasses = ["slice-1-of-1"];
      aligns = [align];
    }
    const body = paths.map(
      (path, i) => `<span class="${widthClasses[i]}" style=height:${height}em><svg width=400em height=${height}em viewBox="0 0 400000 ${viewBoxHeight}" preserveAspectRatio="${aligns[i]} slice"><path fill="currentcolor" d="${PATHS[path]}"></path></svg></span>`
    ).join("");
    return `<span style="display:inline-block;height:${height}em;min-width:${minWidth}em;">${body}</span>`;
  }
  function svgBodyHeight(svgBodyName) {
    if (SVG_BODY[svgBodyName])
      return SVG_BODY[svgBodyName][2] / 1e3;
    return SVG_ACCENTS[svgBodyName][2];
  }

  // src/core/modes-utils.ts
  var _Mode = class {
    constructor(name) {
      _Mode._registry[name] = this;
    }
    static createAtom(mode, command, context, style) {
      return _Mode._registry[mode].createAtom(command, context, style);
    }
    // `run` should be a run (sequence) of atoms all with the same
    // mode
    static serialize(run, options) {
      console.assert(run.length > 0);
      const mode = _Mode._registry[run[0].mode];
      return mode.serialize(run, options);
    }
    static applyStyle(mode, box, style) {
      return _Mode._registry[mode].applyStyle(box, style);
    }
  };
  var Mode = _Mode;
  Mode._registry = {};
  function getModeRuns(atoms) {
    const result = [];
    let run = [];
    let currentMode = "NONE";
    for (const atom of atoms) {
      if (atom.type !== "first") {
        if (atom.mode !== currentMode) {
          if (run.length > 0)
            result.push(run);
          run = [atom];
          currentMode = atom.mode;
        } else
          run.push(atom);
      }
    }
    if (run.length > 0)
      result.push(run);
    return result;
  }
  function getPropertyRuns(atoms, property) {
    const result = [];
    let run = [];
    let currentValue = void 0;
    for (const atom of atoms) {
      if (atom.type !== "first" && atom.style) {
        let value;
        if (property === "variant") {
          value = atom.style.variant;
          if (atom.style.variantStyle && atom.style.variantStyle !== "up")
            value += "-" + atom.style.variantStyle;
        } else if (property === "cssClass") {
          if (atom.type === "group")
            value = atom.customClass;
        } else
          value = atom.style[property];
        if (value === currentValue) {
          run.push(atom);
        } else {
          if (run.length > 0)
            result.push(run);
          run = [atom];
          currentValue = value;
        }
      }
    }
    if (run.length > 0)
      result.push(run);
    return result;
  }

  // src/core/types.ts
  var BOX_TYPE = [
    "",
    "chem",
    "mord",
    // > is an ordinary atom like x ;
    "mbin",
    // > is a binary operation atom like +
    "mop",
    // > is a large operator atom like $$\sum$$
    "mrel",
    // > is a relation atom like =
    "mopen",
    // > is an opening atom like (
    "mclose",
    // > is a closing atom like )
    "mpunct",
    // > is a punctuation atom like ,
    "minner",
    // >  is an inner atom like $$\frac12$$'
    "spacing",
    "first",
    "latex",
    "composition",
    "error",
    "placeholder",
    "supsub",
    "none",
    "mathfield"
  ];

  // src/core/box.ts
  function isBoxType(type) {
    return BOX_TYPE.includes(type);
  }
  var INTER_ATOM_SPACING = {
    mord: { mop: 3, mbin: 4, mrel: 5, minner: 3 },
    mop: { mord: 3, mop: 3, rel: 5, minner: 3 },
    mbin: { mord: 4, mop: 4, mopen: 4, minner: 4 },
    mrel: { mord: 5, mop: 5, mopen: 5, minner: 5 },
    mclose: { mop: 3, mbin: 4, mrel: 5, minner: 3 },
    mpunct: { mord: 3, mop: 3, mrel: 3, mopen: 3, mpunct: 3, minner: 3 },
    minner: { mord: 3, mop: 3, mbin: 4, mrel: 5, mopen: 3, mpunct: 3, minner: 3 }
  };
  var INTER_ATOM_TIGHT_SPACING = {
    mord: { mop: 3 },
    mop: { mord: 3, mop: 3 },
    mclose: { mop: 3 },
    minner: { mop: 3 }
  };
  function toString(arg1, arg2) {
    if (typeof arg1 === "string")
      return arg1;
    if (typeof arg1 === "number") {
      console.assert(Number.isFinite(arg1));
      const numValue = Math.ceil(100 * arg1) / 100;
      if (numValue === 0)
        return "0";
      return numValue.toString() + (arg2 != null ? arg2 : "");
    }
    return "";
  }
  var Box = class {
    constructor(content, options) {
      var _a3, _b3, _c2, _d2, _e, _f;
      if (typeof content === "number")
        this.value = String.fromCodePoint(content);
      else if (typeof content === "string")
        this.value = content;
      else if (isArray(content))
        this.children = content.filter((x) => x !== null);
      else if (content && content instanceof Box)
        this.children = [content];
      this.type = (_a3 = options == null ? void 0 : options.type) != null ? _a3 : "";
      this.isSelected = false;
      this.isTight = (_b3 = options == null ? void 0 : options.isTight) != null ? _b3 : false;
      this.newList = (_c2 = options == null ? void 0 : options.newList) != null ? _c2 : false;
      if (options == null ? void 0 : options.properties) {
        for (const prop of Object.keys(options.properties))
          this.setStyle(prop, options.properties[prop]);
      }
      if (options == null ? void 0 : options.attributes)
        this.attributes = options.attributes;
      this.classes = (_d2 = options == null ? void 0 : options.classes) != null ? _d2 : "";
      let fontName = (options == null ? void 0 : options.fontFamily) || "Main-Regular";
      if ((options == null ? void 0 : options.style) && this.value) {
        fontName = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        Mode.applyStyle((_e = options.mode) != null ? _e : "math", this, options.style) || "Main-Regular";
      }
      this.height = 0;
      this.depth = 0;
      this.skew = 0;
      this.italic = 0;
      this.maxFontSize = 0;
      if (this.type === "latex") {
        this.height = 0.8;
        this.depth = 0.2;
      } else if (typeof content === "number") {
        const metrics = getCharacterMetrics(content, fontName);
        this.height = metrics.height;
        this.depth = metrics.depth;
        this.skew = metrics.skew;
        this.italic = metrics.italic;
      } else if (this.value) {
        this.height = -Infinity;
        this.depth = -Infinity;
        this.skew = -Infinity;
        this.italic = -Infinity;
        for (let i = 0; i < this.value.length; i++) {
          const metrics = getCharacterMetrics(
            this.value.codePointAt(i),
            fontName || "Main-Regular"
          );
          this.height = Math.max(this.height, metrics.height);
          this.depth = Math.max(this.depth, metrics.depth);
          this.skew = metrics.skew;
          this.italic = metrics.italic;
        }
      } else if (this.children && this.children.length > 0) {
        if (this.children.length === 1) {
          const child = this.children[0];
          this.height = child.height;
          this.depth = child.depth;
          this.maxFontSize = child.maxFontSize;
          this.skew = child.skew;
          this.italic = child.italic;
        } else {
          let height = -Infinity;
          let depth = -Infinity;
          let maxFontSize = 0;
          for (const child of this.children) {
            if (child.height > height)
              height = child.height;
            if (child.depth > depth)
              depth = child.depth;
            maxFontSize = Math.max(maxFontSize, (_f = child.maxFontSize) != null ? _f : 0);
          }
          this.height = height;
          this.depth = depth;
          this.maxFontSize = maxFontSize;
        }
      }
      if ((options == null ? void 0 : options.height) !== void 0)
        this.height = options.height;
      if ((options == null ? void 0 : options.depth) !== void 0)
        this.depth = options.depth;
      if ((options == null ? void 0 : options.maxFontSize) !== void 0)
        this.maxFontSize = options.maxFontSize;
    }
    set atomID(id) {
      if (id === void 0 || id.length === 0)
        return;
      if (!this.attributes)
        this.attributes = {};
      this.attributes["data-atom-id"] = id;
    }
    selected(isSelected) {
      if (this.isSelected === isSelected)
        return;
      this.isSelected = isSelected;
      if (this.children)
        for (const child of this.children)
          child.selected(isSelected);
    }
    setStyle(prop, value, unit) {
      if (value === void 0)
        return;
      const v = toString(value, unit);
      if (v.length > 0) {
        if (!this.cssProperties)
          this.cssProperties = {};
        this.cssProperties[prop] = v;
      }
    }
    setTop(top) {
      if (Number.isFinite(top) && Math.abs(top) > 0.01) {
        if (!this.cssProperties)
          this.cssProperties = {};
        this.cssProperties.top = toString(top, "em");
        this.height -= top;
        this.depth += top;
      }
    }
    get left() {
      var _a3;
      if ((_a3 = this.cssProperties) == null ? void 0 : _a3["margin-left"])
        return Number.parseFloat(this.cssProperties["margin-left"]);
      return 0;
    }
    set left(value) {
      if (!Number.isFinite(value))
        return;
      if (value === 0) {
        if (this.cssProperties)
          delete this.cssProperties["margin-left"];
      } else {
        if (!this.cssProperties)
          this.cssProperties = {};
        this.cssProperties["margin-left"] = toString(value, "em");
      }
    }
    set right(value) {
      if (!Number.isFinite(value))
        return;
      if (value === 0) {
        if (this.cssProperties)
          delete this.cssProperties["margin-right"];
      } else {
        if (!this.cssProperties)
          this.cssProperties = {};
        this.cssProperties["margin-right"] = toString(value, "em");
      }
    }
    set width(value) {
      if (!Number.isFinite(value))
        return;
      if (value === 0) {
        if (this.cssProperties)
          delete this.cssProperties.width;
      } else {
        if (!this.cssProperties)
          this.cssProperties = {};
        this.cssProperties.width = toString(value, "em");
      }
    }
    /**
     * If necessary wrap this box with another one that adjust the font-size
     * to account for a change in size between the context and its parent.
     * Also, apply color and background-color attributes.
     */
    wrap(context, options) {
      const parent = context.parent;
      if (!parent)
        return this;
      if (context.isPhantom)
        this.setStyle("opacity", 0);
      let newColor = context.computedColor;
      if (newColor === parent.computedColor)
        newColor = "";
      this.setStyle("color", newColor);
      const newSize = context.effectiveFontSize === parent.effectiveFontSize ? void 0 : context.effectiveFontSize;
      let newBackgroundColor = context.computedBackgroundColor;
      if (this.isSelected)
        newBackgroundColor = highlight(newBackgroundColor);
      if (newBackgroundColor === parent.computedBackgroundColor)
        newBackgroundColor = "";
      if (!newSize && !newBackgroundColor && !(options && (options.classes || options.type)))
        return this;
      let result;
      if (newBackgroundColor) {
        result = makeStruts(this, options);
        result.selected(this.isSelected);
        result.setStyle("background-color", newBackgroundColor);
        result.setStyle("display", "inline-block");
      } else
        result = new Box(this, options);
      const factor = context.scalingFactor;
      if (factor !== 1) {
        result.setStyle("font-size", factor * 100, "%");
        result.height *= factor;
        result.depth *= factor;
        result.italic *= factor;
        result.skew *= factor;
      }
      return result;
    }
    /** If necessary, wrap this box in another that accounts for
     * selected backgroundColor
     */
    wrapSelect(context) {
      if (!this.isSelected)
        return this;
      const parent = context.parent;
      if (!parent)
        return this;
      const newBackgroundColor = highlight(context.computedBackgroundColor);
      const result = makeStruts(this);
      result.selected(true);
      result.setStyle("background-color", newBackgroundColor);
      result.setStyle("display", "inline-block");
      return result;
    }
    /**
     * Generate the HTML markup to represent this box.
     */
    toMarkup() {
      var _a3, _b3, _c2;
      let body = (_a3 = this.value) != null ? _a3 : "";
      if (this.children)
        for (const box of this.children)
          body += box.toMarkup();
      const classes = this.classes.split(" ");
      classes.push(
        (_b3 = {
          latex: "ML__latex",
          placeholder: "ML__placeholder",
          error: "ML__error"
        }[this.type]) != null ? _b3 : ""
      );
      if (this.caret === "latex")
        classes.push("ML__latex-caret");
      const classList = classes.length === 1 ? classes[0] : classes.filter((x, e, a) => x.length > 0 && a.indexOf(x) === e).join(" ");
      let result = "";
      if (body.length > 0 && body !== "\u200B" || classList.length > 0 || this.cssId || this.htmlData || this.htmlStyle || this.attributes || this.cssProperties || this.svgBody || this.svgOverlay) {
        let props = "";
        if (this.cssId) {
          props += ` id="${this.cssId.replace(/ /g, "-")}" `;
        }
        if (this.htmlData) {
          const entries = this.htmlData.split(",");
          for (const entry of entries) {
            const matched = entry.match(/([^=]+)=(.+$)/);
            if (matched) {
              const key = matched[1].trim().replace(/ /g, "-");
              if (key)
                props += ` data-${key}="${matched[2]}" `;
            } else {
              const key = entry.trim().replace(/ /g, "-");
              if (key)
                props += ` data-${key} `;
            }
          }
        }
        if (this.htmlStyle) {
          const entries = this.htmlStyle.split(";");
          let styleString = "";
          for (const entry of entries) {
            const matched = entry.match(/([^=]+):(.+$)/);
            if (matched) {
              const key = matched[1].trim().replace(/ /g, "-");
              if (key)
                styleString += `${key}:${matched[2]};`;
            }
          }
          if (styleString)
            props += ` style="${styleString}"`;
        }
        if (this.attributes) {
          props += " " + Object.keys(this.attributes).map((x) => `${x}="${this.attributes[x]}"`).join(" ");
        }
        if (classList.length > 0)
          props += ` class="${classList}"`;
        if (this.cssProperties) {
          const styleString = Object.keys(this.cssProperties).map((x) => `${x}:${this.cssProperties[x]}`).join(";");
          if (styleString.length > 0)
            props += ` style="${styleString}"`;
        }
        let svgMarkup = "";
        if (this.svgBody)
          svgMarkup = svgBodyToMarkup(this.svgBody);
        else if (this.svgOverlay) {
          svgMarkup = '<span style="';
          svgMarkup += "display: inline-block;";
          svgMarkup += `height:${this.height + this.depth}em;`;
          svgMarkup += `vertical-align:${this.depth}em;`;
          svgMarkup += '">';
          svgMarkup += body;
          svgMarkup += "</span>";
          svgMarkup += '<svg style="position:absolute;overflow:overlay;';
          svgMarkup += `height:${this.height + this.depth}em;`;
          if ((_c2 = this.cssProperties) == null ? void 0 : _c2.padding) {
            svgMarkup += `top:${this.cssProperties.padding}em;`;
            svgMarkup += `left:${this.cssProperties.padding}em;`;
            svgMarkup += `width:calc(100% - 2 * ${this.cssProperties.padding}em );`;
          } else
            svgMarkup += "top:0;left:0;width:100%;";
          svgMarkup += "z-index:2;";
          svgMarkup += '"';
          if (this.svgStyle)
            svgMarkup += ` style="${this.svgStyle}"`;
          svgMarkup += `>${this.svgOverlay}</svg>`;
        }
        result = `<span${props}>${body}${svgMarkup}</span>`;
      }
      if (this.caret === "text")
        result += '<span class="ML__text-caret"></span>';
      else if (this.caret === "math")
        result += '<span class="ML__caret"></span>';
      return result;
    }
    /**
     * Can this box be coalesced with 'box'?
     * This is used to 'coalesce' (i.e. group together) a series of boxes that are
     * identical except for their value, and to avoid generating redundant boxes.
     * That is: '12' ->
     *      "<span class='crm'>12</span>"
     * rather than:
     *      "<span class='crm'>1</span><span class='crm'>2</span>"
     */
    tryCoalesceWith(box) {
      if (this.type !== box.type)
        return false;
      if (!/ML__text/.test(this.classes) && !["mord", "mbin", "mrel"].includes(this.type))
        return false;
      if (this.svgBody || !this.value)
        return false;
      if (box.svgBody || !box.value)
        return false;
      const hasChildren = this.children && this.children.length > 0;
      const boxHasChildren = box.children && box.children.length > 0;
      if (hasChildren || boxHasChildren)
        return false;
      const thisStyleCount = this.cssProperties ? Object.keys(this.cssProperties).length : 0;
      const boxStyleCount = box.cssProperties ? Object.keys(box.cssProperties).length : 0;
      if (thisStyleCount !== boxStyleCount)
        return false;
      if (thisStyleCount > 0) {
        for (const prop of Object.keys(this.cssProperties))
          if (this.cssProperties[prop] !== box.cssProperties[prop])
            return false;
      }
      const classes = this.classes.trim().replace(/\s+/g, " ").split(" ");
      const boxClasses = box.classes.trim().replace(/\s+/g, " ").split(" ");
      if (classes.length !== boxClasses.length)
        return false;
      classes.sort();
      boxClasses.sort();
      for (const [i, class_] of classes.entries()) {
        if (class_ === "vertical-separator")
          return false;
        if (class_ !== boxClasses[i])
          return false;
      }
      this.value += box.value;
      this.height = Math.max(this.height, box.height);
      this.depth = Math.max(this.depth, box.depth);
      this.maxFontSize = Math.max(this.maxFontSize, box.maxFontSize);
      this.italic = box.italic;
      return true;
    }
  };
  function coalesceRecursive(boxes) {
    if (!boxes || boxes.length === 0)
      return [];
    boxes[0].children = coalesceRecursive(boxes[0].children);
    const result = [boxes[0]];
    for (let i = 1; i < boxes.length; i++) {
      if (!result[result.length - 1].tryCoalesceWith(boxes[i])) {
        boxes[i].children = coalesceRecursive(boxes[i].children);
        result.push(boxes[i]);
      }
    }
    return result;
  }
  function coalesce(box) {
    if (box.children)
      box.children = coalesceRecursive(box.children);
    return box;
  }
  function adjustType(root) {
    forEachBox(root, (prevBox, box) => {
      if (box.type === "mbin" && (!prevBox || /first|none|mbin|mop|mrel|mopen|mpunct/.test(prevBox.type)))
        box.type = "mord";
      if (prevBox && prevBox.type === "mbin" && /mrel|mclose|mpunct|placeholder/.test(box.type))
        prevBox.type = "mord";
    });
  }
  function applyInterAtomSpacing(root, context) {
    forEachBox(root, (prevBox, box) => {
      var _a3, _b3, _c2, _d2;
      const prevType = (_a3 = prevBox == null ? void 0 : prevBox.type) != null ? _a3 : "none";
      const table = box.isTight ? (_b3 = INTER_ATOM_TIGHT_SPACING[prevType]) != null ? _b3 : null : (_c2 = INTER_ATOM_SPACING[prevType]) != null ? _c2 : null;
      const hskip = (_d2 = table == null ? void 0 : table[box.type]) != null ? _d2 : "none";
      if (hskip !== "none") {
        if (hskip === 3)
          box.left += context.getRegisterAsEm("thinmuskip");
        if (hskip === 4)
          box.left += context.getRegisterAsEm("medmuskip");
        if (hskip === 5)
          box.left += context.getRegisterAsEm("thickmuskip");
      }
    });
  }
  function forEachBoxRecursive(prevBox, box, f) {
    if (box.newList)
      prevBox = null;
    const type = box.type;
    if (type === "first") {
      console.assert(box.newList === true);
      return null;
    }
    if (type === "spacing")
      return prevBox;
    f(prevBox, box);
    if (box.children) {
      let childPrev = null;
      if (type === void 0 || type.length === 0)
        childPrev = prevBox;
      for (const child of box.children)
        childPrev = forEachBoxRecursive(childPrev, child, f);
      if (type === void 0 || type.length === 0)
        prevBox = childPrev;
    }
    if (type !== "supsub" && type !== void 0 && type.length > 0)
      prevBox = box;
    return prevBox;
  }
  function forEachBox(box, f) {
    if (!box)
      return;
    forEachBoxRecursive(null, box, f);
  }
  function adjustInterAtomSpacing(root, context) {
    adjustType(root);
    applyInterAtomSpacing(root, context);
    return root;
  }
  function makeStruts(content, options) {
    if (!content)
      return new Box(null, options);
    const topStrut = new Box(null, { classes: "ML__strut" });
    topStrut.setStyle("height", Math.max(0, content.height), "em");
    const struts = [topStrut];
    if (content.depth !== 0) {
      const bottomStrut = new Box(null, { classes: "ML__strut--bottom" });
      bottomStrut.setStyle("height", content.height + content.depth, "em");
      bottomStrut.setStyle("vertical-align", -content.depth, "em");
      struts.push(bottomStrut);
    }
    struts.push(content);
    return new Box(struts, options);
  }
  function addSVGOverlay(body, svgMarkup, svgStyle) {
    body.svgOverlay = svgMarkup;
    body.svgStyle = svgStyle;
    return body;
  }
  function makeSVGBox(svgBodyName) {
    const height = svgBodyHeight(svgBodyName) / 2;
    const box = new Box(null, {
      height: height + 0.166,
      depth: height - 0.166,
      maxFontSize: 0
    });
    box.svgBody = svgBodyName;
    return box;
  }

  // src/core/v-box.ts
  function getVListChildrenAndDepth(params) {
    if ("individualShift" in params) {
      const oldChildren = params.individualShift;
      let prevChild = oldChildren[0];
      const children = [prevChild];
      const depth = -prevChild.shift - prevChild.box.depth;
      let currPos = depth;
      for (let i = 1; i < oldChildren.length; i++) {
        const child = oldChildren[i];
        const diff = -child.shift - currPos - child.box.depth;
        const size = diff - (prevChild.box.height + prevChild.box.depth);
        currPos = currPos + diff;
        children.push(size);
        children.push(child);
        prevChild = child;
      }
      return [children, depth];
    }
    if ("top" in params) {
      let bottom = params.top;
      for (const child of params.children) {
        bottom -= typeof child === "number" ? child : child.box.height + child.box.depth;
      }
      return [params.children, bottom];
    } else if ("bottom" in params)
      return [params.children, -params.bottom];
    else if ("firstBaseline" in params) {
      const firstChild = params.firstBaseline[0];
      if (typeof firstChild === "number")
        throw new Error("First child must be an element.");
      return [params.firstBaseline, -firstChild.box.depth];
    } else if ("shift" in params) {
      const firstChild = params.children[0];
      if (typeof firstChild === "number")
        throw new Error("First child must be an element.");
      return [params.children, -firstChild.box.depth - params.shift];
    }
    return [null, 0];
  }
  function makeRows(params) {
    var _a3;
    const [children, depth] = getVListChildrenAndDepth(params);
    if (!children)
      return [[], 0, 0];
    let pstrutSize = 0;
    for (const child of children) {
      if (typeof child !== "number") {
        const box = child.box;
        pstrutSize = Math.max(pstrutSize, box.maxFontSize, box.height);
      }
    }
    pstrutSize += 2;
    const pstrut = new Box(null, { classes: "pstrut" });
    pstrut.setStyle("height", pstrutSize, "em");
    const realChildren = [];
    let minPos = depth;
    let maxPos = depth;
    let currPos = depth;
    for (const child of children) {
      if (typeof child === "number")
        currPos += child;
      else {
        const box = child.box;
        const classes = (_a3 = child.classes) != null ? _a3 : [];
        const childWrap = new Box([pstrut, box], {
          classes: classes.join(" "),
          style: child.style
        });
        childWrap.setStyle("top", -pstrutSize - currPos - box.depth, "em");
        if (child.marginLeft)
          childWrap.setStyle("margin-left", child.marginLeft, "em");
        if (child.marginRight)
          childWrap.setStyle("margin-right", child.marginRight, "em");
        realChildren.push(childWrap);
        currPos += box.height + box.depth;
      }
      minPos = Math.min(minPos, currPos);
      maxPos = Math.max(maxPos, currPos);
    }
    const vlist = new Box(realChildren, { classes: "vlist" });
    vlist.setStyle("height", maxPos, "em");
    if (minPos >= 0)
      return [[new Box(vlist, { classes: "vlist-r" })], maxPos, -minPos];
    const depthStrut = new Box(new Box(null), { classes: "vlist" });
    depthStrut.setStyle("height", -minPos, "em");
    const topStrut = new Box(8203, {
      classes: "vlist-s",
      maxFontSize: 0,
      height: 0,
      depth: 0
    });
    return [
      [
        new Box([vlist, topStrut], { classes: "vlist-r" }),
        new Box(depthStrut, { classes: "vlist-r" })
      ],
      maxPos,
      -minPos
    ];
  }
  var VBox = class extends Box {
    constructor(content, options) {
      var _a3;
      const [rows, height, depth] = makeRows(content);
      super(rows.length === 1 ? rows[0] : rows, {
        classes: ((_a3 = options == null ? void 0 : options.classes) != null ? _a3 : "") + " vlist-t" + (rows.length === 2 ? " vlist-t2" : ""),
        height,
        depth,
        type: options == null ? void 0 : options.type
      });
    }
  };
  function makeLimitsStack(context, options) {
    var _a3, _b3, _c2, _d2, _e;
    const metrics = context.metrics;
    const base = new Box(options.base);
    const baseShift = (_a3 = options.baseShift) != null ? _a3 : 0;
    const slant = (_b3 = options.slant) != null ? _b3 : 0;
    let aboveShift = 0;
    let belowShift = 0;
    if (options.above) {
      aboveShift = (_c2 = options.aboveShift) != null ? _c2 : Math.max(
        metrics.bigOpSpacing1,
        metrics.bigOpSpacing3 - options.above.depth
      );
    }
    if (options.below) {
      belowShift = (_d2 = options.belowShift) != null ? _d2 : Math.max(
        metrics.bigOpSpacing2,
        metrics.bigOpSpacing4 - options.below.height
      );
    }
    let result = null;
    if (options.below && options.above) {
      const bottom = metrics.bigOpSpacing5 + options.below.height + options.below.depth + belowShift + base.depth + baseShift;
      result = new VBox({
        bottom,
        children: [
          metrics.bigOpSpacing5,
          {
            box: options.below,
            marginLeft: -slant,
            classes: ["ML__center"]
          },
          belowShift,
          //  We need to center the base to account for the case where the
          // above/below is wider
          { box: base, classes: ["ML__center"] },
          aboveShift,
          {
            box: options.above,
            marginLeft: slant,
            classes: ["ML__center"]
          },
          metrics.bigOpSpacing5
        ]
      }).wrap(context);
    } else if (options.below && !options.above) {
      result = new VBox({
        top: base.height - baseShift,
        children: [
          metrics.bigOpSpacing5,
          {
            box: options.below,
            marginLeft: -slant,
            classes: ["ML__center"]
          },
          belowShift,
          { box: base, classes: ["ML__center"] }
        ]
      }).wrap(context);
    } else if (!options.below && options.above) {
      const bottom = base.depth + baseShift;
      result = new VBox({
        bottom,
        children: [
          { box: base, classes: ["ML__center"] },
          aboveShift,
          {
            box: options.above,
            marginLeft: slant,
            classes: ["ML__center"]
          },
          metrics.bigOpSpacing5
        ]
      }).wrap(context);
    } else {
      const bottom = base.depth + baseShift;
      result = new VBox({
        bottom,
        children: [{ box: base }, metrics.bigOpSpacing5]
      }).wrap(context);
    }
    console.assert(options.type !== void 0);
    return new Box(result, { type: (_e = options.type) != null ? _e : "mop" });
  }

  // src/core/grapheme-splitter.ts
  function stringToCodepoints(string) {
    const result = [];
    for (let i = 0; i < string.length; i++) {
      let code = string.charCodeAt(i);
      if (code === 13 && string.charCodeAt(i + 1) === 10) {
        code = 10;
        i++;
      }
      if (code === 13 || code === 12)
        code = 10;
      if (code === 0)
        code = 65533;
      if (code >= 55296 && code <= 56319) {
        const nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          const lead = code - 55296;
          const trail = nextCode - 56320;
          code = 2 ** 16 + lead * 2 ** 10 + trail;
          i++;
        }
      }
      result.push(code);
    }
    return result;
  }
  var ZWJ = 8205;
  var EMOJI_COMBINATOR = [
    [ZWJ, 1],
    [65038, 2],
    // VS-15: text presentation, VS-16: Emoji presentation
    [127995, 5],
    // EMOJI_MODIFIER_FITZPATRICK_TYPE 1-6
    [129456, 4],
    // Red hair..white hair
    [917536, 96]
    // EMOJI_TAG
  ];
  var emojiCombinator;
  var REGIONAL_INDICATOR = [127462, 127487];
  function isEmojiCombinator(code) {
    var _a3;
    if (emojiCombinator === void 0) {
      emojiCombinator = {};
      for (const x of EMOJI_COMBINATOR)
        for (let i = x[0]; i <= x[0] + x[1] - 1; i++)
          emojiCombinator[i] = true;
    }
    return (_a3 = emojiCombinator[code]) != null ? _a3 : false;
  }
  function isRegionalIndicator(code) {
    return code >= REGIONAL_INDICATOR[0] && code <= REGIONAL_INDICATOR[1];
  }
  function splitGraphemes(string) {
    if (/^[\u0020-\u00FF]*$/.test(string))
      return string;
    const result = [];
    const codePoints = stringToCodepoints(string);
    let index = 0;
    while (index < codePoints.length) {
      const code = codePoints[index++];
      const next = codePoints[index];
      if (next === ZWJ) {
        const baseIndex = index - 1;
        index += 2;
        while (codePoints[index] === ZWJ)
          index += 2;
        result.push(
          String.fromCodePoint(
            ...codePoints.slice(baseIndex, index - baseIndex + 1)
          )
        );
      } else if (isEmojiCombinator(next)) {
        const baseIndex = index - 1;
        while (isEmojiCombinator(codePoints[index]))
          index += codePoints[index] === ZWJ ? 2 : 1;
        result.push(
          String.fromCodePoint(
            ...codePoints.slice(baseIndex, 2 * index - baseIndex - 1)
          )
        );
      } else if (isRegionalIndicator(code)) {
        index += 1;
        result.push(String.fromCodePoint(...codePoints.slice(index - 2, 2)));
      } else
        result.push(String.fromCodePoint(code));
    }
    return result;
  }

  // src/core/tokenizer.ts
  var Tokenizer = class {
    constructor(s) {
      this.s = splitGraphemes(s);
      this.pos = 0;
      this.obeyspaces = false;
    }
    /**
     * @return True if we reached the end of the stream
     */
    end() {
      return this.pos >= this.s.length;
    }
    /**
     * Return the next char and advance
     */
    get() {
      return this.pos < this.s.length ? this.s[this.pos++] : "";
    }
    /**
     * Return the next char, but do not advance
     */
    peek() {
      return this.s[this.pos];
    }
    /**
     * Return the next substring matching regEx and advance.
     */
    match(regEx) {
      const execResult = typeof this.s === "string" ? regEx.exec(this.s.slice(this.pos)) : regEx.exec(this.s.slice(this.pos).join(""));
      if (execResult == null ? void 0 : execResult[0]) {
        this.pos += execResult[0].length;
        return execResult[0];
      }
      return "";
    }
    /**
     * Return the next token, or null.
     */
    next() {
      if (this.end())
        return null;
      if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]+/)) {
        return "<space>";
      }
      if (this.obeyspaces && this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]/)) {
        return "<space>";
      }
      const next = this.get();
      if (next === "\\") {
        if (!this.end()) {
          let command = this.match(/^[a-zA-Z\*]+/);
          if (command) {
            this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]*/);
          } else {
            command = this.get();
            if (command === " ") {
              return "<space>";
            }
          }
          return "\\" + command;
        }
      } else if (next === "{") {
        return "<{>";
      } else if (next === "}") {
        return "<}>";
      } else if (next === "^") {
        if (this.peek() === "^") {
          this.get();
          const hex = this.match(
            /^(\^(\^(\^(\^[\da-f])?[\da-f])?[\da-f])?[\da-f])?[\da-f]{2}/
          );
          if (hex) {
            return String.fromCodePoint(
              Number.parseInt(hex.slice(hex.lastIndexOf("^") + 1), 16)
            );
          }
        }
        return next;
      } else if (next === "#") {
        if (!this.end()) {
          let isParameter = false;
          if (/[\d?@]/.test(this.peek())) {
            isParameter = true;
            if (this.pos + 1 < this.s.length) {
              const after = this.s[this.pos + 1];
              isParameter = /[^\dA-Za-z]/.test(after);
            }
          }
          if (isParameter)
            return "#" + this.get();
          return "#";
        }
      } else if (next === "$") {
        if (this.peek() === "$") {
          this.get();
          return "<$$>";
        }
        return "<$>";
      }
      return next;
    }
  };
  function expand(lex, args) {
    var _a3, _b3, _c2, _d2;
    const result = [];
    let token = lex.next();
    if (token) {
      if (token === "\\relax") {
      } else if (token === "\\noexpand") {
        token = lex.next();
        if (token)
          result.push(token);
      } else if (token === "\\obeyspaces")
        lex.obeyspaces = true;
      else if (token === "\\space" || token === "~") {
        result.push("<space>");
      } else if (token === "\\bgroup") {
        result.push("<{>");
      } else if (token === "\\egroup") {
        result.push("<}>");
      } else if (token === "\\string") {
        token = lex.next();
        if (token) {
          if (token.startsWith("\\"))
            for (const x of token)
              result.push(x === "\\" ? "\\backslash" : x);
          else if (token === "<{>")
            result.push("\\{");
          else if (token === "<space>")
            result.push("~");
          else if (token === "<}>")
            result.push("\\}");
        }
      } else if (token === "\\csname") {
        while (lex.peek() === "<space>")
          lex.next();
        let command = "";
        let done = false;
        let tokens = [];
        do {
          if (tokens.length === 0) {
            if (/^#[\d?@]$/.test(lex.peek())) {
              const parameter = lex.get().slice(1);
              tokens = tokenize(
                (_b3 = (_a3 = args == null ? void 0 : args(parameter)) != null ? _a3 : args == null ? void 0 : args("?")) != null ? _b3 : "\\placeholder{}",
                args
              );
              token = tokens[0];
            } else {
              token = lex.next();
              tokens = token ? [token] : [];
            }
          }
          done = tokens.length === 0;
          if (!done && token === "\\endcsname") {
            done = true;
            tokens.shift();
          }
          if (!done) {
            done = token === "<$>" || token === "<$$>" || token === "<{>" || token === "<}>" || typeof token === "string" && token.length > 1 && token.startsWith("\\");
          }
          if (!done)
            command += tokens.shift();
        } while (!done);
        if (command)
          result.push("\\" + command);
        result.push(...tokens);
      } else if (token === "\\endcsname") {
      } else if (token.length > 1 && token.startsWith("#")) {
        const parameter = token.slice(1);
        result.push(
          ...tokenize((_d2 = (_c2 = args == null ? void 0 : args(parameter)) != null ? _c2 : args == null ? void 0 : args("?")) != null ? _d2 : "\\placeholder{}", args)
        );
      } else
        result.push(token);
    }
    return result;
  }
  function tokenize(s, args = null) {
    const stream = [];
    let sep = "";
    for (const line of s.toString().split(/\r?\n/)) {
      if (sep)
        stream.push(sep);
      sep = " ";
      const m = line.match(/((?:\\%)|[^%])*/);
      if (m !== null)
        stream.push(m[0]);
    }
    const tokenizer = new Tokenizer(stream.join(""));
    const result = [];
    do
      result.push(...expand(tokenizer, args));
    while (!tokenizer.end());
    return result;
  }
  function joinLatex(segments) {
    let sep = "";
    const result = [];
    for (const segment of segments) {
      if (segment) {
        if (/[a-zA-Z\*]/.test(segment[0]))
          result.push(sep);
        result.push(segment);
        if (/\\[a-zA-Z]+\*?[\"\'][^\ ]+$/.test(segment))
          result.push(" ");
        sep = /\\[a-zA-Z]+\*?$/.test(segment) ? " " : "";
      }
    }
    return result.join("");
  }
  function tokensToString(tokens) {
    return joinLatex(
      tokens.map((token) => {
        var _a3;
        return (_a3 = {
          "<space>": " ",
          "<$$>": "$$",
          "<$>": "$",
          "<{>": "{",
          "<}>": "}"
        }[token]) != null ? _a3 : token;
      })
    );
  }

  // src/core-definitions/unicode.ts
  var MATH_LETTER_EXCEPTIONS = {
    119893: 8462,
    119965: 8492,
    119968: 8496,
    119969: 8497,
    119971: 8459,
    119972: 8464,
    119975: 8466,
    119976: 8499,
    119981: 8475,
    119994: 8495,
    119996: 8458,
    120004: 8500,
    120070: 8493,
    120075: 8460,
    120076: 8465,
    120085: 8476,
    120093: 8488,
    120122: 8450,
    120127: 8461,
    120133: 8469,
    120135: 8473,
    120136: 8474,
    120137: 8477,
    120145: 8484
  };
  var MATH_UNICODE_BLOCKS = [
    { start: 119808, len: 26, offset: 65, style: "bold" },
    { start: 119834, len: 26, offset: 97, style: "bold" },
    { start: 119860, len: 26, offset: 65, style: "italic" },
    { start: 119886, len: 26, offset: 97, style: "italic" },
    { start: 119912, len: 26, offset: 65, style: "bolditalic" },
    { start: 119938, len: 26, offset: 97, style: "bolditalic" },
    { start: 119964, len: 26, offset: 65, variant: "script" },
    { start: 119990, len: 26, offset: 97, variant: "script" },
    { start: 120016, len: 26, offset: 65, variant: "script", style: "bold" },
    { start: 120042, len: 26, offset: 97, variant: "script", style: "bold" },
    { start: 120068, len: 26, offset: 65, variant: "fraktur" },
    { start: 120094, len: 26, offset: 97, variant: "fraktur" },
    { start: 120172, len: 26, offset: 65, variant: "fraktur", style: "bold" },
    { start: 120198, len: 26, offset: 97, variant: "fraktur", style: "bold" },
    { start: 120120, len: 26, offset: 65, variant: "double-struck" },
    { start: 120146, len: 26, offset: 97, variant: "double-struck" },
    { start: 120224, len: 26, offset: 65, variant: "sans-serif" },
    { start: 120250, len: 26, offset: 97, variant: "sans-serif" },
    {
      start: 120276,
      len: 26,
      offset: 65,
      variant: "sans-serif",
      style: "bold"
    },
    {
      start: 120302,
      len: 26,
      offset: 97,
      variant: "sans-serif",
      style: "bold"
    },
    {
      start: 120328,
      len: 26,
      offset: 65,
      variant: "sans-serif",
      style: "italic"
    },
    {
      start: 120354,
      len: 26,
      offset: 97,
      variant: "sans-serif",
      style: "italic"
    },
    {
      start: 120380,
      len: 26,
      offset: 65,
      variant: "sans-serif",
      style: "bolditalic"
    },
    {
      start: 120406,
      len: 26,
      offset: 97,
      variant: "sans-serif",
      style: "bolditalic"
    },
    { start: 120432, len: 26, offset: 65, variant: "monospace" },
    { start: 120458, len: 26, offset: 97, variant: "monospace" },
    { start: 120488, len: 25, offset: 913, style: "bold" },
    { start: 120514, len: 25, offset: 945, style: "bold" },
    { start: 120546, len: 25, offset: 913, style: "italic" },
    { start: 120572, len: 25, offset: 945, style: "italic" },
    { start: 120604, len: 25, offset: 913, style: "bolditalic" },
    { start: 120630, len: 25, offset: 945, style: "bolditalic" },
    {
      start: 120662,
      len: 25,
      offset: 913,
      variant: "sans-serif",
      style: "bold"
    },
    {
      start: 120688,
      len: 25,
      offset: 945,
      variant: "sans-serif",
      style: "bold"
    },
    {
      start: 120720,
      len: 25,
      offset: 913,
      variant: "sans-serif",
      style: "bolditalic"
    },
    {
      start: 120746,
      len: 25,
      offset: 945,
      variant: "sans-serif",
      style: "bolditalic"
    },
    { start: 120782, len: 10, offset: 48, variant: "main", style: "bold" },
    { start: 120792, len: 10, offset: 48, variant: "double-struck" },
    { start: 120803, len: 10, offset: 48, variant: "sans-serif" },
    {
      start: 120812,
      len: 10,
      offset: 48,
      variant: "sans-serif",
      style: "bold"
    },
    { start: 120822, len: 10, offset: 48, variant: "monospace" }
  ];
  function mathVariantToUnicode(char, variant, style) {
    if (!/[A-Za-z\d]/.test(char))
      return char;
    if (!variant && !style)
      return char;
    const codepoint = char.codePointAt(0);
    if (codepoint === void 0)
      return char;
    for (const MATH_UNICODE_BLOCK of MATH_UNICODE_BLOCKS) {
      if (!variant || MATH_UNICODE_BLOCK.variant === variant) {
        if (!style || MATH_UNICODE_BLOCK.style === style) {
          if (codepoint >= MATH_UNICODE_BLOCK.offset && codepoint < MATH_UNICODE_BLOCK.offset + MATH_UNICODE_BLOCK.len) {
            const result = MATH_UNICODE_BLOCK.start + codepoint - MATH_UNICODE_BLOCK.offset;
            return String.fromCodePoint(MATH_LETTER_EXCEPTIONS[result] || result);
          }
        }
      }
    }
    return char;
  }
  function unicodeToMathVariant(codepoint) {
    var _a3;
    if ((codepoint < 119808 || codepoint > 120831) && (codepoint < 8448 || codepoint > 8527))
      return { char: String.fromCodePoint(codepoint) };
    for (const c in MATH_LETTER_EXCEPTIONS) {
      if (MATH_LETTER_EXCEPTIONS[c] === codepoint) {
        codepoint = (_a3 = c.codePointAt(0)) != null ? _a3 : 0;
        break;
      }
    }
    for (const MATH_UNICODE_BLOCK of MATH_UNICODE_BLOCKS) {
      if (codepoint >= MATH_UNICODE_BLOCK.start && codepoint < MATH_UNICODE_BLOCK.start + MATH_UNICODE_BLOCK.len) {
        return {
          char: String.fromCodePoint(
            codepoint - MATH_UNICODE_BLOCK.start + MATH_UNICODE_BLOCK.offset
          ),
          variant: MATH_UNICODE_BLOCK.variant,
          style: MATH_UNICODE_BLOCK.style
        };
      }
    }
    return { char: String.fromCodePoint(codepoint) };
  }

  // src/core-definitions/definitions-utils.ts
  var MATH_SYMBOLS = {};
  var REVERSE_MATH_SYMBOLS = {
    60: "\\lt",
    62: "\\gt",
    111: "o",
    // Also \omicron
    38: "\\&",
    // Also \And
    123: "\\lbrace",
    125: "\\rbrace",
    91: "\\lbrack",
    93: "\\rbrack",
    58: "\\colon",
    // Also :
    160: "~",
    // Also \space
    172: "\\neg",
    // Also \lnot
    183: "\\cdot",
    188: "\\frac{1}{4}",
    189: "\\frac{1}{2}",
    190: "\\frac{3}{4}",
    8304: "^{0}",
    8305: "^{i}",
    185: "^{1}",
    178: "^{2}",
    179: "^{3}",
    8224: "\\dagger",
    // Also \dag
    8225: "\\ddagger",
    // Also \ddag
    8230: "\\ldots",
    // Also \mathellipsis
    8308: "^{4}",
    8309: "^{5}",
    8310: "^{6}",
    8311: "^{7}",
    8312: "^{8}",
    8313: "^{9}",
    8314: "^{+}",
    8315: "^{-}",
    8316: "^{=}",
    8319: "^{n}",
    8320: "_{0}",
    8321: "_{1}",
    8322: "_{2}",
    8323: "_{3}",
    8324: "_{4}",
    8325: "_{5}",
    8326: "_{6}",
    8327: "_{7}",
    8328: "_{8}",
    8329: "_{9}",
    8330: "_{+}",
    8331: "_{-}",
    8332: "_{=}",
    8336: "_{a}",
    8337: "_{e}",
    8338: "_{o}",
    8339: "_{x}",
    8242: "\\prime",
    39: "\\prime",
    8592: "\\gets",
    // Also \leftarrow
    8594: "\\to",
    // Also \rightarrow
    9651: "\\triangle",
    // Also \bigtriangleup, \vartriangle
    9661: "\\triangledown",
    8715: "\\owns",
    // Also \ni
    8727: "\\ast",
    // Also *
    8739: "\\vert",
    // Also |, \mvert, \lvert, \rvert
    8741: "\\Vert",
    // Also \parallel \shortparallel
    8743: "\\land",
    // Also \wedge
    8744: "\\lor",
    // Also \vee
    8901: "\\cdot",
    // Also \centerdot, \cdotp
    8904: "\\bowtie",
    // Also \Joint
    8800: "\\ne",
    // Also \neq
    8804: "\\le",
    // Also \leq
    8805: "\\ge",
    // Also \geq
    8869: "\\bot",
    // Also \perp
    10231: "\\biconditional",
    // Also \longleftrightarrow
    10232: "\\impliedby",
    // Also \Longleftarrow
    10233: "\\implies",
    // Also \Longrightarrow
    10234: "\\iff",
    8450: "\\mathbb{C}",
    // Also \doubleStruckCapitalC
    8469: "\\mathbb{N}",
    // Also \doubleStruckCapitalN
    8473: "\\mathbb{P}",
    // Also \doubleStruckCapitalP
    8474: "\\mathbb{Q}",
    // Also \doubleStruckCapitalQ
    8477: "\\mathbb{R}",
    // Also \doubleStruckCapitalR
    8484: "\\mathbb{Z}",
    // Also \doubleStruckCapitalZ
    8461: "\\mathbb{H}",
    8476: "\\Re",
    8465: "\\Im",
    42: "\\ast",
    11036: "\\square",
    9633: "\\square",
    8720: "\\coprod",
    8716: "\\not\\ni",
    9671: "\\diamond",
    8846: "\\uplus",
    8851: "\\sqcap",
    8852: "\\sqcup",
    8768: "\\wr",
    8750: "\\oint",
    8226: "\\textbullet",
    8722: "-",
    978: "\\Upsilon"
  };
  var LATEX_COMMANDS = {};
  var ENVIRONMENTS = {};
  var TEXVC_MACROS = {
    //////////////////////////////////////////////////////////////////////
    // texvc.sty
    // The texvc package contains macros available in mediawiki pages.
    // We omit the functions deprecated at
    // https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax
    // We also omit texvc's \O, which conflicts with \text{\O}
    darr: "\\downarrow",
    dArr: "\\Downarrow",
    Darr: "\\Downarrow",
    lang: "\\langle",
    rang: "\\rangle",
    uarr: "\\uparrow",
    uArr: "\\Uparrow",
    Uarr: "\\Uparrow",
    N: "\\mathbb{N}",
    R: "\\mathbb{R}",
    Z: "\\mathbb{Z}",
    alef: "\\aleph",
    alefsym: "\\aleph",
    Alpha: "\\mathrm{A}",
    Beta: "\\mathrm{B}",
    bull: "\\bullet",
    Chi: "\\mathrm{X}",
    clubs: "\\clubsuit",
    cnums: "\\mathbb{C}",
    Complex: "\\mathbb{C}",
    Dagger: "\\ddagger",
    diamonds: "\\diamondsuit",
    empty: "\\emptyset",
    Epsilon: "\\mathrm{E}",
    Eta: "\\mathrm{H}",
    exist: "\\exists",
    harr: "\\leftrightarrow",
    hArr: "\\Leftrightarrow",
    Harr: "\\Leftrightarrow",
    hearts: "\\heartsuit",
    image: "\\Im",
    infin: "\\infty",
    Iota: "\\mathrm{I}",
    isin: "\\in",
    Kappa: "\\mathrm{K}",
    larr: "\\leftarrow",
    lArr: "\\Leftarrow",
    Larr: "\\Leftarrow",
    lrarr: "\\leftrightarrow",
    lrArr: "\\Leftrightarrow",
    Lrarr: "\\Leftrightarrow",
    Mu: "\\mathrm{M}",
    natnums: "\\mathbb{N}",
    Nu: "\\mathrm{N}",
    Omicron: "\\mathrm{O}",
    plusmn: "\\pm",
    rarr: "\\rightarrow",
    rArr: "\\Rightarrow",
    Rarr: "\\Rightarrow",
    real: "\\Re",
    reals: "\\mathbb{R}",
    Reals: "\\mathbb{R}",
    Rho: "\\mathrm{P}",
    sdot: "\\cdot",
    sect: "\\S",
    spades: "\\spadesuit",
    sub: "\\subset",
    sube: "\\subseteq",
    supe: "\\supseteq",
    Tau: "\\mathrm{T}",
    thetasym: "\\vartheta",
    // TODO: varcoppa: { def: "\\\mbox{\\coppa}", expand: false },
    weierp: "\\wp",
    Zeta: "\\mathrm{Z}"
  };
  var AMSMATH_MACROS = {
    // amsmath.sty
    // http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf
    // Italic Greek capital letters.  AMS defines these with \DeclareMathSymbol,
    // but they are equivalent to \mathit{\Letter}.
    varGamma: "\\mathit{\\Gamma}",
    varDelta: "\\mathit{\\Delta}",
    varTheta: "\\mathit{\\Theta}",
    varLambda: "\\mathit{\\Lambda}",
    varXi: "\\mathit{\\Xi}",
    varPi: "\\mathit{\\Pi}",
    varSigma: "\\mathit{\\Sigma}",
    varUpsilon: "\\mathit{\\Upsilon}",
    varPhi: "\\mathit{\\Phi}",
    varPsi: "\\mathit{\\Psi}",
    varOmega: "\\mathit{\\Omega}",
    // From http://tug.ctan.org/macros/latex/required/amsmath/amsmath.dtx
    // > \newcommand{\pod}[1]{
    // >    \allowbreak
    // >    \if@display
    // >      \mkern18mu
    // >    \else
    // >      \mkern8mu
    // >    \fi
    // >    (#1)
    // > }
    // 18mu = \quad
    // > \renewcommand{\pmod}[1]{
    // >  \pod{{\operator@font mod}\mkern6mu#1}
    // > }
    pmod: {
      def: "\\quad(\\operatorname{mod}\\ #1)",
      args: 1,
      expand: false
    },
    // > \newcommand{\mod}[1]{
    // >    \allowbreak
    // >    \if@display
    // >      \mkern18mu
    // >    \else
    // >      \mkern12mu
    // >    \fi
    //>     {\operator@font mod}\,\,#1}
    mod: {
      def: "\\quad\\operatorname{mod}\\,\\,#1",
      args: 1,
      expand: false
    },
    // > \renewcommand{\bmod}{
    // >  \nonscript\mskip-\medmuskip\mkern5mu
    // >  \mathbin{\operator@font mod}
    // >  \penalty900 \mkern5mu
    // >  \nonscript\mskip-\medmuskip
    // > }
    // 5mu = \;
    bmod: {
      def: "\\;\\mathbin{\\operatorname{mod }}",
      expand: false
    }
  };
  var BRAKET_MACROS = {
    bra: "\\mathinner{\\langle{#1}|}",
    ket: "\\mathinner{|{#1}\\rangle}",
    braket: "\\mathinner{\\langle{#1}\\rangle}",
    set: "\\mathinner{\\lbrace #1 \\rbrace}",
    Bra: "\\left\\langle #1\\right|",
    Ket: "\\left|#1\\right\\rangle",
    Braket: "\\left\\langle{#1}\\right\\rangle",
    Set: "\\left\\lbrace #1 \\right\\rbrace"
  };
  var DEFAULT_MACROS = {
    "iff": "\\;\u27FA\\;",
    // >2,000 Note: additional spaces around the arrows
    "nicefrac": "^{#1}\\!\\!/\\!_{#2}",
    // Proof Wiki
    "rd": "\\mathrm{d}",
    "rD": "\\mathrm{D}",
    // From Wolfram Alpha
    "doubleStruckCapitalN": "\\mathbb{N}",
    "doubleStruckCapitalR": "\\mathbb{R}",
    "doubleStruckCapitalQ": "\\mathbb{Q}",
    "doubleStruckCapitalZ": "\\mathbb{Z}",
    "doubleStruckCapitalP": "\\mathbb{P}",
    "scriptCapitalE": "\\mathscr{E}",
    "scriptCapitalH": "\\mathscr{H}",
    "scriptCapitalL": "\\mathscr{L}",
    "gothicCapitalC": "\\mathfrak{C}",
    "gothicCapitalH": "\\mathfrak{H}",
    "gothicCapitalI": "\\mathfrak{I}",
    "gothicCapitalR": "\\mathfrak{R}",
    "imaginaryI": "\\mathrm{i}",
    // NOTE: set in main (upright) as per ISO 80000-2:2009.
    "imaginaryJ": "\\mathrm{j}",
    // NOTE: set in main (upright) as per ISO 80000-2:2009.
    "exponentialE": "\\mathrm{e}",
    // NOTE: set in main (upright) as per ISO 80000-2:2009.
    "differentialD": "\\mathrm{d}",
    // NOTE: set in main (upright) as per ISO 80000-2:2009.
    "capitalDifferentialD": "\\mathrm{D}",
    // NOTE: set in main (upright) as per ISO 80000-2:2009.
    "braket.sty": { package: BRAKET_MACROS },
    "amsmath.sty": {
      package: AMSMATH_MACROS,
      expand: false
    },
    "texvc.sty": {
      package: TEXVC_MACROS,
      expand: false
    }
  };
  var TEXT_SYMBOLS = {
    " ": 32,
    "\\#": 35,
    "\\&": 38,
    "\\$": 36,
    "\\%": 37,
    "\\_": 95,
    "\\euro": 8364,
    "\\maltese": 10016,
    "\\{": 123,
    "\\}": 125,
    "\\nobreakspace": 160,
    "\\ldots": 8230,
    "\\textellipsis": 8230,
    "\\backslash": 92,
    "`": 8216,
    "'": 8217,
    "``": 8220,
    "''": 8221,
    "\\degree": 176,
    "\\textasciicircum": 94,
    "\\textasciitilde": 126,
    "\\textasteriskcentered": 42,
    "\\textbackslash": 92,
    "\\textbraceleft": 123,
    "\\textbraceright": 125,
    "\\textbullet": 8226,
    "\\textdollar": 36,
    "\\textsterling": 163,
    "\\textdagger": 8224,
    "\\textdaggerdbl": 8225,
    "\u2013": 8211,
    // EN DASH
    "\u2014": 8212,
    // EM DASH
    "\u2018": 8216,
    // LEFT SINGLE QUOTATION MARK
    "\u2019": 8217,
    // RIGHT SINGLE QUOTATION MARK
    "\u201C": 8220,
    // LEFT DOUBLE QUOTATION MARK
    "\u201D": 8221,
    // RIGHT DOUBLE QUOTATION MARK
    '"': 8221,
    // DOUBLE PRIME
    "\\ss": 223,
    // LATIN SMALL LETTER SHARP S
    "\\ae": 230,
    // LATIN SMALL LETTER AE
    "\\oe": 339,
    // LATIN SMALL LIGATURE OE
    "\\AE": 198,
    // LATIN CAPITAL LETTER AE
    "\\OE": 338,
    // LATIN CAPITAL LIGATURE OE
    "\\O": 216,
    // LATIN CAPITAL LETTER O WITH STROKE
    "\\i": 305,
    // LATIN SMALL LETTER DOTLESS I
    "\\j": 567,
    // LATIN SMALL LETTER DOTLESS J
    "\\aa": 229,
    // LATIN SMALL LETTER A WITH RING ABOVE
    "\\AA": 197
    // LATIN CAPITAL LETTER A WITH RING ABOVE
  };
  var COMMAND_MODE_CHARACTERS = /[\w!@*()-=+{}[\]\\';:?/.,~<>`|$%#&^" ]/;
  var LETTER = supportRegexPropertyEscape() ? (
    /* eslint-disable-next-line prefer-regex-literals */
    new RegExp("\\p{Letter}", "u")
  ) : /[a-zA-Z]/;
  var LETTER_AND_DIGITS = supportRegexPropertyEscape() ? (
    /* eslint-disable-next-line prefer-regex-literals */
    new RegExp("[0-9\\p{Letter}]", "u")
  ) : /[\da-zA-Z]/;
  function newSymbol(symbol, value, type = "mord", variant) {
    if (value === void 0)
      return;
    MATH_SYMBOLS[symbol] = {
      definitionType: "symbol",
      type,
      variant,
      codepoint: value
    };
    if (!REVERSE_MATH_SYMBOLS[value])
      REVERSE_MATH_SYMBOLS[value] = symbol;
    if (!TEXT_SYMBOLS[symbol])
      TEXT_SYMBOLS[symbol] = value;
  }
  function newSymbols(value, inType, inVariant) {
    if (typeof value === "string") {
      for (let i = 0; i < value.length; i++) {
        const ch = value.charAt(i);
        newSymbol(ch, ch.codePointAt(0));
      }
      return;
    }
    for (const [symbol, val, type, variant] of value)
      newSymbol(symbol, val, type != null ? type : inType, variant != null ? variant : inVariant);
  }
  function newSymbolRange(from, to) {
    for (let i = from; i <= to; i++)
      newSymbol(String.fromCodePoint(i), i);
  }
  function getEnvironmentDefinition(name) {
    var _a3;
    return (_a3 = ENVIRONMENTS[name]) != null ? _a3 : null;
  }
  function suggest(mf, s) {
    var _a3, _b3;
    if (s.length === 0 || s === "\\" || !s.startsWith("\\"))
      return [];
    const result = [];
    for (const p in LATEX_COMMANDS) {
      if (p.startsWith(s) && !LATEX_COMMANDS[p].infix)
        result.push({ match: p, frequency: (_a3 = LATEX_COMMANDS[p].frequency) != null ? _a3 : 0 });
    }
    for (const p in MATH_SYMBOLS) {
      if (p.startsWith(s))
        result.push({ match: p, frequency: (_b3 = MATH_SYMBOLS[p].frequency) != null ? _b3 : 0 });
    }
    const command = s.substring(1);
    for (const p of Object.keys(mf.options.macros))
      if (p.startsWith(command))
        result.push({ match: "\\" + p, frequency: 0 });
    result.sort((a, b) => {
      var _a4, _b4;
      if (a.frequency === b.frequency) {
        if (a.match.length === b.match.length)
          return a.match < b.match ? -1 : 1;
        return a.match.length - b.match.length;
      }
      return ((_a4 = b.frequency) != null ? _a4 : 0) - ((_b4 = a.frequency) != null ? _b4 : 0);
    });
    return result.map((x) => x.match);
  }
  function parseParameterTemplateArgument(argTemplate) {
    let type = "auto";
    const r = argTemplate.match(/:([^=]+)/);
    if (r)
      type = r[1].trim();
    return type;
  }
  function parseParameterTemplate(parameterTemplate) {
    if (!parameterTemplate)
      return [];
    const result = [];
    let parameters = parameterTemplate.split("]");
    if (parameters[0].startsWith("[")) {
      result.push({
        isOptional: true,
        type: parseParameterTemplateArgument(parameters[0].slice(1))
      });
      for (let i = 1; i <= parameters.length; i++)
        result.push(...parseParameterTemplate(parameters[i]));
    } else {
      parameters = parameterTemplate.split("}");
      if (parameters[0].startsWith("{")) {
        result.push({
          isOptional: false,
          type: parseParameterTemplateArgument(parameters[0].slice(1))
        });
        for (let i = 1; i <= parameters.length; i++)
          result.push(...parseParameterTemplate(parameters[i]));
      }
    }
    return result;
  }
  function parseArgAsString(atoms) {
    if (!atoms)
      return "";
    let result = "";
    let success = true;
    for (const atom of atoms) {
      if (typeof atom.value === "string")
        result += atom.value;
      else
        success = false;
    }
    return success ? result : "";
  }
  function defineEnvironment(names, parameters, createAtom, isTabular = false) {
    if (typeof names === "string")
      names = [names];
    const parsedParameters = parseParameterTemplate(parameters);
    const data = {
      tabular: isTabular,
      // Params: the parameters for this function, an array of
      // {optional, type}
      params: parsedParameters,
      // Handler to create an atom
      createAtom
    };
    for (const name of names)
      ENVIRONMENTS[name] = data;
  }
  function defineTabularEnvironment(names, parameters, createAtom) {
    defineEnvironment(names, parameters, createAtom, true);
  }
  function defineFunction(names, parameters, options) {
    var _a3, _b3;
    if (!options)
      options = {};
    const data = {
      definitionType: "function",
      // The parameters for this function, an array of
      // {optional, type}
      params: parseParameterTemplate(parameters),
      ifMode: options.ifMode,
      isFunction: (_a3 = options.isFunction) != null ? _a3 : false,
      applyMode: options.applyMode,
      infix: (_b3 = options.infix) != null ? _b3 : false,
      createAtom: options.createAtom,
      applyStyle: options.applyStyle
    };
    if (typeof names === "string")
      LATEX_COMMANDS["\\" + names] = data;
    else
      for (const name of names)
        LATEX_COMMANDS["\\" + name] = data;
  }
  var _DEFAULT_MACROS;
  function getMacros(otherMacros) {
    if (!_DEFAULT_MACROS)
      _DEFAULT_MACROS = normalizeMacroDictionary(DEFAULT_MACROS);
    if (!otherMacros)
      return _DEFAULT_MACROS;
    return normalizeMacroDictionary(__spreadValues(__spreadValues({}, _DEFAULT_MACROS), otherMacros));
  }
  function normalizeMacroDefinition(def, options) {
    var _a3, _b3, _c2, _d2;
    if (typeof def === "string") {
      let argCount = 0;
      const defString = def;
      if (/(^|[^\\])#1/.test(defString))
        argCount = 1;
      if (/(^|[^\\])#2/.test(defString))
        argCount = 2;
      if (/(^|[^\\])#3/.test(defString))
        argCount = 3;
      if (/(^|[^\\])#4/.test(defString))
        argCount = 4;
      if (/(^|[^\\])#5/.test(defString))
        argCount = 5;
      if (/(^|[^\\])#6/.test(defString))
        argCount = 6;
      if (/(^|[^\\])#7/.test(defString))
        argCount = 7;
      if (/(^|[^\\])#8/.test(defString))
        argCount = 8;
      if (/(^|[^\\])#9/.test(defString))
        argCount = 9;
      return {
        expand: (_a3 = options == null ? void 0 : options.expand) != null ? _a3 : true,
        captureSelection: (_b3 = options == null ? void 0 : options.captureSelection) != null ? _b3 : true,
        args: argCount,
        def: defString
      };
    }
    return __spreadValues({
      expand: (_c2 = options == null ? void 0 : options.expand) != null ? _c2 : true,
      captureSelection: (_d2 = options == null ? void 0 : options.captureSelection) != null ? _d2 : true,
      args: 0
    }, def);
  }
  function normalizeMacroDictionary(macros) {
    if (!macros)
      return {};
    const result = {};
    for (const macro of Object.keys(macros)) {
      const macroDef = macros[macro];
      if (macroDef === void 0 || macroDef === null)
        delete result[macro];
      else if (typeof macroDef === "object" && "package" in macroDef) {
        for (const packageMacro of Object.keys(macroDef.package)) {
          result[packageMacro] = normalizeMacroDefinition(
            macroDef.package[packageMacro],
            {
              expand: macroDef.expand,
              captureSelection: macroDef.captureSelection
            }
          );
        }
      } else
        result[macro] = normalizeMacroDefinition(macroDef);
    }
    return result;
  }
  function binRelType(atoms) {
    if (atoms.length === 1) {
      const atom = atoms[0];
      if (atom.type === "mbin")
        return "mbin";
      if (atom.type === "mrel")
        return "mrel";
    }
    return "mord";
  }
  function defaultGetDefinition(token, parseMode = "math") {
    if (!token || token.length === 0)
      return null;
    let info = null;
    if (token.startsWith("\\")) {
      info = LATEX_COMMANDS[token];
      if (info)
        return info;
      if (parseMode === "math")
        info = MATH_SYMBOLS[token];
      else if (TEXT_SYMBOLS[token]) {
        info = {
          definitionType: "symbol",
          type: "mord",
          codepoint: TEXT_SYMBOLS[token]
        };
      }
    } else if (parseMode === "math") {
      info = MATH_SYMBOLS[token];
      if (!info && token.length === 1) {
        const command = charToLatex("math", token.codePointAt(0));
        if (command.startsWith("\\"))
          return __spreadProps(__spreadValues({}, defaultGetDefinition(command, "math")), { command });
        return null;
      }
    } else if (TEXT_SYMBOLS[token]) {
      info = {
        definitionType: "symbol",
        type: "mord",
        codepoint: TEXT_SYMBOLS[token]
      };
    } else if (parseMode === "text") {
      info = {
        definitionType: "symbol",
        type: "mord",
        codepoint: token.codePointAt(0)
      };
    }
    if (info && info.definitionType === "symbol" && info.type === "mord" && (info.codepoint === 102 || info.codepoint === 103 || info.codepoint === 104))
      info.isFunction = true;
    return info != null ? info : null;
  }
  function getMacroDefinition(token, macros) {
    if (!token.startsWith("\\"))
      return null;
    const command = token.slice(1);
    return macros[command];
  }
  function unicodeCharToLatex(parseMode, char) {
    var _a3;
    if (parseMode === "text")
      return (_a3 = charToLatex(parseMode, char.codePointAt(0))) != null ? _a3 : char;
    let result;
    result = charToLatex(parseMode, char.codePointAt(0));
    if (result)
      return result;
    const cp = char.codePointAt(0);
    const v = unicodeToMathVariant(cp);
    if (!v.style && !v.variant)
      return "";
    result = v.char;
    if (v.variant)
      result = "\\" + v.variant + "{" + result + "}";
    if (v.style === "bold")
      result = "\\mathbf{" + result + "}";
    else if (v.style === "italic")
      result = "\\mathit{" + result + "}";
    else if (v.style === "bolditalic")
      result = "\\mathbfit{" + result + "}";
    return "\\mathord{" + result + "}";
  }
  function charToLatex(parseMode, codepoint) {
    if (codepoint === void 0)
      return "";
    if (parseMode === "math" && REVERSE_MATH_SYMBOLS[codepoint])
      return REVERSE_MATH_SYMBOLS[codepoint];
    if (parseMode === "text") {
      let textSymbol = Object.keys(TEXT_SYMBOLS).find(
        (x) => TEXT_SYMBOLS[x] === codepoint
      );
      if (!textSymbol) {
        const hex = codepoint.toString(16);
        textSymbol = "^".repeat(hex.length) + hex;
      }
      return textSymbol;
    }
    return String.fromCodePoint(codepoint);
  }

  // src/core/mathstyle.ts
  var D = 7;
  var Dc = 6;
  var T = 5;
  var Tc = 4;
  var S = 3;
  var Sc = 2;
  var SS = 1;
  var SSc = 0;
  var Mathstyle = class {
    constructor(id, sizeDelta, cramped) {
      this.id = id;
      this.sizeDelta = sizeDelta;
      this.cramped = cramped;
      const metricsIndex = { "-4": 2, "-3": 1, 0: 0 }[sizeDelta];
      this.metrics = Object.keys(FONT_METRICS).reduce((acc, x) => {
        return __spreadProps(__spreadValues({}, acc), { [x]: FONT_METRICS[x][metricsIndex] });
      }, {});
    }
    getFontSize(size) {
      return Math.max(1, size + this.sizeDelta);
    }
    /**
     * Get the style of a superscript given a base in the current style.
     */
    get sup() {
      return MATHSTYLES[[SSc, SS, SSc, SS, Sc, S, Sc, S][this.id]];
    }
    /**
     * Get the style of a subscript given a base in the current style.
     */
    get sub() {
      return MATHSTYLES[[SSc, SSc, SSc, SSc, Sc, Sc, Sc, Sc][this.id]];
    }
    /**
     * Get the style of a fraction numerator given the fraction in the current
     * style.
     * See TeXBook p 141.
     */
    get fracNum() {
      return MATHSTYLES[[SSc, SS, SSc, SS, Sc, S, Tc, T][this.id]];
    }
    /**
     * Get the style of a fraction denominator given the fraction in the current
     * style.
     * See TeXBook p 141.
     */
    get fracDen() {
      return MATHSTYLES[[SSc, SSc, SSc, SSc, Sc, Sc, Tc, Tc][this.id]];
    }
    /**
     * Get the cramped version of a style (in particular, cramping a cramped style
     * doesn't change the style).
     */
    get cramp() {
      return MATHSTYLES[[SSc, SSc, Sc, Sc, Tc, Tc, Dc, Dc][this.id]];
    }
    /**
     * Return if this style is tightly spaced (scriptstyle/scriptscriptstyle)
     */
    get isTight() {
      return this.sizeDelta < 0;
    }
  };
  var MATHSTYLES = {
    7: new Mathstyle(D, 0, false),
    6: new Mathstyle(Dc, 0, true),
    5: new Mathstyle(T, 0, false),
    4: new Mathstyle(Tc, 0, true),
    3: new Mathstyle(S, -3, false),
    2: new Mathstyle(Sc, -3, true),
    1: new Mathstyle(SS, -4, false),
    0: new Mathstyle(SSc, -4, true)
  };
  MATHSTYLES.displaystyle = MATHSTYLES[D];
  MATHSTYLES.textstyle = MATHSTYLES[T];
  MATHSTYLES.scriptstyle = MATHSTYLES[S];
  MATHSTYLES.scriptscriptstyle = MATHSTYLES[SS];

  // src/core/registers-utils.ts
  function convertDimensionToPt(value, precision) {
    var _a3;
    if (!value)
      return 0;
    const f = {
      pt: 1,
      mm: 7227 / 2540,
      cm: 7227 / 254,
      ex: 35271 / 8192,
      px: 3 / 4,
      em: PT_PER_EM,
      bp: 803 / 800,
      dd: 1238 / 1157,
      pc: 12,
      in: 72.27,
      mu: 10 / 18
    }[(_a3 = value.unit) != null ? _a3 : "pt"];
    if (Number.isFinite(precision)) {
      const factor = 10 ** precision;
      return Math.round(value.dimension / PT_PER_EM * f * factor) / factor;
    }
    return value.dimension * f;
  }
  function convertDimensionToEm(value, precision) {
    if (value === null)
      return 0;
    return convertDimensionToPt(value, precision) / PT_PER_EM;
  }
  function convertGlueToEm(value) {
    return convertDimensionToEm(value.glue);
  }
  function serializeDimension(value) {
    var _a3;
    return `${value.dimension}${(_a3 = value.unit) != null ? _a3 : "pt"}`;
  }

  // src/core/context.ts
  var Context = class {
    constructor(parent, style, inMathstyle) {
      var _a3, _b3, _c2, _d2, _e, _f;
      console.assert(parent instanceof Context || (style == null ? void 0 : style.fontSize) !== void 0);
      console.assert(parent instanceof Context || inMathstyle !== void 0);
      if (parent instanceof Context)
        this.parent = parent;
      if (!(parent instanceof Context))
        this.registers = (_a3 = parent.registers) != null ? _a3 : {};
      this.isPhantom = (_d2 = (_c2 = style == null ? void 0 : style.isPhantom) != null ? _c2 : (_b3 = this.parent) == null ? void 0 : _b3.isPhantom) != null ? _d2 : false;
      const from = __spreadValues({}, parent);
      if (style) {
        if (style.letterShapeStyle && style.letterShapeStyle !== "auto")
          from.letterShapeStyle = style.letterShapeStyle;
        if (style.color && style.color !== "none")
          from.color = style.color;
        if (style.backgroundColor && style.backgroundColor !== "none")
          from.backgroundColor = style.backgroundColor;
        if (style.fontSize && style.fontSize !== "auto" && style.fontSize !== ((_e = this.parent) == null ? void 0 : _e._size))
          this._size = style.fontSize;
      }
      this.letterShapeStyle = (_f = from.letterShapeStyle) != null ? _f : "tex";
      this.color = from.color;
      this.backgroundColor = from.backgroundColor;
      let mathstyle;
      if (typeof inMathstyle === "string") {
        if (parent instanceof Context) {
          switch (inMathstyle) {
            case "cramp":
              mathstyle = parent.mathstyle.cramp;
              break;
            case "superscript":
              mathstyle = parent.mathstyle.sup;
              break;
            case "subscript":
              mathstyle = parent.mathstyle.sub;
              break;
            case "numerator":
              mathstyle = parent.mathstyle.fracNum;
              break;
            case "denominator":
              mathstyle = parent.mathstyle.fracDen;
              break;
          }
        }
        switch (inMathstyle) {
          case "textstyle":
            mathstyle = MATHSTYLES.textstyle;
            break;
          case "displaystyle":
            mathstyle = MATHSTYLES.displaystyle;
            break;
          case "scriptstyle":
            mathstyle = MATHSTYLES.scriptstyle;
            break;
          case "scriptscriptstyle":
            mathstyle = MATHSTYLES.scriptscriptstyle;
            break;
          case "":
          case "auto":
            break;
        }
      }
      this._mathstyle = mathstyle;
      this.atomIdsSettings = parent.atomIdsSettings;
      this.renderPlaceholder = from.renderPlaceholder;
      console.assert(
        !(parent instanceof Context) || this.atomIdsSettings === parent.atomIdsSettings
      );
    }
    get mathstyle() {
      let result = this._mathstyle;
      let parent = this.parent;
      while (!result) {
        result = parent._mathstyle;
        parent = parent.parent;
      }
      return result;
    }
    getRegister(name) {
      var _a3;
      if ((_a3 = this.registers) == null ? void 0 : _a3[name])
        return this.registers[name];
      if (this.parent)
        return this.parent.getRegister(name);
      return void 0;
    }
    getRegisterAsGlue(name) {
      var _a3;
      if ((_a3 = this.registers) == null ? void 0 : _a3[name]) {
        const value = this.registers[name];
        if (typeof value === "object" && "glue" in value)
          return value;
        else if (typeof value === "object" && "dimension" in value)
          return { glue: { dimension: value.dimension } };
        else if (typeof value === "number")
          return { glue: { dimension: value } };
        return void 0;
      }
      if (this.parent)
        return this.parent.getRegisterAsGlue(name);
      return void 0;
    }
    getRegisterAsEm(name) {
      return convertDimensionToEm(this.getRegisterAsDimension(name));
    }
    getRegisterAsDimension(name) {
      var _a3;
      if ((_a3 = this.registers) == null ? void 0 : _a3[name]) {
        const value = this.registers[name];
        if (typeof value === "object" && "glue" in value)
          return value.glue;
        else if (typeof value === "object" && "dimension" in value)
          return value;
        else if (typeof value === "number")
          return { dimension: value };
        return void 0;
      }
      if (this.parent)
        return this.parent.getRegisterAsDimension(name);
      return void 0;
    }
    setRegister(name, value) {
      if (value === void 0) {
        delete this.registers[name];
        return;
      }
      this.registers[name] = value;
    }
    setGlobalRegister(name, value) {
      let root = this;
      while (root.parent) {
        root.setRegister(name, void 0);
        root = root.parent;
      }
      root.setRegister(name, value);
    }
    get size() {
      let result = this._size;
      let parent = this.parent;
      while (!result) {
        result = parent._size;
        parent = parent.parent;
      }
      return result;
    }
    makeID() {
      if (!this.atomIdsSettings)
        return void 0;
      if (this.atomIdsSettings.overrideID)
        return this.atomIdsSettings.overrideID;
      if (typeof this.atomIdsSettings.seed !== "number") {
        return Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
      }
      const result = this.atomIdsSettings.seed.toString(36);
      this.atomIdsSettings.seed += 1;
      return result;
    }
    // Scale a value, in em, to account for the fontsize and mathstyle
    // of this context
    scale(value) {
      return value * this.effectiveFontSize;
    }
    get scalingFactor() {
      if (!this.parent)
        return 1;
      return this.effectiveFontSize / this.parent.effectiveFontSize;
    }
    get isDisplayStyle() {
      return this.mathstyle.id === D || this.mathstyle.id === Dc;
    }
    get isCramped() {
      return this.mathstyle.cramped;
    }
    get isTight() {
      return this.mathstyle.isTight;
    }
    // Return the font size, in em relative to the mathfield fontsize,
    // accounting both for the base font size and the mathstyle
    get effectiveFontSize() {
      return FONT_SCALE[Math.max(1, this.size + this.mathstyle.sizeDelta)];
    }
    get computedColor() {
      let result = this.color;
      let parent = this.parent;
      if (!result && parent) {
        result = parent.color;
        parent = parent.parent;
      }
      return result != null ? result : "";
    }
    get computedBackgroundColor() {
      let result = this.backgroundColor;
      let parent = this.parent;
      if (!result && parent) {
        result = parent.backgroundColor;
        parent = parent.parent;
      }
      return result != null ? result : "";
    }
    get metrics() {
      return this.mathstyle.metrics;
    }
  };

  // src/core/atom-class.ts
  var gCustomSerializer = {};
  var NAMED_BRANCHES = [
    "above",
    "body",
    "below",
    "superscript",
    "subscript"
  ];
  function isNamedBranch(branch) {
    return typeof branch === "string" && NAMED_BRANCHES.includes(branch);
  }
  function isCellBranch(branch) {
    return branch !== void 0 && Array.isArray(branch) && branch.length === 2;
  }
  var Atom = class {
    constructor(type, context, options) {
      // If no branches
      // Used to match a DOM element to an Atom
      // (the corresponding DOM element has a `data-atom-id` attribute)
      this.id = void 0;
      // Verbatim LaTeX of the command and its arguments
      // Note that the empty string is a valid verbatim LaTeX , so it's important
      // to distinguish between `verbatimLatex === undefined` and `typeof verbatimLatex === 'string'`
      this.verbatimLatex = void 0;
      // If true, some structural changes have been made to the atom
      // (insertion or removal of children) or one of its children is dirty
      /** @internal */
      this._isDirty = false;
      // A monotonically increasing counter to detect structural changes
      /** @internal */
      this._changeCounter = 0;
      // How to display "limits" (i.e. superscript/subscript) for example
      // with `\sum`:
      // - 'over-under': directly above and below the symbol
      // - 'adjacent': to the right, above and below the baseline (for example
      // for operators in `textstyle` style)
      // - 'auto': 'over-under' in \displaystyle, 'adjacent' otherwise
      // If `undefined`, the subsup should be placed on a separate `msubsup` atom.
      this.subsupPlacement = void 0;
      // True if the subsupPlacement was set by `\limits`, `\nolimits` or
      // `\displaylimits`.
      // Necessary so the proper LaTeX can be output.
      this.explicitSubsupPlacement = false;
      // If true, when the caret reaches the first position in this element's body,
      // (moving right to left) it automatically moves to the outside of the
      // element.
      // Conversely, when the caret reaches the last position inside
      // this element, (moving left to right) it automatically moves to the one
      // outside the element.
      this.skipBoundary = false;
      // If true, the children of this atom cannot be selected and should be handled
      // as a unit. Used by the `\enclose` annotations, for example.
      this.captureSelection = false;
      var _a3, _b3, _c2, _d2, _e, _f;
      this.type = type;
      this.context = context;
      if (typeof (options == null ? void 0 : options.value) === "string")
        this.value = options.value;
      this.command = (_b3 = (_a3 = options == null ? void 0 : options.command) != null ? _a3 : this.value) != null ? _b3 : "";
      this.mode = (_c2 = options == null ? void 0 : options.mode) != null ? _c2 : "math";
      this.isFunction = (_d2 = options == null ? void 0 : options.isFunction) != null ? _d2 : false;
      this.subsupPlacement = options == null ? void 0 : options.limits;
      this.style = (_e = options == null ? void 0 : options.style) != null ? _e : {};
      this.displayContainsHighlight = (_f = options == null ? void 0 : options.displayContainsHighlight) != null ? _f : false;
      if (options == null ? void 0 : options.serialize) {
        console.assert(typeof options.command === "string");
        gCustomSerializer[options.command] = options.serialize;
      }
    }
    /**
     * Return a list of boxes equivalent to atoms.
     *
     * While an atom represent an abstract element (for example 'genfrac'),
     * a box corresponds to something to draw on screen (a character, a line,
     * etc...).
     *
     * @param parentContext Font family, variant, size, color, and other info useful
     * to render an expression
     * @param options.newList - If true, for the purpose of calculating spacing
     * between atoms, this list of atoms should be considered a new atom list,
     * in the sense of TeX atom lists (i.e. don't consider preceding atoms
     * to calculate spacing)
     */
    static createBox(parentContext, atoms, options) {
      var _a3, _b3, _c2;
      if (!atoms)
        return null;
      const runs = getStyleRuns(atoms);
      if (runs.length === 1) {
        const run = runs[0];
        if (run[0].style) {
          return renderStyleRun(parentContext, run, __spreadProps(__spreadValues({}, options), {
            style: {
              color: run[0].style.color,
              backgroundColor: run[0].style.backgroundColor,
              fontSize: run[0].style.fontSize
            }
          }));
        }
        return renderStyleRun(parentContext, run, options);
      }
      const boxes = [];
      let newList = options == null ? void 0 : options.newList;
      for (const run of runs) {
        const context = new Context(parentContext, {
          color: (_a3 = run[0].style) == null ? void 0 : _a3.color,
          backgroundColor: (_b3 = run[0].style) == null ? void 0 : _b3.backgroundColor,
          fontSize: (_c2 = run[0].style) == null ? void 0 : _c2.fontSize
        });
        const box = renderStyleRun(context, run, { newList });
        if (box) {
          newList = false;
          boxes.push(box);
        }
      }
      if (boxes.length === 0)
        return null;
      if (boxes.length === 1 && !(options == null ? void 0 : options.classes) && !(options == null ? void 0 : options.type))
        return boxes[0].wrap(parentContext);
      return new Box(boxes, {
        classes: options == null ? void 0 : options.classes,
        type: options == null ? void 0 : options.type,
        newList: options == null ? void 0 : options.newList
      }).wrap(parentContext);
    }
    /**
     * Given an atom or an array of atoms, return a LaTeX string representation
     */
    static serialize(value, options) {
      if (isArray(value))
        return serializeAtoms(value, options);
      if (typeof value === "number" || typeof value === "boolean")
        return value.toString();
      if (typeof value === "string")
        return value.replace(/\s/g, "~");
      if (value === void 0)
        return "";
      if (!options.expandMacro && typeof value.verbatimLatex === "string")
        return value.verbatimLatex;
      if (value.command && gCustomSerializer[value.command])
        return gCustomSerializer[value.command](value, options);
      return value.serialize(options);
    }
    /**
     * The common ancestor between two atoms
     */
    static commonAncestor(a, b) {
      if (a === b)
        return a.parent;
      if (a.parent === b.parent)
        return a.parent;
      const parents = /* @__PURE__ */ new WeakSet();
      let { parent } = a;
      while (parent) {
        parents.add(parent);
        parent = parent.parent;
      }
      parent = b.parent;
      while (parent) {
        if (parents.has(parent))
          return parent;
        parent = parent.parent;
      }
      console.assert(Boolean(parent));
      return void 0;
    }
    static fromJson(json, context) {
      const result = new Atom(json.type, context, json);
      for (const branch of NAMED_BRANCHES)
        if (json[branch])
          result.setChildren(json[branch], branch);
      return result;
    }
    toJson() {
      const result = { type: this.type };
      if (this.mode !== "math")
        result.mode = this.mode;
      if (this.command && this.command !== this.value)
        result.command = this.command;
      if (this.value !== void 0)
        result.value = this.value;
      if (this.style && Object.keys(this.style).length > 0)
        result.style = __spreadValues({}, this.style);
      if (this.verbatimLatex !== void 0)
        result.verbatimLatex = this.verbatimLatex;
      if (this.subsupPlacement)
        result.subsupPlacement = this.subsupPlacement;
      if (this.explicitSubsupPlacement)
        result.explicitSubsupPlacement = true;
      if (this.isFunction)
        result.isFunction = true;
      if (this.displayContainsHighlight)
        result.displayContainsHighlight = true;
      if (this.isExtensibleSymbol)
        result.isExtensibleSymbol = true;
      if (this.skipBoundary)
        result.skipBoundary = true;
      if (this.captureSelection)
        result.captureSelection = true;
      if (this._branches) {
        for (const branch of Object.keys(this._branches)) {
          if (this._branches[branch]) {
            result[branch] = this._branches[branch].filter((x) => x.type !== "first").map((x) => x.toJson());
          }
        }
      }
      return result;
    }
    get changeCounter() {
      return this._changeCounter;
    }
    get isDirty() {
      return this._isDirty;
    }
    set isDirty(dirty) {
      this._isDirty = dirty;
      if (dirty) {
        this._changeCounter++;
        this.verbatimLatex = void 0;
        this._children = void 0;
        let { parent } = this;
        while (parent) {
          parent._isDirty = true;
          parent._changeCounter++;
          parent.verbatimLatex = void 0;
          parent._children = void 0;
          parent = parent.parent;
        }
      }
    }
    /**
     * Serialize the atom  to LaTeX
     */
    serialize(options) {
      var _a3;
      if (this.body && this.command) {
        return joinLatex([
          this.command,
          "{",
          this.bodyToLatex(options),
          "}",
          this.supsubToLatex(options)
        ]);
      }
      if (this.body) {
        return joinLatex([
          this.bodyToLatex(options),
          this.supsubToLatex(options)
        ]);
      }
      if (this.value && this.value !== "\u200B") {
        return (_a3 = this.command) != null ? _a3 : unicodeCharToLatex(this.mode, this.value);
      }
      return "";
    }
    bodyToLatex(options) {
      return serializeAtoms(this.body, options);
    }
    aboveToLatex(options) {
      return serializeAtoms(this.above, options);
    }
    belowToLatex(options) {
      return serializeAtoms(this.below, options);
    }
    supsubToLatex(options) {
      let result = "";
      if (this.branch("subscript") !== void 0) {
        const sub = serializeAtoms(this.subscript, options);
        if (sub.length === 0)
          result += "_{}";
        else if (sub.length === 1)
          result += "_" + sub;
        else
          result += `_{${sub}}`;
      }
      if (this.branch("superscript") !== void 0) {
        const sup = serializeAtoms(this.superscript, options);
        if (sup.length === 0)
          result += "^{}";
        else if (sup.length === 1) {
          if (sup === "\u2032")
            result += "^\\prime ";
          else if (sup === "\u2033")
            result += "^\\doubleprime ";
          else
            result += "^" + sup;
        } else
          result += `^{${sup}}`;
      }
      return result;
    }
    get treeDepth() {
      let result = 1;
      let atom = this.parent;
      while (atom) {
        atom = atom.parent;
        result += 1;
      }
      return result;
    }
    get inCaptureSelection() {
      let atom = this;
      while (atom) {
        if (atom.captureSelection)
          return true;
        atom = atom.parent;
      }
      return false;
    }
    /** Return the parent editable prompt, if it exists */
    get parentPrompt() {
      let atom = this;
      while (atom) {
        if (atom.type === "prompt" && !atom.captureSelection)
          return atom;
        atom = atom.parent;
      }
      return null;
    }
    /**
     * Return the atoms in the branch, if it exists, otherwise null
     */
    branch(name) {
      if (!isNamedBranch(name))
        return void 0;
      if (!this._branches)
        return void 0;
      return this._branches[name];
    }
    /**
     * Return all the branches that exist.
     * Some of them may be empty.
     */
    get branches() {
      if (!this._branches)
        return [];
      const result = [];
      for (const branch of NAMED_BRANCHES)
        if (this._branches[branch])
          result.push(branch);
      return result;
    }
    /**
     * Return the atoms in the branch, if it exists, otherwise create it
     */
    createBranch(name) {
      console.assert(isNamedBranch(name));
      if (!isNamedBranch(name))
        return [];
      if (!this._branches) {
        this._branches = {
          [name]: [this.makeFirstAtom(name)]
        };
      } else if (!this._branches[name])
        this._branches[name] = [this.makeFirstAtom(name)];
      this.isDirty = true;
      return this._branches[name];
    }
    get row() {
      if (!isCellBranch(this.treeBranch))
        return -1;
      return this.treeBranch[0];
    }
    get col() {
      if (!isCellBranch(this.treeBranch))
        return -1;
      return this.treeBranch[1];
    }
    get body() {
      var _a3;
      return (_a3 = this._branches) == null ? void 0 : _a3.body;
    }
    set body(atoms) {
      this.setChildren(atoms, "body");
    }
    get superscript() {
      var _a3;
      return (_a3 = this._branches) == null ? void 0 : _a3.superscript;
    }
    set superscript(atoms) {
      this.setChildren(atoms, "superscript");
    }
    get subscript() {
      var _a3;
      return (_a3 = this._branches) == null ? void 0 : _a3.subscript;
    }
    set subscript(atoms) {
      this.setChildren(atoms, "subscript");
    }
    get above() {
      var _a3;
      return (_a3 = this._branches) == null ? void 0 : _a3.above;
    }
    set above(atoms) {
      this.setChildren(atoms, "above");
    }
    get below() {
      var _a3;
      return (_a3 = this._branches) == null ? void 0 : _a3.below;
    }
    set below(atoms) {
      this.setChildren(atoms, "below");
    }
    get computedStyle() {
      var _a3;
      if (!this.parent)
        return __spreadValues({}, (_a3 = this.style) != null ? _a3 : {});
      const hadVerbatimColor = this.style.verbatimColor !== void 0;
      const hadVerbatimBackgroundColor = this.style.verbatimBackgroundColor !== void 0;
      const result = __spreadValues(__spreadValues({}, this.parent.computedStyle), this.style);
      delete result.variant;
      delete result.variantStyle;
      if (!hadVerbatimBackgroundColor)
        delete result.verbatimBackgroundColor;
      if (!hadVerbatimColor)
        delete result.verbatimColor;
      return result;
    }
    applyStyle(style) {
      this.isDirty = true;
      this.style = __spreadValues(__spreadValues({}, this.style), style);
      if (this.style.fontFamily === "none")
        delete this.style.fontFamily;
      if (this.style.fontShape === "auto")
        delete this.style.fontShape;
      if (this.style.fontSeries === "auto")
        delete this.style.fontSeries;
      if (this.style.color === "none") {
        delete this.style.color;
        delete this.style.verbatimColor;
      }
      if (this.style.backgroundColor === "none") {
        delete this.style.backgroundColor;
        delete this.style.verbatimBackgroundColor;
      }
      if (this.style.fontSize === "auto")
        delete this.style.fontSize;
      for (const child of this.children)
        child.applyStyle(style);
    }
    getInitialBaseElement() {
      var _a3;
      let result = void 0;
      if (!this.hasEmptyBranch("body")) {
        console.assert(((_a3 = this.body) == null ? void 0 : _a3[0].type) === "first");
        result = this.body[1].getInitialBaseElement();
      }
      return result != null ? result : this;
    }
    getFinalBaseElement() {
      if (!this.hasEmptyBranch("body"))
        return this.body[this.body.length - 1].getFinalBaseElement();
      return this;
    }
    isCharacterBox() {
      if (this.type === "leftright")
        return false;
      const base = this.getInitialBaseElement();
      return /mord/.test(base.type);
    }
    hasEmptyBranch(branch) {
      const atoms = this.branch(branch);
      if (!atoms)
        return true;
      console.assert(atoms.length > 0);
      console.assert(atoms[0].type === "first");
      return atoms.length === 1;
    }
    /*
     * Setting `null` does nothing
     * Setting `[]` adds an empty list (the branch is created)
     * The children should *not* start with a `"first"` atom:
     * the `first` atom will be added if necessary
     */
    setChildren(children, branch) {
      var _a3;
      if (!children)
        return;
      console.assert(isNamedBranch(branch));
      if (!isNamedBranch(branch))
        return;
      console.assert(((_a3 = children[0]) == null ? void 0 : _a3.type) !== "first");
      const newBranch = [this.makeFirstAtom(branch), ...children];
      if (this._branches)
        this._branches[branch] = newBranch;
      else
        this._branches = { [branch]: newBranch };
      for (const child of children) {
        child.parent = this;
        child.treeBranch = branch;
      }
      this.isDirty = true;
    }
    makeFirstAtom(branch) {
      const result = new Atom("first", this.context, { mode: this.mode });
      result.parent = this;
      result.treeBranch = branch;
      return result;
    }
    addChild(child, branch) {
      console.assert(child.type !== "first");
      this.createBranch(branch).push(child);
      this.isDirty = true;
      child.parent = this;
      child.treeBranch = branch;
    }
    addChildBefore(child, before) {
      console.assert(before.treeBranch !== void 0);
      const branch = this.createBranch(before.treeBranch);
      branch.splice(branch.indexOf(before), 0, child);
      this.isDirty = true;
      child.parent = this;
      child.treeBranch = before.treeBranch;
    }
    addChildAfter(child, after) {
      console.assert(after.treeBranch !== void 0);
      const branch = this.createBranch(after.treeBranch);
      branch.splice(branch.indexOf(after) + 1, 0, child);
      this.isDirty = true;
      child.parent = this;
      child.treeBranch = after.treeBranch;
    }
    addChildren(children, branch) {
      for (const child of children)
        this.addChild(child, branch);
    }
    /**
     * Return the last atom that was added
     */
    addChildrenAfter(children, after) {
      console.assert(children.length === 0 || children[0].type !== "first");
      console.assert(after.treeBranch !== void 0);
      const branch = this.createBranch(after.treeBranch);
      branch.splice(branch.indexOf(after) + 1, 0, ...children);
      this.isDirty = true;
      for (const child of children) {
        child.parent = this;
        child.treeBranch = after.treeBranch;
      }
      return children[children.length - 1];
    }
    removeBranch(name) {
      const children = this.branch(name);
      if (isNamedBranch(name))
        this._branches[name] = void 0;
      if (!children)
        return [];
      for (const child of children) {
        child.parent = void 0;
        child.treeBranch = void 0;
      }
      console.assert(children[0].type === "first");
      children.shift();
      this.isDirty = true;
      return children;
    }
    removeChild(child) {
      console.assert(child.parent === this);
      if (child.type === "first")
        return;
      const branch = this.branch(child.treeBranch);
      const index = branch.indexOf(child);
      console.assert(index >= 0);
      branch.splice(index, 1);
      this.isDirty = true;
      child.parent = void 0;
      child.treeBranch = void 0;
    }
    get siblings() {
      if (this.type === "root")
        return [];
      return this.parent.branch(this.treeBranch);
    }
    get firstSibling() {
      return this.siblings[0];
    }
    get lastSibling() {
      const { siblings } = this;
      return siblings[siblings.length - 1];
    }
    get isFirstSibling() {
      return this === this.firstSibling;
    }
    get isLastSibling() {
      return this === this.lastSibling;
    }
    get hasNoSiblings() {
      return this.siblings.length === 1;
    }
    get leftSibling() {
      console.assert(this.parent !== void 0);
      const siblings = this.parent.branch(this.treeBranch);
      return siblings[siblings.indexOf(this) - 1];
    }
    get rightSibling() {
      console.assert(this.parent !== void 0);
      const siblings = this.parent.branch(this.treeBranch);
      return siblings[siblings.indexOf(this) + 1];
    }
    get hasChildren() {
      return Boolean(this._branches && this.children.length > 0);
    }
    get firstChild() {
      console.assert(this.hasChildren);
      return this.children[0];
    }
    get lastChild() {
      console.assert(this.hasChildren);
      const { children } = this;
      return children[children.length - 1];
    }
    /**
     * All the children of this atom.
     *
     * The order of the atoms is the order in which they
     * are navigated using the keyboard.
     */
    get children() {
      if (this._children)
        return this._children;
      if (!this._branches)
        return [];
      const result = [];
      for (const branchName of NAMED_BRANCHES) {
        if (this._branches[branchName]) {
          for (const x of this._branches[branchName]) {
            result.push(...x.children);
            result.push(x);
          }
        }
      }
      this._children = result;
      return result;
    }
    /**
     * Render this atom as an array of boxes.
     *
     * The parent context (color, size...) will be applied
     * to the result.
     *
     */
    render(parentContext, options) {
      if (this.type === "first" && !parentContext.atomIdsSettings)
        return null;
      const context = new Context(parentContext, this.style);
      let classes = "";
      if (this.type === "root")
        classes += " ML__base";
      if (this.isSelected)
        classes += " ML__selected";
      let result = this.createBox(context, {
        classes,
        newList: (options == null ? void 0 : options.newList) === true || this.type === "first"
      });
      if (!result)
        return null;
      if (!this.subsupPlacement && (this.superscript || this.subscript)) {
        result = this.attachSupsub(context, { base: result });
      }
      return result.wrap(context);
    }
    attachSupsub(parentContext, options) {
      var _a3, _b3;
      const base = options.base;
      const superscript = this.superscript;
      const subscript = this.subscript;
      if (!superscript && !subscript)
        return base;
      let supBox = null;
      let subBox = null;
      const isCharacterBox = (_a3 = options.isCharacterBox) != null ? _a3 : this.isCharacterBox();
      let supShift = 0;
      if (superscript) {
        const context = new Context(parentContext, void 0, "superscript");
        supBox = Atom.createBox(context, superscript, { newList: true });
        if (!isCharacterBox) {
          supShift = base.height - parentContext.metrics.supDrop * context.scalingFactor;
        }
      }
      let subShift = 0;
      if (subscript) {
        const context = new Context(parentContext, void 0, "subscript");
        subBox = Atom.createBox(context, subscript, { newList: true });
        if (!isCharacterBox) {
          subShift = base.depth + parentContext.metrics.subDrop * context.scalingFactor;
        }
      }
      let minSupShift;
      if (parentContext.isDisplayStyle)
        minSupShift = parentContext.metrics.sup1;
      else if (parentContext.isCramped)
        minSupShift = parentContext.metrics.sup3;
      else
        minSupShift = parentContext.metrics.sup2;
      const scriptspace = 0.5 / PT_PER_EM / parentContext.scalingFactor;
      let supsub = null;
      if (subBox && supBox) {
        supShift = Math.max(
          supShift,
          minSupShift,
          supBox.depth + 0.25 * parentContext.metrics.xHeight
        );
        subShift = Math.max(subShift, parentContext.metrics.sub2);
        const ruleWidth = parentContext.metrics.defaultRuleThickness;
        if (supShift - supBox.depth - (subBox.height - subShift) < 4 * ruleWidth) {
          subShift = 4 * ruleWidth - (supShift - supBox.depth) + subBox.height;
          const psi = 0.8 * parentContext.metrics.xHeight - (supShift - supBox.depth);
          if (psi > 0) {
            supShift += psi;
            subShift -= psi;
          }
        }
        const slant = this.isExtensibleSymbol && base.italic ? -base.italic : 0;
        supsub = new VBox({
          individualShift: [
            { box: subBox, shift: subShift, marginLeft: slant },
            { box: supBox, shift: -supShift }
          ]
        }).wrap(parentContext);
      } else if (subBox && !supBox) {
        subShift = Math.max(
          subShift,
          parentContext.metrics.sub1,
          subBox.height - 0.8 * X_HEIGHT
        );
        supsub = new VBox({
          shift: subShift,
          children: [
            {
              box: subBox,
              marginRight: scriptspace,
              marginLeft: this.isCharacterBox() ? -((_b3 = base.italic) != null ? _b3 : 0) : 0
            }
          ]
        });
      } else if (!subBox && supBox) {
        supShift = Math.max(
          supShift,
          minSupShift,
          supBox.depth + 0.25 * X_HEIGHT
        );
        supsub = new VBox({
          shift: -supShift,
          children: [{ box: supBox, marginRight: scriptspace }]
        });
        supsub.wrap(parentContext);
      }
      const supsubContainer = new Box(supsub, {
        classes: "msubsup" + (this.isSelected ? " ML__selected" : "")
      });
      if (this.caret)
        supsubContainer.caret = this.caret;
      return new Box([base, supsubContainer], { type: options.type });
    }
    attachLimits(parentContext, options) {
      var _a3;
      const above = this.superscript ? Atom.createBox(
        new Context(parentContext, this.style, "superscript"),
        this.superscript,
        { newList: true }
      ) : null;
      const below = this.subscript ? Atom.createBox(
        new Context(parentContext, this.style, "subscript"),
        this.subscript,
        { newList: true }
      ) : null;
      if (!above && !below)
        return options.base.wrap(parentContext);
      return makeLimitsStack(parentContext, __spreadProps(__spreadValues({}, options), {
        above,
        below,
        type: (_a3 = options == null ? void 0 : options.type) != null ? _a3 : "mop"
      }));
    }
    bind(context, box) {
      if (!box || context.isPhantom || this.value === "\u200B")
        return box;
      let parent = this.parent;
      while (parent && !parent.captureSelection)
        parent = parent.parent;
      if (parent == null ? void 0 : parent.captureSelection)
        return box;
      if (!this.id)
        this.id = context.makeID();
      box.atomID = this.id;
      return box;
    }
    /**
     * Create a box with the specified body.
     */
    createBox(context, options) {
      var _a3, _b3, _c2;
      const value = (_a3 = this.value) != null ? _a3 : this.body;
      const type = isBoxType(this.type) ? this.type : void 0;
      let classes = (_b3 = options == null ? void 0 : options.classes) != null ? _b3 : "";
      if (this.mode === "text")
        classes += " ML__text";
      const result = typeof value === "string" || value === void 0 ? new Box(value != null ? value : null, {
        type,
        mode: this.mode,
        maxFontSize: context.scalingFactor,
        style: __spreadProps(__spreadValues({
          variant: "normal"
        }, this.style), {
          letterShapeStyle: context.letterShapeStyle,
          fontSize: Math.max(
            1,
            context.size + context.mathstyle.sizeDelta
          )
        }),
        classes,
        newList: options == null ? void 0 : options.newList
      }) : (_c2 = Atom.createBox(context, value, {
        type,
        mode: this.mode,
        style: this.style,
        classes,
        newList: options == null ? void 0 : options.newList
      })) != null ? _c2 : new Box(null);
      if (context.isTight)
        result.isTight = true;
      if (this.mode !== "math" || this.style.variant === "main")
        result.italic = 0;
      result.right = result.italic;
      this.bind(context, result);
      if (this.caret) {
        if (!this.superscript && !this.subscript)
          result.caret = this.caret;
      }
      return result;
    }
    /** Return true if a digit, or a decimal point, or a french decimal `{,}` */
    isDigit() {
      var _a3;
      if (this.type === "mord" && this.value)
        return /^[\d,.]$/.test(this.value);
      if (this.type === "group" && ((_a3 = this.body) == null ? void 0 : _a3.length) === 2)
        return this.body[0].type === "first" && this.body[1].value === ",";
      return false;
    }
    asDigit() {
      var _a3;
      if (this.type === "mord" && this.value && /^[\d,.]$/.test(this.value))
        return this.value;
      if (this.type === "group" && ((_a3 = this.body) == null ? void 0 : _a3.length) === 2) {
        if (this.body[0].type === "first" && this.body[1].value === ",")
          return ".";
      }
      return "";
    }
  };
  function serializeAtoms(atoms, options) {
    if (!atoms || atoms.length === 0)
      return "";
    if (atoms[0].type === "first") {
      if (atoms.length === 1)
        return "";
      atoms = atoms.slice(1);
    }
    if (atoms.length === 0)
      return "";
    return joinLatex(
      getPropertyRuns(atoms, "cssClass").map(
        (x) => joinLatex(
          getPropertyRuns(x, "color").map(
            (x2) => joinLatex(getModeRuns(x2).map((x3) => Mode.serialize(x3, options)))
          )
        )
      )
    );
  }
  function getStyleRuns(atoms) {
    let style = void 0;
    const runs = [];
    let run = [];
    for (const atom of atoms) {
      if (!style && !atom.style)
        run.push(atom);
      else {
        const atomStyle = atom.computedStyle;
        if (style && atomStyle.color === style.color && atomStyle.backgroundColor === style.backgroundColor && atomStyle.fontSize === style.fontSize) {
          run.push(atom);
        } else {
          if (run.length > 0)
            runs.push(run);
          run = [atom];
          style = atomStyle;
        }
      }
    }
    if (run.length > 0)
      runs.push(run);
    return runs;
  }
  function renderStyleRun(parentContext, atoms, options) {
    var _a3, _b3, _c2, _d2, _e;
    function isText(atom) {
      return atom.mode === "text";
    }
    if (!atoms || atoms.length === 0)
      return null;
    const context = new Context(parentContext, options == null ? void 0 : options.style);
    const displaySelection = !((_a3 = context.atomIdsSettings) == null ? void 0 : _a3.groupNumbers);
    let boxes = [];
    let newList = (_b3 = options == null ? void 0 : options.newList) != null ? _b3 : false;
    if (atoms.length === 1) {
      const atom = atoms[0];
      const box = atom.render(context, { newList });
      if (box) {
        if (displaySelection && atom.isSelected)
          box.selected(true);
        boxes = [box];
      }
    } else {
      let digitOrTextStringID = "";
      let lastWasDigit = true;
      for (const atom of atoms) {
        if (((_c2 = context.atomIdsSettings) == null ? void 0 : _c2.groupNumbers) && digitOrTextStringID && (lastWasDigit && atom.isDigit() || !lastWasDigit && isText(atom)))
          context.atomIdsSettings.overrideID = digitOrTextStringID;
        const box = atom.render(context, { newList });
        if (context.atomIdsSettings)
          context.atomIdsSettings.overrideID = void 0;
        if (box) {
          newList = atom.type === "group" && !atom["boxType"];
          if ((_d2 = context.atomIdsSettings) == null ? void 0 : _d2.groupNumbers) {
            if (atom.isDigit() || isText(atom)) {
              if (!digitOrTextStringID || lastWasDigit !== atom.isDigit()) {
                lastWasDigit = atom.isDigit();
                digitOrTextStringID = (_e = atom.id) != null ? _e : "";
              }
            }
            if (digitOrTextStringID && (!(atom.isDigit() || isText(atom)) || !atom.hasEmptyBranch("superscript") || !atom.hasEmptyBranch("subscript"))) {
              digitOrTextStringID = "";
            }
          }
          if (displaySelection && atom.isSelected)
            box.selected(true);
          boxes.push(box);
        }
      }
    }
    if (boxes.length === 0)
      return null;
    let result;
    if (options || context.isTight || boxes.length > 1) {
      result = new Box(boxes, __spreadValues({
        isTight: context.isTight
      }, options != null ? options : {}));
      result.isSelected = boxes.every((x) => x.isSelected);
    } else
      result = boxes[0];
    return result.wrap(context).wrap(parentContext);
  }

  // src/core-atoms/accent.ts
  var AccentAtom = class extends Atom {
    constructor(command, body, context, options) {
      super("accent", context, { command, style: options.style });
      if (options.accentChar)
        this.accent = options.accentChar;
      else
        this.svgAccent = options == null ? void 0 : options.svgAccent;
      this.body = body;
      this.skipBoundary = true;
      this.captureSelection = true;
    }
    static fromJson(json, context) {
      return new AccentAtom(json.command, json.body, context, {
        accentChar: json.accentChar,
        svgAccent: json.svgAccent,
        style: json.style
      });
    }
    toJson() {
      return __spreadProps(__spreadValues({}, super.toJson()), {
        accentChar: this.accent,
        svgAccent: this.svgAccent
      });
    }
    render(parentContext) {
      var _a3;
      const context = new Context(parentContext, this.style, "cramp");
      const base = (_a3 = Atom.createBox(context, this.body)) != null ? _a3 : new Box(null);
      let skew = 0;
      if (!this.hasEmptyBranch("body") && this.body.length === 2 && this.body[1].isCharacterBox())
        skew = base.skew;
      let clearance = Math.min(base.height, X_HEIGHT);
      let accentBox;
      if (this.svgAccent) {
        accentBox = makeSVGBox(this.svgAccent);
        clearance = context.metrics.bigOpSpacing1 - clearance;
      } else if (this.accent) {
        const accent = new Box(this.accent, { fontFamily: "Main-Regular" });
        accent.italic = 0;
        const vecClass = this.accent === 8407 ? " ML__accent-vec" : "";
        accentBox = new Box(new Box(accent), {
          classes: "ML__accent-body" + vecClass
        });
      }
      accentBox = new VBox({
        shift: 0,
        children: [
          { box: new Box(base) },
          -clearance,
          {
            box: accentBox,
            marginLeft: base.left + 2 * skew,
            classes: ["ML__center"]
          }
        ]
      });
      const result = new Box(accentBox, { newList: true, type: "mord" });
      if (this.caret)
        result.caret = this.caret;
      this.bind(context, result.wrap(context));
      return this.attachSupsub(context, { base: result });
    }
  };

  // src/core/delimiters.ts
  var RIGHT_DELIM = {
    "(": ")",
    "{": "}",
    "[": "]",
    "|": "|",
    "\\lbrace": "\\rbrace",
    "\\lparen": "\\rparen",
    "\\{": "\\}",
    "\\langle": "\\rangle",
    "\\lfloor": "\\rfloor",
    "\\lceil": "\\rceil",
    "\\vert": "\\vert",
    "\\lvert": "\\rvert",
    "\\Vert": "\\Vert",
    "\\lVert": "\\rVert",
    "\\lbrack": "\\rbrack",
    "\\ulcorner": "\\urcorner",
    "\\llcorner": "\\lrcorner",
    "\\lgroup": "\\rgroup",
    "\\lmoustache": "\\rmoustache"
  };
  var LEFT_DELIM = Object.fromEntries(
    Object.entries(RIGHT_DELIM).map(([leftDelim, rightDelim]) => [
      rightDelim,
      leftDelim
    ])
  );
  function getSymbolValue(symbol) {
    var _a3;
    return (_a3 = {
      "[": 91,
      // '[',
      "]": 93,
      // ']',
      "(": 40,
      // '(',
      ")": 41,
      // ')',
      "\\mid": 8739,
      "|": 8739,
      "\u2223": 8739,
      // DIVIDES
      "\u2225": 8741,
      // PARALLEL TO
      "\\|": 8739,
      "\\{": 123,
      // '{',
      "\\}": 125,
      // '}',
      "\\lbrace": 123,
      // '{',
      "\\rbrace": 125,
      // '}',
      "\\lparen": 40,
      // '('
      "\\rparen": 41,
      // ')'
      "\\lbrack": 91,
      // '[',
      "\\rbrack": 93,
      // ']',
      "\\vert": 8739,
      "\\lvert": 8739,
      "\\mvert": 8739,
      "\\rvert": 8739,
      "\\Vert": 8741,
      "\\lVert": 8741,
      "\\mVert": 8741,
      "\\rVert": 8741,
      "\\parallel": 8741,
      "\\shortparallel": 8741,
      "\\langle": 10216,
      "\\rangle": 10217,
      "\\lfloor": 8970,
      "\\rfloor": 8971,
      "\\lceil": 8968,
      "\\rceil": 8969,
      "\\ulcorner": 9484,
      "\\urcorner": 9488,
      "\\llcorner": 9492,
      "\\lrcorner": 9496,
      "\\lgroup": 10222,
      "\\rgroup": 10223,
      "\\lmoustache": 9136,
      "\\rmoustache": 9137,
      "\\surd": 8730
    }[symbol]) != null ? _a3 : symbol.codePointAt(0);
  }
  function makeSmallDelim(delim, context, center, options) {
    const text = new Box(getSymbolValue(delim), { fontFamily: "Main-Regular" });
    const box = text.wrap(context, options);
    if (center)
      box.setTop((1 - context.scalingFactor) * AXIS_HEIGHT);
    return box;
  }
  function makeLargeDelim(delim, size, center, parentContext, options) {
    const context = new Context(parentContext, options == null ? void 0 : options.style, "textstyle");
    const result = new Box(getSymbolValue(delim), {
      fontFamily: "Size" + size + "-Regular",
      classes: "ML__delim-size" + size
    }).wrap(context);
    if (center)
      result.setTop((1 - context.scalingFactor) * AXIS_HEIGHT);
    return result;
  }
  function makeStackedDelim(delim, heightTotal, center, context, options) {
    var _a3;
    let top;
    let middle;
    let repeat;
    let bottom;
    top = repeat = bottom = getSymbolValue(delim);
    middle = null;
    let fontFamily = "Size1-Regular";
    if (delim === "\\vert" || delim === "\\lvert" || delim === "\\rvert" || delim === "\\mvert" || delim === "\\mid")
      repeat = top = bottom = 8739;
    else if (delim === "\\Vert" || delim === "\\lVert" || delim === "\\rVert" || delim === "\\mVert" || delim === "\\|")
      repeat = top = bottom = 8741;
    else if (delim === "\\uparrow")
      repeat = bottom = 9168;
    else if (delim === "\\Uparrow")
      repeat = bottom = 8214;
    else if (delim === "\\downarrow")
      top = repeat = 9168;
    else if (delim === "\\Downarrow")
      top = repeat = 8214;
    else if (delim === "\\updownarrow") {
      top = 8593;
      repeat = 9168;
      bottom = 8595;
    } else if (delim === "\\Updownarrow") {
      top = 8657;
      repeat = 8214;
      bottom = 8659;
    } else if (delim === "[" || delim === "\\lbrack") {
      top = 9121;
      repeat = 9122;
      bottom = 9123;
      fontFamily = "Size4-Regular";
    } else if (delim === "]" || delim === "\\rbrack") {
      top = 9124;
      repeat = 9125;
      bottom = 9126;
      fontFamily = "Size4-Regular";
    } else if (delim === "\\lfloor" || delim === "\u230A") {
      repeat = top = 9122;
      bottom = 9123;
      fontFamily = "Size4-Regular";
    } else if (delim === "\\lceil" || delim === "\u2308") {
      top = 9121;
      repeat = bottom = 9122;
      fontFamily = "Size4-Regular";
    } else if (delim === "\\rfloor" || delim === "\u230B") {
      repeat = top = 9125;
      bottom = 9126;
      fontFamily = "Size4-Regular";
    } else if (delim === "\\rceil" || delim === "\u2309") {
      top = 9124;
      repeat = bottom = 9125;
      fontFamily = "Size4-Regular";
    } else if (delim === "(" || delim === "\\lparen") {
      top = 9115;
      repeat = 9116;
      bottom = 9117;
      fontFamily = "Size4-Regular";
    } else if (delim === ")" || delim === "\\rparen") {
      top = 9118;
      repeat = 9119;
      bottom = 9120;
      fontFamily = "Size4-Regular";
    } else if (delim === "\\{" || delim === "\\lbrace") {
      top = 9127;
      middle = 9128;
      bottom = 9129;
      repeat = 9130;
      fontFamily = "Size4-Regular";
    } else if (delim === "\\}" || delim === "\\rbrace") {
      top = 9131;
      middle = 9132;
      bottom = 9133;
      repeat = 9130;
      fontFamily = "Size4-Regular";
    } else if (delim === "\\lgroup" || delim === "\u27EE") {
      top = 9127;
      bottom = 9129;
      repeat = 9130;
      fontFamily = "Size4-Regular";
    } else if (delim === "\\rgroup" || delim === "\u27EF") {
      top = 9131;
      bottom = 9133;
      repeat = 9130;
      fontFamily = "Size4-Regular";
    } else if (delim === "\\lmoustache" || delim === "\u23B0") {
      top = 9127;
      bottom = 9133;
      repeat = 9130;
      fontFamily = "Size4-Regular";
    } else if (delim === "\\rmoustache" || delim === "\u23B1") {
      top = 9131;
      bottom = 9129;
      repeat = 9130;
      fontFamily = "Size4-Regular";
    } else if (delim === "\\surd") {
      top = 57345;
      bottom = 9143;
      repeat = 57344;
      fontFamily = "Size4-Regular";
    } else if (delim === "\\ulcorner") {
      top = 9484;
      repeat = bottom = 32;
    } else if (delim === "\\urcorner") {
      top = 9488;
      repeat = bottom = 32;
    } else if (delim === "\\llcorner") {
      bottom = 9492;
      repeat = top = 32;
    } else if (delim === "\\lrcorner") {
      top = 9496;
      repeat = top = 32;
    }
    const topMetrics = getCharacterMetrics(top, fontFamily);
    const topHeightTotal = topMetrics.height + topMetrics.depth;
    const repeatMetrics = getCharacterMetrics(repeat, fontFamily);
    const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
    const bottomMetrics = getCharacterMetrics(bottom, fontFamily);
    const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
    let middleHeightTotal = 0;
    let middleFactor = 1;
    if (middle !== null) {
      const middleMetrics = getCharacterMetrics(middle, fontFamily);
      middleHeightTotal = middleMetrics.height + middleMetrics.depth;
      middleFactor = 2;
    }
    const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
    const repeatCount = Math.max(
      0,
      Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal))
    );
    const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
    let axisHeight = AXIS_HEIGHT;
    if (center)
      axisHeight = axisHeight * context.scalingFactor;
    const depth = realHeightTotal / 2 - axisHeight;
    const OVERLAP = 8e-3;
    const stack = [];
    stack.push({ box: new Box(bottom, { fontFamily }) });
    stack.push(-OVERLAP);
    const repeatBox = new Box(repeat, { fontFamily });
    if (middle === null) {
      for (let i = 0; i < repeatCount; i++)
        stack.push({ box: repeatBox });
    } else {
      for (let i = 0; i < repeatCount; i++)
        stack.push({ box: repeatBox });
      stack.push(-OVERLAP);
      stack.push({ box: new Box(middle, { fontFamily }) });
      stack.push(-OVERLAP);
      for (let i = 0; i < repeatCount; i++)
        stack.push({ box: repeatBox });
    }
    stack.push(-OVERLAP);
    stack.push({ box: new Box(top, { fontFamily }) });
    let sizeClass = "";
    if (fontFamily === "Size1-Regular")
      sizeClass = " delim-size1";
    else if (fontFamily === "Size4-Regular")
      sizeClass = " delim-size4";
    const inner = new VBox(
      {
        bottom: depth,
        children: stack
      },
      { classes: sizeClass }
    );
    const result = new Box(inner, __spreadProps(__spreadValues({}, options != null ? options : {}), {
      classes: ((_a3 = options == null ? void 0 : options.classes) != null ? _a3 : "") + " ML__delim-mult"
    }));
    return result;
  }
  var stackLargeDelimiters = /* @__PURE__ */ new Set([
    "(",
    ")",
    "\\lparen",
    "\\rparen",
    "[",
    "]",
    "\\lbrack",
    "\\rbrack",
    "\\{",
    "\\}",
    "\\lbrace",
    "\\rbrace",
    "\\lfloor",
    "\\rfloor",
    "\\lceil",
    "\\rceil",
    "\\surd",
    "\u230A",
    "\u230B",
    "\u2308",
    "\u2309"
  ]);
  var stackAlwaysDelimiters = /* @__PURE__ */ new Set([
    "\\uparrow",
    "\\downarrow",
    "\\updownarrow",
    "\\Uparrow",
    "\\Downarrow",
    "\\Updownarrow",
    "|",
    "\\|",
    "\\vert",
    "\\Vert",
    "\\lvert",
    "\\rvert",
    "\\lVert",
    "\\rVert",
    "\\mvert",
    "\\mid",
    "\\lgroup",
    "\\rgroup",
    "\\lmoustache",
    "\\rmoustache",
    "\u27EE",
    "\u27EF",
    "\u23B0",
    "\u23B1"
  ]);
  var stackNeverDelimiters = /* @__PURE__ */ new Set([
    "<",
    ">",
    "\\langle",
    "\\rangle",
    "/",
    "\\backslash",
    "\\lt",
    "\\gt"
  ]);
  var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
  function makeSizedDelim(delim, size, context, options) {
    var _a3;
    if (delim === void 0 || delim === ".") {
      return makeNullDelimiter(
        context,
        (_a3 = options.type) != null ? _a3 : "minner",
        options.classes
      );
    }
    if (delim === "<" || delim === "\\lt" || delim === "\u27E8")
      delim = "\\langle";
    else if (delim === ">" || delim === "\\gt" || delim === "\u27E9")
      delim = "\\rangle";
    if (stackLargeDelimiters.has(delim) || stackNeverDelimiters.has(delim))
      return makeLargeDelim(delim, size, false, context, options);
    if (stackAlwaysDelimiters.has(delim)) {
      return makeStackedDelim(
        delim,
        sizeToMaxHeight[size],
        false,
        context,
        options
      );
    }
    console.assert(false, "Unknown delimiter '" + delim + "'");
    return null;
  }
  var stackNeverDelimiterSequence = [
    { type: "small", mathstyle: "scriptscriptstyle" },
    { type: "small", mathstyle: "scriptstyle" },
    { type: "small", mathstyle: "textstyle" },
    { type: "large", size: 1 },
    { type: "large", size: 2 },
    { type: "large", size: 3 },
    { type: "large", size: 4 }
  ];
  var stackAlwaysDelimiterSequence = [
    { type: "small", mathstyle: "scriptscriptstyle" },
    { type: "small", mathstyle: "scriptscriptstyle" },
    { type: "small", mathstyle: "textstyle" },
    { type: "stack" }
  ];
  var stackLargeDelimiterSequence = [
    { type: "small", mathstyle: "scriptscriptstyle" },
    { type: "small", mathstyle: "scriptstyle" },
    { type: "small", mathstyle: "textstyle" },
    { type: "large", size: 1 },
    { type: "large", size: 2 },
    { type: "large", size: 3 },
    { type: "large", size: 4 },
    { type: "stack" }
  ];
  function delimTypeToFont(info) {
    if (info.type === "small")
      return "Main-Regular";
    if (info.type === "large")
      return "Size" + info.size + "-Regular";
    console.assert(info.type === "stack");
    return "Size4-Regular";
  }
  function traverseSequence(delim, height, sequence, context) {
    const start = { "-4": 0, "-3": 1, "0": 2 }[context.mathstyle.sizeDelta];
    for (let i = start; i < sequence.length; i++) {
      if (sequence[i].type === "stack") {
        break;
      }
      const metrics = getCharacterMetrics(delim, delimTypeToFont(sequence[i]));
      if (metrics.defaultMetrics) {
        return { type: "small", mathstyle: "scriptstyle" };
      }
      let heightDepth = metrics.height + metrics.depth;
      if (sequence[i].type === "small") {
        if (sequence[i].mathstyle === "scriptscriptstyle")
          heightDepth *= FONT_SCALE[Math.max(1, context.size - 2)];
        else if (sequence[i].mathstyle === "scriptstyle")
          heightDepth *= FONT_SCALE[Math.max(1, context.size - 1)];
      }
      if (heightDepth > height)
        return sequence[i];
    }
    return sequence[sequence.length - 1];
  }
  function makeCustomSizedDelim(type, delim, height, center, context, options) {
    var _a3;
    if (!delim || delim.length === 0 || delim === ".")
      return makeNullDelimiter(context, type, type);
    if (delim === "<" || delim === "\\lt")
      delim = "\\langle";
    else if (delim === ">" || delim === "\\gt")
      delim = "\\rangle";
    let sequence;
    if (stackNeverDelimiters.has(delim))
      sequence = stackNeverDelimiterSequence;
    else if (stackLargeDelimiters.has(delim))
      sequence = stackLargeDelimiterSequence;
    else
      sequence = stackAlwaysDelimiterSequence;
    const delimType = traverseSequence(
      getSymbolValue(delim),
      height,
      sequence,
      context
    );
    const delimContext = new Context(
      context,
      options == null ? void 0 : options.style,
      delimType.mathstyle
    );
    if (delimType.type === "small") {
      return makeSmallDelim(delim, delimContext, center, {
        type,
        classes: "ML__small-delim " + ((_a3 = options == null ? void 0 : options.classes) != null ? _a3 : "")
      });
    }
    if (delimType.type === "large") {
      return makeLargeDelim(delim, delimType.size, center, delimContext, __spreadProps(__spreadValues({}, options), {
        type
      }));
    }
    console.assert(delimType.type === "stack");
    return makeStackedDelim(delim, height, center, delimContext, __spreadProps(__spreadValues({}, options), {
      type
    }));
  }
  function makeLeftRightDelim(type, delim, height, depth, context, options) {
    if (delim === ".")
      return makeNullDelimiter(context, type, options == null ? void 0 : options.classes);
    const axisHeight = AXIS_HEIGHT * context.scalingFactor;
    const delimiterFactor = 901;
    const delimiterExtend = 5 / PT_PER_EM;
    const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
    const totalHeight = Math.max(
      maxDistFromAxis / 500 * delimiterFactor,
      2 * maxDistFromAxis - delimiterExtend
    );
    return makeCustomSizedDelim(type, delim, totalHeight, true, context, options);
  }
  function makeNullDelimiter(parentContext, type, classes) {
    const context = new Context(parentContext, void 0, "textstyle");
    return new Box(null, {
      classes: " nulldelimiter " + (classes != null ? classes : ""),
      type
    }).wrap(context);
  }

  // src/core-atoms/overunder.ts
  var OverunderAtom = class extends Atom {
    constructor(command, context, options) {
      var _a3, _b3, _c2, _d2;
      super("overunder", context, {
        command,
        serialize: options.serialize,
        style: options.style
      });
      this.skipBoundary = (_a3 = options.skipBoundary) != null ? _a3 : true;
      this.subsupPlacement = options.supsubPlacement;
      this.body = options.body;
      this.svgAbove = options.svgAbove;
      this.svgBelow = options.svgBelow;
      this.svgBody = options.svgBody;
      this.above = options.above;
      this.below = options.below;
      this.boxType = (_b3 = options.boxType) != null ? _b3 : "mord";
      this.paddedBody = (_c2 = options.paddedBody) != null ? _c2 : false;
      this.paddedLabels = (_d2 = options.paddedLabels) != null ? _d2 : false;
    }
    static fromJson(json, context) {
      return new OverunderAtom(json.command, context, json);
    }
    toJson() {
      const options = {};
      if (!this.skipBoundary)
        options.skipBoundary = false;
      if (this.subsupPlacement)
        options.subsupPlacement = this.subsupPlacement;
      if (this.svgAbove)
        options.svgAbove = this.svgAbove;
      if (this.svgBelow)
        options.svgBelow = this.svgBelow;
      if (this.svgBody)
        options.svgBody = this.svgBody;
      if (this.boxType !== "mord")
        options.boxType = this.boxType;
      if (this.paddedBody)
        options.paddedBody = true;
      if (this.paddedLabels)
        options.paddedLabels = true;
      return __spreadValues(__spreadValues({}, super.toJson()), options);
    }
    /**
     * Combine a base with an atom above and an atom below.
     *
     * See http://tug.ctan.org/macros/latex/required/amsmath/amsmath.dtx
     *
     * > \newcommand{\overset}[2]{\binrel@{#2}%
     * > \binrel@@{\mathop{\kern\z@#2}\limits^{#1}}}
     *
     */
    render(parentContext) {
      let body = this.svgBody ? makeSVGBox(this.svgBody) : Atom.createBox(parentContext, this.body, { newList: true });
      const annotationContext = new Context(
        parentContext,
        this.style,
        "scriptstyle"
      );
      let above = null;
      if (this.svgAbove)
        above = makeSVGBox(this.svgAbove);
      else if (this.above)
        above = Atom.createBox(annotationContext, this.above, { newList: true });
      let below = null;
      if (this.svgBelow)
        below = makeSVGBox(this.svgBelow);
      else if (this.below)
        below = Atom.createBox(annotationContext, this.below, { newList: true });
      if (this.paddedBody) {
        body = new Box(
          [
            makeNullDelimiter(parentContext, "mopen"),
            body,
            makeNullDelimiter(parentContext, "mclose")
          ],
          { newList: true }
        );
      }
      let base = makeOverunderStack(parentContext, {
        base: body,
        above,
        // aboveShift,
        below,
        // belowShift,
        type: this.boxType === "mbin" || this.boxType === "mrel" ? this.boxType : "mord",
        paddedAboveBelow: this.paddedLabels
      });
      if (!base)
        return null;
      if (this.subsupPlacement === "over-under")
        base = this.attachLimits(parentContext, { base, type: base.type });
      else
        base = this.attachSupsub(parentContext, { base });
      if (this.caret)
        base.caret = this.caret;
      return this.bind(parentContext, base);
    }
  };
  function makeOverunderStack(context, options) {
    if (!options.base)
      return null;
    if (!options.above && !options.below) {
      const box = new Box(options.base, { type: options.type });
      box.setStyle("position", "relative");
      return box;
    }
    let aboveShift = 0;
    if (options.above)
      aboveShift = -options.above.depth + context.metrics.bigOpSpacing2;
    let result = null;
    const base = options.base;
    const baseShift = 0;
    const classes = ["ML__center"];
    if (options.paddedAboveBelow)
      classes.push("ML__label_padding");
    if (options.below && options.above) {
      const bottom = context.metrics.bigOpSpacing5 + options.below.height + options.below.depth + base.depth + baseShift;
      result = new VBox({
        bottom,
        children: [
          context.metrics.bigOpSpacing5,
          { box: options.below, classes },
          { box: base, classes: ["ML__center"] },
          aboveShift,
          { box: options.above, classes },
          context.metrics.bigOpSpacing5
        ]
      });
    } else if (options.below) {
      result = new VBox({
        top: base.height - baseShift,
        children: [
          context.metrics.bigOpSpacing5,
          { box: options.below, classes },
          { box: base, classes: ["ML__center"] }
        ]
      });
    } else if (options.above) {
      result = new VBox({
        bottom: base.depth + baseShift,
        children: [
          // base.depth,
          { box: base, classes: ["ML__center"] },
          aboveShift,
          { box: options.above, classes },
          context.metrics.bigOpSpacing5
        ]
      });
    }
    return new Box(result, { type: options.type });
  }

  // src/core-definitions/accents.ts
  var ACCENTS = {
    acute: 714,
    grave: 715,
    dot: 729,
    ddot: 168,
    mathring: 730,
    tilde: 126,
    bar: 713,
    breve: 728,
    check: 711,
    hat: 94,
    vec: 8407
  };
  defineFunction(Object.keys(ACCENTS), "{body:auto}", {
    createAtom: (command, args, style, context) => new AccentAtom(command, args[0], context, {
      accentChar: ACCENTS[command.slice(1)],
      style
    })
  });
  defineFunction(["widehat", "widecheck", "widetilde"], "{body:auto}", {
    createAtom: (command, args, style, context) => {
      const baseString = parseArgAsString(args[0]);
      return new AccentAtom(command, args[0], context, {
        style,
        svgAccent: command.slice(1) + (baseString.length > 5 ? "4" : ["1", "1", "2", "2", "3", "3"][baseString.length])
      });
    }
  });
  defineFunction(["overarc", "overparen", "wideparen"], "{body:auto}", {
    createAtom: (command, args, style, context) => {
      return new AccentAtom(command, args[0], context, {
        style,
        svgAccent: "overarc"
      });
    }
  });
  defineFunction(["underarc", "underparen"], "{body:auto}", {
    createAtom: (command, args, style, context) => {
      return new OverunderAtom(command, context, {
        body: args[0],
        style,
        svgBelow: "underarc"
      });
    }
  });
  defineFunction("utilde", "{body:auto}", {
    createAtom: (command, args, style, context) => {
      const baseString = parseArgAsString(args[0]);
      const accent = "widetilde" + (baseString.length > 5 ? "4" : ["1", "1", "2", "2", "3", "3"][baseString.length]);
      return new OverunderAtom(command, context, {
        body: args[0],
        svgBelow: accent,
        style,
        boxType: binRelType(args[0])
      });
    }
  });
  defineFunction("^", "{:string}", {
    createAtom: (command, args, style, context) => {
      var _a3;
      return new Atom("mord", context, {
        command,
        isFunction: false,
        limits: "adjacent",
        style,
        value: args[0] ? (_a3 = {
          a: "\xE2",
          e: "\xEA",
          i: "\xEE",
          o: "\xF4",
          u: "\xFB",
          A: "\xC2",
          E: "\xCA",
          I: "\xCE",
          O: "\xD4",
          U: "\xDB"
        }[args[0]]) != null ? _a3 : "^" : "^"
      });
    }
  });
  defineFunction("`", "{:string}", {
    createAtom: (command, args, style, context) => {
      var _a3;
      return new Atom("mord", context, {
        command,
        isFunction: false,
        limits: "adjacent",
        style,
        value: args[0] ? (_a3 = {
          a: "\xE0",
          e: "\xE8",
          i: "\xEC",
          o: "\xF2",
          u: "\xF9",
          A: "\xC0",
          E: "\xC8",
          I: "\xCC",
          O: "\xD2",
          U: "\xD9"
        }[args[0]]) != null ? _a3 : "`" : "`"
      });
    }
  });
  defineFunction("'", "{:string}", {
    createAtom: (command, args, style, context) => {
      var _a3;
      return new Atom("mord", context, {
        command,
        isFunction: false,
        limits: "adjacent",
        style,
        value: args[0] ? (_a3 = {
          a: "\xE1",
          e: "\xE9",
          i: "\xED",
          o: "\xF3",
          u: "\xFA",
          A: "\xC1",
          E: "\xC9",
          I: "\xCD",
          O: "\xD3",
          U: "\xDA"
        }[args[0]]) != null ? _a3 : "^" : "^"
      });
    }
  });
  defineFunction("~", "{:string}", {
    createAtom: (command, args, style, context) => {
      var _a3;
      return new Atom("mord", context, {
        command,
        isFunction: false,
        limits: "adjacent",
        style,
        value: args[0] ? (_a3 = { n: "\xF1", N: "\xD1", a: "\xE3", o: "\xF5", A: "\xC3", O: "\xD5" }[args[0]]) != null ? _a3 : "\xB4" : "\xB4"
      });
    }
  });
  defineFunction("c", "{:string}", {
    createAtom: (command, args, style, context) => {
      var _a3;
      return new Atom("mord", context, {
        command,
        isFunction: false,
        limits: "adjacent",
        style,
        value: args[0] ? (_a3 = { c: "\xE7", C: "\xC7" }[args[0]]) != null ? _a3 : "" : ""
      });
    }
  });

  // src/core-atoms/error.ts
  var ErrorAtom = class extends Atom {
    constructor(value, context) {
      super("error", context, { value, command: value, mode: "math" });
      this.verbatimLatex = value;
    }
    static fromJson(json, context) {
      return new ErrorAtom(json.command, context);
    }
    toJson() {
      return super.toJson();
    }
    render(context) {
      const result = this.createBox(context, { classes: "ML__error" });
      if (this.caret)
        result.caret = this.caret;
      return result;
    }
  };

  // src/core-atoms/group.ts
  var GroupAtom = class extends Atom {
    constructor(arg, context, options) {
      var _a3, _b3, _c2, _d2;
      super("group", context, {
        command: options == null ? void 0 : options.command,
        mode: (_a3 = options == null ? void 0 : options.mode) != null ? _a3 : "math",
        serialize: options == null ? void 0 : options.serialize,
        style: options == null ? void 0 : options.style
      });
      this.body = arg;
      this.mathstyleName = options == null ? void 0 : options.mathstyleName;
      console.assert(
        !(options == null ? void 0 : options.serialize) || !Boolean(options == null ? void 0 : options.latexClose) || !Boolean(options == null ? void 0 : options.latexOpen),
        (_b3 = options == null ? void 0 : options.command) != null ? _b3 : ""
      );
      this.latexOpen = options == null ? void 0 : options.latexOpen;
      this.latexClose = options == null ? void 0 : options.latexClose;
      this.cssId = options == null ? void 0 : options.cssId;
      this.htmlData = options == null ? void 0 : options.htmlData;
      this.htmlStyle = options == null ? void 0 : options.htmlStyle;
      this.customClass = options == null ? void 0 : options.customClass;
      this.boxType = options == null ? void 0 : options.boxType;
      this.skipBoundary = true;
      this.captureSelection = (_c2 = options == null ? void 0 : options.captureSelection) != null ? _c2 : false;
      this.changeMode = (_d2 = options == null ? void 0 : options.changeMode) != null ? _d2 : false;
      this.displayContainsHighlight = false;
      if (arg && arg.length === 1 && arg[0].command === ",")
        this.captureSelection = true;
    }
    static fromJson(json, context) {
      return new GroupAtom(json.body, context, json);
    }
    toJson() {
      const options = {};
      if (this.mathstyleName)
        options.mathstyleName = this.mathstyleName;
      if (this.latexOpen)
        options.latexOpen = this.latexOpen;
      if (this.latexClose)
        options.latexClose = this.latexClose;
      if (this.cssId)
        options.cssId = this.cssId;
      if (this.htmlData)
        options.htmlData = this.htmlData;
      if (this.htmlStyle)
        options.htmlStyle = this.htmlStyle;
      if (this.customClass)
        options.customClass = this.customClass;
      if (this.boxType)
        options.boxType = this.boxType;
      if (this.captureSelection)
        options.captureSelection = true;
      if (this.changeMode)
        options.changeMode = true;
      return __spreadValues(__spreadValues({}, super.toJson()), options);
    }
    render(context) {
      const localContext = new Context(context, this.style, this.mathstyleName);
      const box = Atom.createBox(localContext, this.body, {
        type: this.boxType,
        classes: this.customClass,
        mode: this.mode,
        style: { backgroundColor: this.style.backgroundColor },
        newList: !this.boxType
      });
      if (!box)
        return null;
      if (this.cssId)
        box.cssId = this.cssId;
      if (this.htmlData)
        box.htmlData = this.htmlData;
      if (this.htmlStyle)
        box.htmlStyle = this.htmlStyle;
      if (this.caret)
        box.caret = this.caret;
      return this.bind(context, box);
    }
    serialize(options) {
      let result = this.bodyToLatex(options);
      if (typeof this.latexOpen === "string")
        result = this.latexOpen + result + this.latexClose;
      if (this.htmlData)
        result = `\\htmlData{${this.htmlData}}{${result}}`;
      if (this.htmlStyle)
        result = `\\htmlStyle{${this.htmlStyle}}{${result}}`;
      if (this.customClass)
        result = `\\class{${this.customClass}}{${result}}`;
      if (this.cssId)
        result = `\\cssId{${this.cssId}}{${result}}`;
      return result;
    }
  };

  // src/core-atoms/leftright.ts
  var LeftRightAtom = class extends Atom {
    constructor(variant, body, context, options) {
      super("leftright", context, {
        style: options.style,
        displayContainsHighlight: true
      });
      this.variant = variant;
      this.body = body;
      this.leftDelim = options.leftDelim;
      this.rightDelim = options.rightDelim;
    }
    static fromJson(json, context) {
      var _a3;
      return new LeftRightAtom(
        (_a3 = json.variant) != null ? _a3 : "",
        json.body,
        context,
        json
      );
    }
    toJson() {
      const result = super.toJson();
      if (this.variant)
        result.variant = this.variant;
      if (this.leftDelim)
        result.leftDelim = this.leftDelim;
      if (this.rightDelim)
        result.rightDelim = this.rightDelim;
      return result;
    }
    serialize(options) {
      var _a3, _b3;
      const rightDelim = this.matchingRightDelim();
      if (this.variant === "left...right") {
        return joinLatex([
          "\\left" + ((_a3 = this.leftDelim) != null ? _a3 : "."),
          this.bodyToLatex(options),
          "\\right" + rightDelim
        ]);
      }
      if (this.variant === "mleft...mright") {
        return joinLatex([
          "\\mleft" + ((_b3 = this.leftDelim) != null ? _b3 : "."),
          this.bodyToLatex(options),
          "\\mright" + rightDelim
        ]);
      }
      return joinLatex([
        !this.leftDelim || this.leftDelim === "." ? "" : this.leftDelim,
        this.bodyToLatex(options),
        rightDelim
      ]);
    }
    matchingRightDelim() {
      var _a3, _b3;
      if (this.rightDelim && this.rightDelim !== "?")
        return this.rightDelim;
      const leftDelim = (_a3 = this.leftDelim) != null ? _a3 : ".";
      return (_b3 = RIGHT_DELIM[leftDelim]) != null ? _b3 : leftDelim;
    }
    render(parentContext) {
      var _a3, _b3, _c2;
      const context = new Context(parentContext, this.style);
      console.assert(this.body !== void 0);
      const delimContext = new Context(parentContext, this.style, "textstyle");
      const inner = (_a3 = Atom.createBox(context, this.body, { newList: true })) != null ? _a3 : new Box(null, { newList: true });
      const innerHeight = inner.height / delimContext.scalingFactor;
      const innerDepth = inner.depth / delimContext.scalingFactor;
      const boxes = [];
      if (this.leftDelim) {
        boxes.push(
          this.bind(
            delimContext,
            makeLeftRightDelim(
              "mopen",
              this.leftDelim,
              innerHeight,
              innerDepth,
              delimContext,
              {
                classes: "ML__open" + (this.containsCaret ? " ML__contains-caret" : ""),
                mode: this.mode,
                style: this.style
              }
            )
          )
        );
      }
      if (inner) {
        if (inner.children) {
          for (let i = 0; i < inner.children.length; i++) {
            const child = inner.children[i];
            if (child.delim) {
              const savedCaret = child.caret;
              inner.children[i] = this.bind(
                context,
                makeLeftRightDelim(
                  "minner",
                  child.delim,
                  innerHeight,
                  innerDepth,
                  context
                )
              );
              inner.children[i].caret = savedCaret;
            }
          }
        }
        boxes.push(inner);
      }
      if (this.rightDelim) {
        let classes = this.containsCaret ? " ML__contains-caret" : "";
        let delim = this.rightDelim;
        if (delim === "?") {
          if (this.context.smartFence) {
            delim = this.matchingRightDelim();
            classes += " ML__smart-fence__close";
          } else
            delim = ".";
        }
        boxes.push(
          this.bind(
            delimContext,
            makeLeftRightDelim(
              "mclose",
              delim,
              innerHeight,
              innerDepth,
              delimContext,
              {
                classes: classes + " ML__close",
                mode: this.mode,
                style: this.style
              }
            )
          )
        );
      }
      const tightSpacing = (_c2 = this.variant === "mleft...mright" || ((_b3 = this.leftSibling) == null ? void 0 : _b3.isFunction)) != null ? _c2 : false;
      const result = new Box(boxes, {
        type: tightSpacing ? "mclose" : "minner",
        classes: "left-right"
      });
      if (this.caret)
        result.caret = this.caret;
      return this.bind(context, result.wrap(context));
    }
  };

  // src/core-atoms/macro.ts
  var MacroAtom = class extends Atom {
    constructor(macro, context, options) {
      var _a3, _b3;
      super("macro", context, { command: macro });
      this.body = options.body;
      if (options.captureSelection === void 0) {
        if (options.args)
          this.captureSelection = false;
        else
          this.captureSelection = true;
      } else
        this.captureSelection = options.captureSelection;
      this.macroArgs = (_a3 = options.args) != null ? _a3 : "";
      this.expand = (_b3 = options.expand) != null ? _b3 : false;
    }
    static fromJson(json, context) {
      return new MacroAtom(json.command, context, json);
    }
    toJson() {
      const options = super.toJson();
      if (this.expand)
        options.expand = true;
      if (this.captureSelection !== void 0)
        options.captureSelection = this.captureSelection;
      if (this.macroArgs)
        options.args = this.macroArgs;
      return options;
    }
    serialize(options) {
      return options.expandMacro && this.expand ? this.bodyToLatex(options) : this.command + this.macroArgs;
    }
    render(context) {
      const result = Atom.createBox(context, this.body);
      if (!result)
        return null;
      if (this.caret)
        result.caret = this.caret;
      return this.bind(context, result);
    }
  };

  // src/core-atoms/prompt.ts
  var PromptAtom = class extends Atom {
    constructor(context, placeholderId, correctness, locked = false, body, options) {
      var _a3;
      super("prompt", context, {
        mode: (_a3 = options == null ? void 0 : options.mode) != null ? _a3 : "math",
        style: options == null ? void 0 : options.style,
        command: "\\placeholder"
      });
      this.body = body;
      this.correctness = correctness;
      this.placeholderId = placeholderId;
      this.locked = locked;
      this.captureSelection = this.locked;
    }
    static fromJson(json, context) {
      return new PromptAtom(
        context,
        json.placeholderId,
        json.correctness,
        json.locked,
        json.body,
        json
      );
    }
    toJson() {
      const result = super.toJson();
      if (this.placeholderId)
        result.placeholderId = this.placeholderId;
      if (!this.body)
        delete result.body;
      if (this.body) {
        result.body = this.body.filter((x) => x.type !== "first").map((x) => x.toJson());
      }
      if (this.correctness)
        result.correctness = this.correctness;
      result.locked = this.locked;
      return result;
    }
    render(parentContext) {
      const context = new Context(parentContext);
      const fboxsep = convertDimensionToEm(
        context.getRegisterAsDimension("fboxsep")
      );
      const padding = fboxsep;
      const content = Atom.createBox(parentContext, this.body);
      if (!content)
        return null;
      if (!content.height)
        content.height = 0.5;
      content.setStyle("vertical-align", -content.height, "em");
      if (this.correctness === "correct") {
        content.setStyle(
          "color",
          "var(--correct-color, var(--ML__correct-color))"
        );
      } else if (this.correctness === "incorrect") {
        content.setStyle(
          "color",
          "var(--incorrect-color, var(--ML__incorrect-color))"
        );
      }
      const base = new Box(content, { type: "mord" });
      let boxClasses = "ML__prompt ";
      if (this.locked) {
        boxClasses += " ML__lockedPromptBox ";
      } else
        boxClasses += " ML__editablePromptBox ";
      if (this.correctness === "correct")
        boxClasses += " ML__correctPromptBox ";
      else if (this.correctness === "incorrect")
        boxClasses += " ML__incorrectPromptBox ";
      if (this.containsCaret)
        boxClasses += " ML__focusedPromptBox ";
      const box = new Box(null, {
        classes: boxClasses
      });
      box.height = base.height + padding;
      box.depth = base.depth + padding;
      box.setStyle("box-sizing", "border-box");
      box.setStyle("position", "absolute");
      box.setStyle("height", base.height + base.depth + 2 * padding, "em");
      if (padding === 0)
        box.setStyle("width", "100%");
      else {
        box.setStyle("width", `calc(100% + ${2 * padding}em)`);
        box.setStyle("top", fboxsep, "em");
        box.setStyle("left", -padding, "em");
      }
      if (!this.body || this.body.length === 1) {
        box.setStyle("width", `calc(100% + ${3 * padding}em)`);
        box.setStyle("left", -1.5 * padding, "em");
      }
      let svg = "";
      if (this.correctness === "incorrect") {
        svg += '<line x1="3%"  y1="97%" x2="97%" y2="3%" stroke-width="0.5" stroke="var(--incorrect-color, var(--ML__incorrect-color))" stroke-linecap="round" />';
      }
      if (svg)
        addSVGOverlay(box, svg, "");
      base.setStyle("display", "inline-block");
      base.setStyle("height", content.height + content.depth, "em");
      base.setStyle("vertical-align", -padding, "em");
      const result = new Box([box, base], { classes: "ML__prompt-atom" });
      result.setStyle("position", "relative");
      result.setStyle("display", "inline-block");
      result.setStyle("line-height", 0);
      result.height = base.height + padding + 0.2;
      result.depth = base.depth + padding;
      result.left = padding;
      result.right = padding;
      result.setStyle("height", base.height + padding, "em");
      result.setStyle("top", base.depth - base.height, "em");
      result.setStyle("vertical-align", base.depth + padding, "em");
      result.setStyle("margin-left", 0.5, "em");
      result.setStyle("margin-right", 0.5, "em");
      if (this.caret)
        result.caret = this.caret;
      return this.bind(
        context,
        this.attachSupsub(parentContext, { base: result })
      );
    }
    serialize(options) {
      var _a3;
      let value = (_a3 = this.bodyToLatex(options)) != null ? _a3 : "";
      if (value === this.context.placeholderSymbol)
        value = "";
      const id = this.placeholderId ? `[${this.placeholderId}]` : "";
      let correctness;
      if (this.correctness === "correct")
        correctness = "[correct]";
      else if (this.correctness === "incorrect")
        correctness = "[incorrect]";
      else
        correctness = "";
      const locked = this.locked ? "[locked]" : "";
      return `\\placeholder${id}${correctness}${locked}{${value}}`;
    }
  };

  // src/core-atoms/placeholder.ts
  var PlaceholderAtom = class extends Atom {
    constructor(context, options) {
      var _a3;
      const value = (options == null ? void 0 : options.value) || context.placeholderSymbol;
      super("placeholder", context, {
        mode: (_a3 = options == null ? void 0 : options.mode) != null ? _a3 : "math",
        style: options == null ? void 0 : options.style,
        value,
        command: "\\placeholder"
      });
      this.captureSelection = true;
    }
    static fromJson(json, context) {
      return new PlaceholderAtom(context, json);
    }
    toJson() {
      const result = super.toJson();
      if (this.value === this.context.placeholderSymbol)
        delete result.value;
      if (this.defaultValue)
        result.defaultValue = this.defaultValue.map((x) => x.toJson());
      return result;
    }
    render(context) {
      if (typeof context.renderPlaceholder === "function")
        return context.renderPlaceholder(context);
      let classes = "";
      if (this.caret)
        classes += "ML__placeholder-selected ";
      if (this.isSelected)
        classes += " ML__selected ";
      return this.createBox(context, { classes });
    }
    serialize(_options) {
      let value = this.value;
      if (value === this.context.placeholderSymbol)
        value = "";
      return `\\placeholder{${this.value}}`;
    }
  };

  // src/core-atoms/spacing.ts
  var SpacingAtom = class extends Atom {
    constructor(command, style, context, width) {
      super("spacing", context, { command, style });
      this.width = width;
    }
    static fromJson(json, context) {
      return new SpacingAtom(json.command, json.style, context, json.width);
    }
    toJson() {
      const options = {};
      if (this.width)
        options.width = this.width;
      return __spreadValues(__spreadValues({}, super.toJson()), options);
    }
    render(context) {
      var _a3;
      let result;
      if (this.width) {
        result = new Box(null, { classes: "mspace" });
        result.left = convertGlueToEm(this.width);
      } else {
        const spacingCls = (_a3 = {
          "\\qquad": "qquad",
          "\\quad": "quad",
          "\\enspace": "enspace",
          "\\;": "thickspace",
          "\\:": "mediumspace",
          "\\,": "thinspace",
          "\\!": "negativethinspace"
        }[this.command]) != null ? _a3 : "mediumspace";
        result = new Box(null, { classes: spacingCls });
      }
      result = this.bind(context, result);
      if (this.caret)
        result.caret = this.caret;
      return result;
    }
    serialize(_options) {
      var _a3;
      let result = (_a3 = this.command) != null ? _a3 : "";
      if (this.command === "\\hspace" || this.command === "\\hspace*") {
        if (Number.isFinite(this.width))
          result += `{${this.width}em'}`;
        else
          result += `{0pt}`;
      } else if (Number.isFinite(this.width))
        result += ` ${this.width}em`;
      return result;
    }
  };

  // src/core-atoms/subsup.ts
  var SubsupAtom = class extends Atom {
    constructor(context, options) {
      super("msubsup", context, { style: options == null ? void 0 : options.style });
    }
    static fromJson(json, context) {
      const result = new SubsupAtom(context, json);
      for (const branch of NAMED_BRANCHES)
        if (json[branch])
          result.setChildren(json[branch], branch);
      return result;
    }
    toJson() {
      return super.toJson();
    }
    render(context) {
      var _a3;
      console.assert(!this.subsupPlacement);
      const leftSibling = this.leftSibling;
      const phantomContex = new Context(context, { isPhantom: true });
      const base = (_a3 = leftSibling.render(phantomContex)) != null ? _a3 : new Box(null);
      const phantom = new Box(null, { height: base.height, depth: base.depth });
      return this.attachSupsub(context, {
        base: phantom,
        isCharacterBox: leftSibling.isCharacterBox(),
        // Set to 'supsub' so that it is skipped when walking the
        // atom to adjust for spacing.
        type: "supsub"
      });
    }
    serialize(options) {
      return this.supsubToLatex(options);
    }
  };

  // src/core-atoms/text.ts
  var TextAtom = class extends Atom {
    constructor(command, value, style, context) {
      super("text", context, {
        command,
        mode: "text",
        displayContainsHighlight: true
      });
      this.value = value;
      this.verbatimLatex = value;
      this.applyStyle(style);
    }
    static fromJson(json, context) {
      return new TextAtom(json.command, json.value, json.style, context);
    }
    toJson() {
      return super.toJson();
    }
    render(context) {
      const result = this.createBox(context);
      if (this.caret)
        result.caret = this.caret;
      return result;
    }
    serialize(_options) {
      var _a3;
      return (_a3 = this.verbatimLatex) != null ? _a3 : charToLatex("text", this.value.codePointAt(0));
    }
  };

  // src/core/parser.ts
  function isLiteral(token) {
    return !/^<({|}|\$|\$\$|space)>$/.test(token);
  }
  var Parser = class {
    /**
     * @param tokens - An array of tokens generated by the lexer.
     *
     * Note: smartFence and registers are usually defined by the GloablContext.
     * However, in some cases they need to be overridden.
     *
     */
    constructor(tokens, context, options) {
      // The current token to be parsed: index in `this.tokens`
      this.index = 0;
      // Counter to prevent deadlock. If `end()` is called too many times (1,000)
      // in a row for the same token, bail.
      this.endCount = 0;
      var _a3, _b3, _c2, _d2, _e;
      this.tokens = tokens;
      this.context = context;
      this.errors = [];
      this.args = (_a3 = options.args) != null ? _a3 : null;
      this.smartFence = (_b3 = options.smartFence) != null ? _b3 : context.smartFence;
      this._currentParsingContext = {
        parent: void 0,
        mathlist: [],
        style: (_c2 = options.style) != null ? _c2 : {},
        parseMode: (_d2 = options.parseMode) != null ? _d2 : "math",
        mathstyle: (_e = options.mathstyle) != null ? _e : "displaystyle",
        registers: context.registers,
        tabular: false
      };
    }
    get currentContext() {
      return this._currentParsingContext;
    }
    get rootContext() {
      let context = this._currentParsingContext;
      while (context.parent)
        context = context.parent;
      return context;
    }
    beginContext(options) {
      var _a3, _b3, _c2;
      const newContext = {
        parent: this.currentContext,
        mathlist: [],
        style: __spreadValues({}, this.currentContext.style),
        parseMode: (_a3 = options == null ? void 0 : options.mode) != null ? _a3 : this.currentContext.parseMode,
        mathstyle: (_b3 = options == null ? void 0 : options.mathstyle) != null ? _b3 : this.currentContext.mathstyle,
        registers: null,
        tabular: (_c2 = options == null ? void 0 : options.tabular) != null ? _c2 : false
      };
      this._currentParsingContext = newContext;
    }
    endContext() {
      this._currentParsingContext = this._currentParsingContext.parent;
    }
    onError(err) {
      this.errors.push(__spreadValues({
        before: tokensToString(this.tokens.slice(this.index, this.index + 10)),
        after: tokensToString(
          this.tokens.slice(Math.max(0, this.index - 10), this.index)
        )
      }, err));
    }
    get mathlist() {
      return this.currentContext.mathlist;
    }
    set mathlist(value) {
      this.currentContext.mathlist = value;
    }
    get parseMode() {
      return this.currentContext.parseMode;
    }
    // @revisit
    set parseMode(value) {
      this.currentContext.parseMode = value;
    }
    get tabularMode() {
      return this.currentContext.tabular;
    }
    get style() {
      let context = this.currentContext;
      while (context) {
        if (context.style)
          return context.style;
        context = context.parent;
      }
      return {};
    }
    // @revisit
    set style(value) {
      this.currentContext.style = value;
    }
    getRegister(name) {
      var _a3, _b3, _c2;
      console.assert(name[0] !== "\\");
      if (name.startsWith("global "))
        return (_b3 = (_a3 = this.rootContext.registers) == null ? void 0 : _a3[name.slice(7)]) != null ? _b3 : 0;
      let context = this.currentContext;
      while (context) {
        if ((_c2 = context.registers) == null ? void 0 : _c2[name])
          return context.registers[name];
        context = context.parent;
      }
      return 0;
    }
    setRegister(name, value) {
      var _a3;
      if (name.startsWith("global ")) {
        name = name.slice(7);
        let context = this.currentContext;
        while (context) {
          if ((_a3 = context.registers) == null ? void 0 : _a3[name])
            delete context.registers[name];
          context = context.parent;
        }
        this.rootContext.registers[name] = value;
        return;
      }
      if (!this.currentContext.registers)
        this.currentContext.registers = {};
      this.currentContext.registers[name] = value;
    }
    /**
     * True if we've reached the end of the token stream
     */
    end() {
      this.endCount++;
      return this.index >= this.tokens.length || this.endCount > 1e3;
    }
    get() {
      this.endCount = 0;
      return this.index < this.tokens.length ? this.tokens[this.index++] : "";
    }
    peek() {
      return this.tokens[this.index];
    }
    /**
     * @return True if the next token matches the input, and advance
     */
    match(input) {
      if (this.tokens[this.index] === input) {
        this.index++;
        return true;
      }
      return false;
    }
    /**
     * Return the last atom that can have a subscript/superscript attached to it.
     * If there isn't one, insert a `SubsupAtom` and return it.
     */
    lastSubsupAtom() {
      let atom;
      if (this.mathlist.length > 0) {
        atom = this.mathlist[this.mathlist.length - 1];
        if (atom.type === "msubsup")
          return atom;
        if (atom.subsupPlacement !== void 0)
          return atom;
      }
      atom = new SubsupAtom(this.context, { style: this.style });
      this.mathlist.push(atom);
      return atom;
    }
    /**
     * @return True if the next token matches the specified regular expression pattern.
     */
    hasPattern(pattern) {
      return pattern.test(this.tokens[this.index]);
    }
    hasInfixCommand() {
      var _a3;
      const { index } = this;
      if (index < this.tokens.length && this.tokens[index].startsWith("\\")) {
        const info = this.context.getDefinition(
          this.tokens[index],
          this.parseMode
        );
        if (!info || info.definitionType === "symbol")
          return false;
        if (info.ifMode && !info.ifMode.includes(this.parseMode))
          return false;
        return (_a3 = info.infix) != null ? _a3 : false;
      }
      return false;
    }
    matchColumnSeparator() {
      const { index } = this;
      if (this.tabularMode && this.tokens[index] === "&") {
        this.index++;
        return true;
      }
      return false;
    }
    matchRowSeparator() {
      const { index } = this;
      if (this.tabularMode && (this.tokens[index] === "\\\\" || this.tokens[index] === "\\cr")) {
        this.index++;
        return true;
      }
      return false;
    }
    /**
     * Return the appropriate value for a placeholder, either a default
     * one, or if a value was provided for #? via args, that value.
     */
    placeholder() {
      var _a3;
      const placeHolderArg = (_a3 = this.args) == null ? void 0 : _a3.call(this, "?");
      if (!placeHolderArg) {
        return [
          new PlaceholderAtom(this.context, {
            mode: this.parseMode,
            style: this.style
          })
        ];
      }
      return parseLatex(placeHolderArg, this.context, {
        parseMode: this.parseMode,
        mathstyle: "textstyle"
      });
    }
    matchWhitespace() {
      let found = false;
      while (this.match("<space>"))
        found = true;
      return found;
    }
    skipUntilToken(input) {
      let token = this.tokens[this.index];
      while (token && token !== input)
        token = this.tokens[++this.index];
      if (token === input)
        this.index++;
    }
    skipFiller() {
      let done = false;
      do {
        const skippedSpace = this.matchWhitespace();
        const skippedRelax = this.match("\\relax");
        done = !skippedSpace && !skippedRelax;
      } while (!done);
    }
    /**
     * Keywords are used to specify dimensions, and for various other
     * syntactic constructs.
     *
     * Unlike commands, they are not case sensitive.
     *
     * There are 25 keywords:
     *
     * at by bp cc cm dd depth em ex fil fill filll height in minus
     * mm mu pc plus pt sp spread to true width
     *
     * TeX: 8212
     * @return true if the expected keyword is present
     */
    matchKeyword(keyword) {
      const savedIndex = this.index;
      let done = this.end();
      let value = "";
      while (!done) {
        const token = this.get();
        if (isLiteral(token)) {
          value += token;
          done = this.end() || value.length >= keyword.length;
        } else
          done = true;
      }
      const hasKeyword = keyword.toUpperCase() === value.toUpperCase();
      if (!hasKeyword)
        this.index = savedIndex;
      return hasKeyword;
    }
    /**
     * Return a sequence of characters as a string.
     * i.e. 'abcd' returns 'abcd'.
     * Terminates on the first non-literal token encountered
     * e.g. '<{>', '<}>' etc...
     * Will also terminate on character literal ']'
     */
    scanString() {
      let result = "";
      while (!this.end()) {
        if (this.match("<space>"))
          result += " ";
        else {
          const token = this.peek();
          if (token === "]")
            break;
          if (isLiteral(token))
            result += this.get();
          else if (token.startsWith("\\")) {
            this.onError({ code: "unbalanced-braces" });
            result += this.get();
          } else {
            break;
          }
        }
      }
      return result;
    }
    /**
     * Return a sequence of characters as a string.
     * Terminates on a balanced closing bracket
     * This is used by the `\ce` command
     */
    scanBalancedString() {
      let result = "";
      let done = this.end();
      let level = 1;
      while (!done) {
        if (this.match("<space>"))
          result += " ";
        else {
          const token = this.get();
          if (token === "<{>") {
            result += "{";
            level += 1;
          } else if (token === "<}>") {
            level -= 1;
            if (level > 0)
              result += "}";
            else
              this.index -= 1;
          } else if (token === "<$>")
            result += "$";
          else if (token === "<$$>")
            result += "$$";
          else
            result += token;
        }
        done = level === 0 || this.end();
      }
      return result;
    }
    /**
     * Return the literal tokens, as a string, until a matching closing "}"
     */
    matchLiteralArg() {
      var _a3;
      let result = "";
      if (this.match("<{>")) {
        let depth = 1;
        while (depth > 0 && !this.end()) {
          const token = this.get();
          if (token === "<}>") {
            depth -= 1;
            if (depth > 0) {
              result += "}";
            }
          } else if (token === "<{>") {
            depth += 1;
            result += "{";
          } else {
            result += (_a3 = {
              "<space>": " ",
              "<$$>": "$$",
              "<$>": "$"
            }[token]) != null ? _a3 : token;
          }
        }
      }
      return result;
    }
    /**
     * Return as a number a group of characters representing a
     * numerical quantity.
     *
     * From TeX:8695 (scan_int):
     * > An integer number can be preceded by any number of spaces and `+' or
     * > `-' signs. Then comes either a decimal constant (i.e., radix 10), an
     * > octal constant (i.e., radix 8, preceded by '), a hexadecimal constant
     * > (radix 16, preceded by "), an alphabetic constant (preceded by `), or
     * > an internal variable.
     */
    scanNumber(isInteger = true) {
      var _a3, _b3;
      let negative = false;
      let token = this.peek();
      while (token === "<space>" || token === "+" || token === "-") {
        this.get();
        if (token === "-")
          negative = !negative;
        token = this.peek();
      }
      isInteger = Boolean(isInteger);
      let radix = 10;
      let digits = /\d/;
      if (this.match("'")) {
        radix = 8;
        digits = /[0-7]/;
        isInteger = true;
      } else if (this.match('"') || this.match("x")) {
        radix = 16;
        digits = /[\dA-F]/;
        isInteger = true;
      } else if (this.match("`")) {
        token = this.get();
        if (token) {
          if (token.startsWith("\\") && token.length === 2)
            return (negative ? -1 : 1) * ((_a3 = token.codePointAt(1)) != null ? _a3 : 0);
          return (negative ? -1 : 1) * ((_b3 = token.codePointAt(0)) != null ? _b3 : 0);
        }
        return null;
      }
      let value = "";
      while (this.hasPattern(digits))
        value += this.get();
      if (!isInteger && (this.match(".") || this.match(","))) {
        value += ".";
        while (this.hasPattern(digits))
          value += this.get();
      }
      const result = isInteger ? Number.parseInt(value, radix) : Number.parseFloat(value);
      if (Number.isNaN(result))
        return null;
      return negative ? -result : result;
    }
    /**
     * Return a dimension
     *
     * See TeX:8831
     */
    scanDimen() {
      var _a3, _b3, _c2;
      let value = this.scanNumber(false);
      if (value === null) {
        if ((_a3 = this.peek()) == null ? void 0 : _a3.startsWith("\\"))
          value = 1;
        else
          return null;
      }
      this.matchWhitespace();
      let result;
      if (this.matchKeyword("pt"))
        result = { dimension: value, unit: "pt" };
      else if (this.matchKeyword("mm"))
        result = { dimension: value, unit: "mm" };
      else if (this.matchKeyword("cm"))
        result = { dimension: value, unit: "cm" };
      else if (this.matchKeyword("ex"))
        result = { dimension: value, unit: "ex" };
      else if (this.matchKeyword("px"))
        result = { dimension: value, unit: "px" };
      else if (this.matchKeyword("em"))
        result = { dimension: value, unit: "em" };
      else if (this.matchKeyword("bp"))
        result = { dimension: value, unit: "bp" };
      else if (this.matchKeyword("dd"))
        result = { dimension: value, unit: "dd" };
      else if (this.matchKeyword("pc"))
        result = { dimension: value, unit: "pc" };
      else if (this.matchKeyword("in"))
        result = { dimension: value, unit: "in" };
      else if (this.matchKeyword("mu"))
        result = { dimension: value, unit: "mu" };
      else {
        if ((_b3 = this.peek()) == null ? void 0 : _b3.startsWith("\\")) {
          result = (_c2 = convertToDimension(
            this.getRegister(this.get().slice(1)),
            this.context
          )) != null ? _c2 : { dimension: 0 };
          result.dimension *= value;
        } else {
          if (!this.match("\\relax")) {
            this.onError({ code: "missing-unit" });
          }
          result = { dimension: value, unit: "pt" };
        }
      }
      return result;
    }
    scanGlue() {
      const dimen = this.scanDimen();
      if (dimen === null)
        return null;
      const result = { glue: dimen };
      this.matchWhitespace();
      if (this.match("\\relax"))
        return result;
      if (this.matchKeyword("plus")) {
        this.scanDimen();
      }
      this.matchWhitespace();
      if (this.match("\\relax"))
        return result;
      this.matchWhitespace();
      if (this.matchKeyword("minus")) {
        this.scanDimen();
      }
      return result;
    }
    scanColspec() {
      this.matchWhitespace();
      const result = [];
      while (!this.end() && !(this.peek() === "<}>" || this.peek() === "]")) {
        const literal = this.get();
        if (literal === "c" || literal === "r" || literal === "l")
          result.push({ align: literal });
        else if (literal === "|")
          result.push({ separator: "solid" });
        else if (literal === ":")
          result.push({ separator: "dashed" });
        else if (literal === "@") {
          if (this.match("<{>")) {
            this.beginContext({ mode: "math" });
            result.push({
              gap: this.parse((token) => token === "<}>")
            });
            this.endContext();
          }
          if (!this.match("<}>"))
            this.onError({ code: "unbalanced-braces" });
        }
      }
      return result;
    }
    /**
     * Parse a `\(...\)` or `\[...\]` sequence
     * @return group for the sequence or null
     */
    parseModeSet() {
      let final = "";
      if (this.match("\\("))
        final = "\\)";
      if (!final && this.match("\\["))
        final = "\\]";
      if (!final)
        return null;
      this.beginContext({
        mode: "math",
        mathstyle: final === "\\)" ? "textstyle" : "displaystyle"
      });
      const result = new GroupAtom(
        this.parse((token) => token === final),
        this.context,
        {
          mathstyleName: final === "\\)" ? "textstyle" : "displaystyle",
          latexOpen: final === "\\]" ? "\\[" : "\\(",
          latexClose: final,
          boxType: "mord"
        }
      );
      if (!this.match(final))
        this.onError({ code: "unbalanced-mode-shift" });
      this.endContext();
      if (result.hasEmptyBranch("body"))
        return null;
      return result;
    }
    /**
     * Parse a `$...$` or `$$...$$` sequence
     */
    parseModeShift() {
      let final = "";
      if (this.match("<$>"))
        final = "<$>";
      if (!final && this.match("<$$>"))
        final = "<$$>";
      if (!final)
        return null;
      this.beginContext({
        mode: "math",
        mathstyle: "<$>" ? "textstyle" : "displaystyle"
      });
      const result = new GroupAtom(
        this.parse((token) => token === final),
        this.context,
        {
          mathstyleName: final === "<$>" ? "textstyle" : "displaystyle",
          latexOpen: final === "<$>" ? "$ " : "$$ ",
          latexClose: final === "<$>" ? " $" : " $$"
        }
      );
      if (!this.match(final))
        this.onError({ code: "unbalanced-mode-shift" });
      this.endContext();
      if (result.hasEmptyBranch("body"))
        return null;
      return result;
    }
    /**
     * Parse a \begin{env}...\end{end} sequence
     */
    parseEnvironment() {
      if (!this.match("\\begin"))
        return null;
      const envName = this.parseArgument("string");
      if (!envName)
        return null;
      const def = getEnvironmentDefinition(envName);
      if (!def) {
        this.onError({
          code: "unknown-environment",
          arg: envName
        });
        return null;
      }
      const args = [];
      if (def.params) {
        for (const parameter of def.params) {
          if (parameter.isOptional) {
            args.push(this.parseOptionalArgument(parameter.type));
          } else {
            const arg = this.parseArgument(parameter.type);
            if (!arg) {
              this.onError({
                code: "missing-argument",
                arg: envName
              });
            }
            args.push(arg);
          }
        }
      }
      this.beginContext({ tabular: def.tabular });
      const array = [];
      const rowGaps = [];
      let row = [];
      let done = false;
      do {
        if (this.end()) {
          this.onError({ code: "unbalanced-environment", arg: envName });
          done = true;
        }
        if (!done && this.match("\\end")) {
          if (this.parseArgument("string") !== envName) {
            this.onError({
              code: "unbalanced-environment",
              arg: envName
            });
          }
          done = true;
        }
        if (!done) {
          if (this.matchColumnSeparator()) {
            row.push(this.mathlist);
            this.mathlist = [];
          } else if (this.matchRowSeparator()) {
            row.push(this.mathlist);
            this.mathlist = [];
            let gap = null;
            this.matchWhitespace();
            if (this.match("[")) {
              gap = this.scanDimen();
              this.matchWhitespace();
              this.match("]");
            }
            rowGaps.push(gap != null ? gap : { dimension: 0 });
            array.push(row);
            row = [];
          } else {
            this.mathlist.push(
              ...this.parse(
                (token) => token === "<}>" || token === "&" || token === "\\end" || token === "\\cr" || token === "\\\\"
              )
            );
          }
        }
      } while (!done);
      row.push(this.mathlist);
      if (row.length > 0)
        array.push(row);
      this.endContext();
      return def.createAtom(this.context, envName, array, rowGaps, args);
    }
    /**
     * Parse a sequence until a group end marker, such as
     * `}`, `\end`, `&`, etc...
     *
     * Returns an array of atoms or an empty array if the sequence
     * terminates right away.
     *
     * @param done - A predicate indicating if a
     * token signals the end of an implicit group
     */
    parse(done) {
      this.beginContext();
      if (!done)
        done = (token) => token === "<}>";
      let infix = "";
      let infixInfo = null;
      let infixArgs = [];
      let prefix = null;
      const saveAtoms = this.mathlist;
      this.mathlist = [];
      while (!this.end() && !done(this.peek())) {
        if (this.hasInfixCommand() && !infix) {
          infix = this.get();
          infixInfo = this.context.getDefinition(
            infix,
            "math"
          );
          if (infixInfo)
            infixArgs = this.parseArguments(infixInfo)[1];
          prefix = this.mathlist;
          this.mathlist = [];
        } else
          this.parseToken();
      }
      let result;
      if (infix) {
        console.assert(Boolean(infixInfo));
        infixArgs.unshift(this.mathlist);
        this.mathlist = saveAtoms;
        if (prefix)
          infixArgs.unshift(prefix);
        result = [
          infixInfo.createAtom(infix, infixArgs, this.style, this.context)
        ];
      } else {
        result = this.mathlist;
        this.mathlist = saveAtoms;
      }
      this.endContext();
      return result;
    }
    /**
     * Parse a group enclosed in a pair of braces: `{...}`.
     *
     * Return either a group Atom or null if not a group.
     *
     * Return a group Atom with an empty body if an empty
     * group (i.e. `{}`).
     */
    parseGroup() {
      if (!this.match("<{>"))
        return null;
      const result = new GroupAtom(
        this.parse((token) => token === "<}>"),
        this.context,
        {
          mode: this.parseMode,
          latexOpen: "{",
          latexClose: "}"
        }
      );
      if (!this.match("<}>"))
        this.onError({ code: "unbalanced-braces" });
      return result;
    }
    scanSmartFence() {
      this.matchWhitespace();
      if (!this.match("("))
        return null;
      this.beginContext();
      let nestLevel = 1;
      while (!this.end() && nestLevel !== 0) {
        if (this.match("("))
          nestLevel += 1;
        if (this.match(")"))
          nestLevel -= 1;
        if (nestLevel !== 0)
          this.parseToken();
      }
      if (nestLevel === 0)
        this.match(")");
      const result = new LeftRightAtom("", this.mathlist, this.context, {
        leftDelim: "(",
        rightDelim: nestLevel === 0 ? ")" : "?"
      });
      this.endContext();
      return result;
    }
    /**
     * Scan a delimiter, e.g. '(', '|', '\vert', '\ulcorner'
     *
     * @return The delimiter (as a character or command) or null
     */
    scanDelim() {
      this.matchWhitespace();
      const token = this.get();
      if (!token) {
        this.onError({ code: "unexpected-end-of-string" });
        return null;
      }
      let delim = ".";
      if (token.startsWith("\\") || isLiteral(token))
        delim = token;
      const info = this.context.getDefinition(delim, "math");
      if (!info) {
        this.onError({ code: "unknown-command", arg: delim });
        return null;
      }
      if (info.definitionType === "function" && info.ifMode && !info.ifMode.includes(this.parseMode)) {
        this.onError({ code: "unexpected-delimiter", arg: delim });
        return null;
      }
      if (info.definitionType === "symbol" && (info.type === "mopen" || info.type === "mclose"))
        return delim;
      if (/^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(
        delim
      ))
        return delim;
      this.onError({ code: "unexpected-delimiter", arg: delim });
      return null;
    }
    /**
     * Parse a `/left.../right` sequence.
     *
     * Note: the `/middle` command can occur multiple times inside a
     * `/left.../right` sequence, and is handled separately.
     *
     * Return either an atom of type `"leftright"` or null
     */
    parseLeftRight() {
      var _a3;
      if (this.match("\\right") || this.match("\\mright")) {
        this.onError({ code: "unbalanced-braces" });
        return null;
      }
      let close = "\\right";
      if (!this.match("\\left")) {
        if (!this.match("\\mleft"))
          return null;
        close = "\\mright";
      }
      const leftDelim = this.scanDelim();
      if (!leftDelim)
        return null;
      this.beginContext();
      while (!this.end() && !this.match(close))
        this.parseToken();
      const body = this.mathlist;
      this.endContext();
      const rightDelim = (_a3 = this.scanDelim()) != null ? _a3 : ".";
      return new LeftRightAtom(
        close === "\\right" ? "left...right" : "mleft...mright",
        body,
        this.context,
        {
          leftDelim,
          rightDelim,
          style: this.style
        }
      );
    }
    /**
     * Parse a subscript/superscript: `^` and `_`.
     *
     * Modify the last atom accordingly, or create a new 'msubsup' carrier.
     *
     */
    parseSupSub() {
      if (this.parseMode !== "math")
        return false;
      let token = this.peek();
      if (token !== "^" && token !== "_" && token !== "'")
        return false;
      while (token === "^" || token === "_" || token === "'") {
        if (this.match("'")) {
          if (this.match("'")) {
            this.lastSubsupAtom().addChild(
              new Atom("mord", this.context, {
                command: "\\doubleprime",
                mode: "math",
                value: "\u2032\u2032"
                // "\u2033" displays too high
              }),
              "superscript"
            );
          } else {
            this.lastSubsupAtom().addChild(
              new Atom("mord", this.context, {
                command: "\\prime",
                mode: "math",
                value: "\u2032"
              }),
              "superscript"
            );
          }
        } else if (this.match("^") || this.match("_")) {
          const arg = this.parseArgument("math");
          if (arg) {
            this.lastSubsupAtom().addChildren(
              arg,
              token === "_" ? "subscript" : "superscript"
            );
          } else {
            this.lastSubsupAtom().createBranch(
              token === "_" ? "subscript" : "superscript"
            );
          }
        }
        token = this.peek();
      }
      return true;
    }
    /**
     * Parse a `\limits` or `\nolimits` command.
     *
     * This will change the placement of limits to be either above or below
     * (if `\limits`) or in the superscript/subscript position (if `\nolimits`).
     *
     * This overrides the calculation made for the placement, which is usually
     * dependent on the displaystyle (`textstyle` prefers `\nolimits`, while
     * `displaystyle` prefers `\limits`).
     */
    parseLimits() {
      const isLimits = this.match("\\limits");
      const isNoLimits = !isLimits && this.match("\\nolimits");
      const isDisplayLimits = !isNoLimits && !isLimits && this.match("\\displaylimits");
      if (!isLimits && !isNoLimits && !isDisplayLimits)
        return false;
      const opAtom = this.mathlist.length > 0 ? this.mathlist[this.mathlist.length - 1] : null;
      if (opAtom === null || opAtom.type !== "mop")
        return false;
      if (isLimits) {
        opAtom.subsupPlacement = "over-under";
        opAtom.explicitSubsupPlacement = true;
        return true;
      }
      if (isNoLimits) {
        opAtom.subsupPlacement = "adjacent";
        opAtom.explicitSubsupPlacement = true;
        return true;
      }
      if (isDisplayLimits) {
        opAtom.subsupPlacement = "auto";
        opAtom.explicitSubsupPlacement = true;
        return true;
      }
      return false;
    }
    parseArguments(info) {
      if (!(info == null ? void 0 : info.params))
        return [void 0, []];
      let explicitGroup = void 0;
      const args = [];
      let i = info.infix ? 2 : 0;
      while (i < info.params.length) {
        const parameter = info.params[i];
        if (parameter.type === "rest") {
          args.push(
            this.parse(
              (token) => token === "<}>" || token === "&" || token === "\\end" || token === "\\cr" || token === "\\\\"
            )
          );
        } else if (parameter.isOptional)
          args.push(this.parseOptionalArgument(parameter.type));
        else if (parameter.type.endsWith("*")) {
          explicitGroup = parameter.type.slice(0, -1);
        } else {
          const arg = this.parseArgument(parameter.type);
          if (arg !== null)
            args.push(arg);
          else {
            this.onError({ code: "missing-argument" });
            switch (parameter.type) {
              case "number":
                args.push(0);
                break;
              case "dimen":
                args.push({ dimension: 0, unit: "pt" });
                break;
              case "glue":
                args.push({ glue: { dimension: 0, unit: "pt" } });
                break;
              case "string":
              case "balanced-string":
                args.push("");
                break;
              case "delim":
                args.push(".");
                break;
              case "colspec":
                args.push("llllllllll");
                break;
              case "auto":
              default:
                args.push(this.placeholder());
                break;
            }
          }
        }
        i += 1;
      }
      return [explicitGroup, args];
    }
    parseArgument(argType) {
      var _a3, _b3;
      this.skipFiller();
      if (argType === "auto")
        argType = this.parseMode;
      let result = null;
      const hasBrace = this.peek() === "<{>";
      if (!hasBrace) {
        if (argType === "delim")
          return (_a3 = this.scanDelim()) != null ? _a3 : ".";
        if (argType === "text" || argType === "math") {
          this.beginContext();
          const atom = this.parseSimpleToken();
          this.endContext();
          return atom;
        }
      }
      if (hasBrace)
        this.get();
      if (argType === "text" || argType === "math") {
        this.beginContext({ mode: argType });
        do
          this.mathlist.push(...this.parse());
        while (!this.match("<}>") && !this.end());
      } else {
        this.beginContext();
        if (argType === "string")
          result = this.scanString();
        else if (argType === "balanced-string")
          result = this.scanBalancedString();
        else if (argType === "number")
          result = this.scanNumber();
        else if (argType === "colspec")
          result = this.scanColspec();
        else if (argType === "dimen")
          result = this.scanDimen();
        else if (argType === "glue")
          result = this.scanGlue();
        else if (argType === "delim")
          result = (_b3 = this.scanDelim()) != null ? _b3 : ".";
        if (hasBrace)
          this.skipUntilToken("<}>");
        if (result === null) {
          this.endContext();
          return null;
        }
      }
      const atoms = this.mathlist;
      this.endContext();
      return result != null ? result : atoms;
    }
    parseOptionalArgument(argType) {
      var _a3, _b3;
      argType = argType === "auto" ? this.parseMode : argType;
      this.matchWhitespace();
      if (!this.match("["))
        return null;
      let result = null;
      while (!this.end() && !this.match("]")) {
        if (argType === "string")
          result = this.scanString();
        else if (argType === "number")
          result = this.scanNumber();
        else if (argType === "dimen")
          result = this.scanDimen();
        else if (argType === "glue")
          result = this.scanGlue();
        else if (argType === "colspec")
          result = this.scanColspec();
        else if (argType === "bbox") {
          const list = this.scanString().toLowerCase().trim().split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
          const bboxParameter = {};
          for (const element of list) {
            const color = (_b3 = (_a3 = this.context).backgroundColorMap) == null ? void 0 : _b3.call(_a3, element);
            if (color)
              bboxParameter.backgroundcolor = color;
            else {
              const m = element.match(/^\s*([\d.]+)\s*([a-z]{2})/);
              if (m)
                bboxParameter.padding = m[0];
              else {
                const m2 = element.match(/^\s*border\s*:\s*(.*)/);
                if (m2)
                  bboxParameter.border = m2[1];
              }
            }
          }
          result = bboxParameter;
        } else if (argType === "math") {
          this.beginContext({ mode: "math" });
          result = this.mathlist.concat(this.parse((token) => token === "]"));
          this.endContext();
        }
      }
      return result;
    }
    parseCommand(command) {
      var _a3, _b3, _c2, _d2, _e, _f;
      if (command === "\\placeholder") {
        const id = this.parseOptionalArgument("string");
        const defaultValue = this.parseOptionalArgument("math");
        const defaultAsString = serializeAtoms(defaultValue, {
          defaultMode: "math"
        });
        let defaultAtoms = [];
        let correctness;
        if (!correctness && defaultAsString === "correct")
          correctness = "correct";
        else if (!correctness && defaultAsString === "incorrect")
          correctness = "incorrect";
        else if (defaultAsString !== "")
          defaultAtoms = defaultValue;
        const locked = this.parseOptionalArgument("string") === "locked";
        const value = this.parseArgument("auto");
        let body;
        if (value && value.length > 0)
          body = value;
        else
          body = defaultAtoms;
        if (id) {
          return [
            new PromptAtom(
              this.context,
              id,
              correctness,
              // locked,
              locked,
              body != null ? body : defaultAtoms,
              {
                mode: this.parseMode,
                style: this.style
              }
            )
          ];
        }
        return [
          new PlaceholderAtom(this.context, {
            mode: this.parseMode,
            placeholderId: id,
            style: this.style
          })
        ];
      }
      let result = null;
      if (command === "\\char") {
        const initialIndex2 = this.index;
        let codepoint = Math.floor((_a3 = this.scanNumber(true)) != null ? _a3 : Number.NaN);
        if (!Number.isFinite(codepoint) || codepoint < 0 || codepoint > 1114111)
          codepoint = 10067;
        const verbatimLatex = "\\char" + tokensToString(this.tokens.slice(initialIndex2, this.index));
        result = new Atom(
          this.parseMode === "math" ? "mord" : "text",
          this.context,
          {
            command: "\\char",
            mode: this.parseMode,
            value: String.fromCodePoint(codepoint),
            serialize: (atom) => {
              var _a4;
              return (_a4 = atom.verbatimLatex) != null ? _a4 : `\\char"${atom.value.codePointAt(0).toString(16).toUpperCase()}`;
            }
          }
        );
        result.verbatimLatex = verbatimLatex;
        return [result];
      }
      if (command === "\\hskip" || command === "\\kern") {
        const width = this.scanGlue();
        if (!width)
          return null;
        return [new SpacingAtom(command, this.style, this.context, width)];
      }
      result = this.scanMacro(command);
      if (result)
        return [result];
      const info = this.context.getDefinition(command, this.parseMode);
      if (!info) {
        this.onError({ code: "unknown-command", arg: command });
        return [new ErrorAtom(command, this.context)];
      }
      const initialIndex = this.index;
      if (info.definitionType === "symbol") {
        const style = __spreadValues({}, this.style);
        if (info.variant)
          style.variant = info.variant;
        result = new Atom((_b3 = info.type) != null ? _b3 : "mop", this.context, {
          command,
          style,
          value: String.fromCodePoint(info.codepoint),
          mode: this.parseMode
        });
      } else {
        if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
          return [];
        }
        const savedMode = this.parseMode;
        if (info.applyMode)
          this.parseMode = info.applyMode;
        const [deferredArg, args] = this.parseArguments(info);
        this.parseMode = savedMode;
        if (!args)
          return null;
        if (info.applyMode && !info.applyStyle && !info.createAtom)
          return args[0];
        if (info.infix) {
          this.onError({
            code: "too-many-infix-commands",
            arg: command
          });
          return null;
        }
        if (typeof info.createAtom === "function") {
          result = info.createAtom(command, args, this.style, this.context);
          if (deferredArg)
            result.body = (_c2 = this.parseArgument(deferredArg)) != null ? _c2 : void 0;
        } else if (typeof info.applyStyle === "function") {
          const style = info.applyStyle(command, args, this.context);
          const savedMode2 = this.parseMode;
          if (info.applyMode) {
            this.parseMode = info.applyMode;
          }
          if (deferredArg) {
            const saveStyle = this.style;
            this.style = __spreadValues(__spreadValues({}, this.style), style);
            const atoms = this.parseArgument(deferredArg);
            this.style = saveStyle;
            this.parseMode = savedMode2;
            return atoms;
          }
          this.style = __spreadValues(__spreadValues({}, this.style), style);
          this.parseMode = savedMode2;
        } else {
          result = new Atom("mop", this.context, {
            command: (_d2 = info.command) != null ? _d2 : command,
            style: __spreadValues({}, this.style),
            value: command,
            mode: (_e = info.applyMode) != null ? _e : this.parseMode
          });
        }
      }
      if (result instanceof Atom && result.verbatimLatex === void 0 && !/^\\(llap|rlap|class|cssId|htmlData)$/.test(command)) {
        result.verbatimLatex = ((_f = result.command) != null ? _f : "") + tokensToString(this.tokens.slice(initialIndex, this.index));
        if (result.verbatimLatex.length === 0)
          result.verbatimLatex = void 0;
        if (result.isFunction && this.smartFence) {
          const smartFence = this.scanSmartFence();
          if (smartFence)
            return [result, smartFence];
        }
      }
      return result ? [result] : null;
    }
    parseLiteral(literal) {
      const result = Mode.createAtom(this.parseMode, literal, this.context, __spreadValues({}, this.style));
      if (!result)
        return null;
      if (result.isFunction && this.smartFence) {
        const smartFence = this.scanSmartFence();
        if (smartFence)
          return [result, smartFence];
      }
      return [result];
    }
    parseSimpleToken() {
      const token = this.get();
      if (!token)
        return null;
      if (token === "<space>") {
        if (this.parseMode === "text")
          return [new TextAtom(" ", " ", this.style, this.context)];
        return null;
      }
      if (token.startsWith("\\"))
        return this.parseCommand(token);
      if (isLiteral(token))
        return this.parseLiteral(token);
      if (token === "<}>")
        this.onError({ latex: "", code: "unbalanced-braces" });
      else {
        this.onError({
          latex: "",
          code: "unexpected-token",
          arg: token
        });
      }
      return null;
    }
    /**
     * Attempt to scan the macro name and return an atom list if successful.
     * Otherwise, it wasn't a macro.
     */
    scanMacro(macro) {
      var _a3;
      const def = this.context.getMacro(macro);
      if (!def)
        return null;
      const initialIndex = this.index;
      const argCount = def.args;
      const args = { "?": (_a3 = this.args) == null ? void 0 : _a3.call(this, "?") };
      for (let i = 1; i <= argCount; i++)
        args[i] = this.matchLiteralArg();
      return new MacroAtom(macro, this.context, {
        expand: def.expand,
        captureSelection: def.captureSelection,
        args: tokensToString(this.tokens.slice(initialIndex, this.index)),
        body: parseLatex(def.def, this.context, {
          parseMode: this.parseMode,
          args: (arg) => args[arg],
          mathstyle: this.currentContext.mathstyle
        })
      });
    }
    /**
     * Make an atom for the current token or token group and
     * add it to the parser's mathlist
     */
    parseToken() {
      var _a3, _b3, _c2, _d2;
      let result = (_d2 = (_c2 = (_b3 = (_a3 = this.parseEnvironment()) != null ? _a3 : this.parseModeShift()) != null ? _b3 : this.parseModeSet()) != null ? _c2 : this.parseGroup()) != null ? _d2 : this.parseLeftRight();
      if (result === null) {
        if (this.parseSupSub())
          return true;
        if (this.parseLimits())
          return true;
        result = this.parseSimpleToken();
      }
      if (isArray(result))
        this.mathlist.push(...result);
      else if (result)
        this.mathlist.push(result);
      return result !== null;
    }
  };
  function parseLatex(s, context, options) {
    var _a3, _b3, _c2;
    const args = (_a3 = options == null ? void 0 : options.args) != null ? _a3 : null;
    const parser = new Parser(tokenize(s, args), context, {
      args,
      mathstyle: (_b3 = options == null ? void 0 : options.mathstyle) != null ? _b3 : "displaystyle",
      parseMode: (_c2 = options == null ? void 0 : options.parseMode) != null ? _c2 : "math"
    });
    const atoms = [];
    while (!parser.end())
      atoms.push(...parser.parse());
    return atoms;
  }
  function validateLatex(s, context, options) {
    var _a3;
    const parser = new Parser(tokenize(s, null), context, {
      args: null,
      mathstyle: "displaystyle",
      parseMode: (_a3 = options == null ? void 0 : options.parseMode) != null ? _a3 : "math"
    });
    while (!parser.end())
      parser.parse();
    return parser.errors;
  }
  function convertToGlue(value, context) {
    if (typeof value === "object" && "glue" in value)
      return value;
    if (typeof value === "object" && "dimension" in value)
      return { glue: value };
    if (typeof value === "number")
      return { glue: { dimension: value } };
    const parser = new Parser(tokenize(value), context, {});
    return parser.scanGlue();
  }
  function convertToDimension(value, context) {
    if (typeof value === "number")
      return { dimension: value, unit: "pt" };
    if (typeof value === "object" && "glue" in value)
      value = value.glue;
    if (typeof value === "object" && "dimension" in value)
      return value;
    const parser = new Parser(tokenize(value), context, {});
    return parser.scanDimen();
  }

  // src/core-atoms/enclose.ts
  var EncloseAtom = class extends Atom {
    constructor(command, body, notation, context, options) {
      super("enclose", context, { command, style: options.style });
      this.body = body;
      this.backgroundcolor = options.backgroundcolor;
      if (notation.updiagonalarrow)
        notation.updiagonalstrike = false;
      if (notation.box) {
        notation.left = false;
        notation.right = false;
        notation.bottom = false;
        notation.top = false;
      }
      this.notation = notation;
      this.shadow = options.shadow;
      this.strokeWidth = options.strokeWidth;
      this.strokeStyle = options.strokeStyle;
      this.svgStrokeStyle = options.svgStrokeStyle;
      this.strokeColor = options.strokeColor;
      this.borderStyle = options.borderStyle;
      this.padding = options.padding;
      this.captureSelection = true;
    }
    static fromJson(json, context) {
      console.log(json);
      return new EncloseAtom(
        json.command,
        json.body,
        json.notation,
        context,
        json
      );
    }
    toJson() {
      return __spreadProps(__spreadValues({}, super.toJson()), {
        notation: this.notation,
        shadow: this.shadow,
        strokeWidth: this.strokeWidth,
        strokeStyle: this.strokeStyle,
        svgStrokeStyle: this.svgStrokeStyle,
        strokeColor: this.strokeColor,
        borderStyle: this.borderStyle,
        padding: this.padding
      });
    }
    serialize(options) {
      var _a3;
      let result = (_a3 = this.command) != null ? _a3 : "";
      if (this.command === "\\enclose") {
        result += "{" + Object.keys(this.notation).join(" ") + "}";
        let style = "";
        let sep = "";
        if (this.backgroundcolor && this.backgroundcolor !== "transparent") {
          style += sep + 'mathbackground="' + this.backgroundcolor + '"';
          sep = ",";
        }
        if (this.shadow && this.shadow !== "auto") {
          style += sep + 'shadow="' + this.shadow + '"';
          sep = ",";
        }
        if (this.strokeWidth || this.strokeStyle !== "solid") {
          style += sep + this.borderStyle;
          sep = ",";
        } else if (this.strokeColor && this.strokeColor !== "currentColor") {
          style += sep + 'mathcolor="' + this.strokeColor + '"';
          sep = ",";
        }
        if (style)
          result += `[${style}]`;
      }
      result += `{${this.bodyToLatex(options)}}`;
      return result;
    }
    render(parentContext) {
      var _a3;
      const context = new Context(parentContext, this.style);
      const base = Atom.createBox(context, this.body);
      if (!base)
        return null;
      const padding = (_a3 = convertDimensionToEm(
        this.padding && this.padding !== "auto" ? convertToDimension(this.padding, __spreadProps(__spreadValues({}, this.context), {
          registers: parentContext.registers
        })) : context.getRegisterAsDimension("fboxsep")
      )) != null ? _a3 : 0;
      const borderWidth = borderDim(this.borderStyle);
      const notation = new Box(null, { classes: "ML__notation" });
      notation.setStyle("box-sizing", "border-box");
      notation.setStyle("top", `calc(-${borderWidth} / 2 - ${padding}em)`);
      notation.setStyle("left", `calc(-${borderWidth} / 2 - ${padding}em)`);
      notation.setStyle(
        "height",
        `calc(100% + ${2 * padding}em + 2 * ${borderWidth})`
      );
      notation.height = base.height + padding;
      notation.depth = base.depth + padding;
      notation.setStyle(
        "width",
        `calc(100% + ${2 * padding}em + 2 * ${borderWidth})`
      );
      if (this.backgroundcolor)
        notation.setStyle("background-color", this.backgroundcolor);
      if (this.notation.box)
        notation.setStyle("border", this.borderStyle);
      if (this.notation.actuarial) {
        notation.setStyle("border-top", this.borderStyle);
        notation.setStyle("border-right", this.borderStyle);
      }
      if (this.notation.madruwb) {
        notation.setStyle("border-bottom", this.borderStyle);
        notation.setStyle("border-right", this.borderStyle);
      }
      if (this.notation.roundedbox) {
        notation.setStyle("border-radius", "8px");
        notation.setStyle("border", this.borderStyle);
      }
      if (this.notation.circle) {
        notation.setStyle("border-radius", "50%");
        notation.setStyle("border", this.borderStyle);
      }
      if (this.notation.top)
        notation.setStyle("border-top", this.borderStyle);
      if (this.notation.left)
        notation.setStyle("border-left", this.borderStyle);
      if (this.notation.right)
        notation.setStyle("border-right", this.borderStyle);
      if (this.notation.bottom)
        notation.setStyle("border-bottom", this.borderStyle);
      let svg = "";
      if (this.notation.horizontalstrike) {
        svg += '<line x1="3%"  y1="50%" x2="97%" y2="50%"';
        svg += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`;
        svg += ' stroke-linecap="round"';
        if (this.svgStrokeStyle)
          svg += ` stroke-dasharray="${this.svgStrokeStyle}"`;
        svg += "/>";
      }
      if (this.notation.verticalstrike) {
        svg += '<line x1="50%"  y1="3%" x2="50%" y2="97%"';
        svg += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`;
        svg += ' stroke-linecap="round"';
        if (this.svgStrokeStyle)
          svg += ` stroke-dasharray="${this.svgStrokeStyle}"`;
        svg += "/>";
      }
      if (this.notation.updiagonalstrike) {
        svg += '<line x1="3%"  y1="97%" x2="97%" y2="3%"';
        svg += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`;
        svg += ' stroke-linecap="round"';
        if (this.svgStrokeStyle)
          svg += ` stroke-dasharray="${this.svgStrokeStyle}"`;
        svg += "/>";
      }
      if (this.notation.downdiagonalstrike) {
        svg += '<line x1="3%"  y1="3%" x2="97%" y2="97%"';
        svg += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`;
        svg += ' stroke-linecap="round"';
        if (this.svgStrokeStyle)
          svg += ` stroke-dasharray="${this.svgStrokeStyle}"`;
        svg += "/>";
      }
      if (svg) {
        let svgStyle;
        if (this.shadow !== "none") {
          svgStyle = this.shadow === "auto" ? "filter: drop-shadow(0 0 .5px rgba(255, 255, 255, .7)) drop-shadow(1px 1px 2px #333)" : "filter: drop-shadow(" + this.shadow + ")";
        }
        addSVGOverlay(notation, svg, svgStyle);
      }
      const result = new Box([notation, base]);
      result.setStyle("position", "relative");
      result.setStyle("display", "inline");
      result.height = base.height + padding;
      result.depth = base.depth + padding;
      result.left = padding;
      result.right = padding;
      if (this.caret)
        result.caret = this.caret;
      return result.wrap(context);
    }
  };
  function borderDim(s) {
    if (!s)
      return "1px";
    const m = s.match(/([0-9][a-zA-Z\%]+)/);
    if (m === null)
      return "1px";
    return m[1];
  }

  // src/core-definitions/enclose.ts
  defineFunction("enclose", "{notation:string}[style:string]{body:auto}", {
    createAtom: (command, args, style, context) => {
      var _a3;
      const options = {
        strokeColor: "currentColor",
        strokeWidth: "",
        strokeStyle: "solid",
        backgroundcolor: "transparent",
        padding: "auto",
        shadow: "auto",
        svgStrokeStyle: void 0,
        borderStyle: void 0,
        style
      };
      if (args[1]) {
        const styles = args[1].split(
          /,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/
        );
        for (const s of styles) {
          const shorthand = s.match(/\s*(\S+)\s+(\S+)\s+(.*)/);
          if (shorthand) {
            options.strokeWidth = shorthand[1];
            options.strokeStyle = shorthand[2];
            options.strokeColor = shorthand[3];
          } else {
            const attribute = s.match(/\s*([a-z]*)\s*=\s*"(.*)"/);
            if (attribute) {
              if (attribute[1] === "mathbackground")
                options.backgroundcolor = attribute[2];
              else if (attribute[1] === "mathcolor")
                options.strokeColor = attribute[2];
              else if (attribute[1] === "padding")
                options.padding = attribute[2];
              else if (attribute[1] === "shadow")
                options.shadow = attribute[2];
            }
          }
        }
        if (options.strokeStyle === "dashed")
          options.svgStrokeStyle = "5,5";
        else if (options.strokeStyle === "dotted")
          options.svgStrokeStyle = "1,5";
      }
      options.borderStyle = `${options.strokeWidth} ${options.strokeStyle} ${options.strokeColor}`;
      const notation = {};
      ((_a3 = args[0]) != null ? _a3 : "").split(/[, ]/).filter((v) => v.length > 0).forEach((x) => {
        notation[x.toLowerCase()] = true;
      });
      return new EncloseAtom(
        command,
        args[2],
        notation,
        context,
        options
      );
    }
  });
  defineFunction("cancel", "{body:auto}", {
    createAtom: (name, args, style, context) => new EncloseAtom(
      name,
      args[0],
      { updiagonalstrike: true },
      context,
      {
        strokeColor: "currentColor",
        strokeWidth: "",
        strokeStyle: "solid",
        borderStyle: "1px solid currentColor",
        backgroundcolor: "transparent",
        padding: "auto",
        shadow: "auto",
        style
      }
    )
  });
  defineFunction("bcancel", "{body:auto}", {
    createAtom: (name, args, style, context) => new EncloseAtom(
      name,
      args[0],
      { downdiagonalstrike: true },
      context,
      {
        strokeColor: "currentColor",
        strokeWidth: "",
        strokeStyle: "solid",
        borderStyle: "1px solid currentColor",
        backgroundcolor: "transparent",
        padding: "auto",
        shadow: "auto",
        style
      }
    )
  });
  defineFunction("xcancel", "{body:auto}", {
    createAtom: (name, args, style, context) => new EncloseAtom(
      name,
      args[0],
      { updiagonalstrike: true, downdiagonalstrike: true },
      context,
      {
        strokeColor: "currentColor",
        strokeWidth: "",
        strokeStyle: "solid",
        borderStyle: "1px solid currentColor",
        backgroundcolor: "transparent",
        padding: "auto",
        shadow: "auto",
        style
      }
    )
  });

  // src/core-atoms/array.ts
  function normalizeArray(context, atom, array, colFormat) {
    let maxColCount = 0;
    for (const colSpec of colFormat)
      if ("align" in colSpec)
        maxColCount += 1;
    let colCount = 0;
    const rows = [];
    for (const row of array) {
      let colIndex2 = 0;
      colCount = Math.max(colCount, Math.min(row.length, maxColCount));
      while (colIndex2 < row.length) {
        const newRow = [];
        const lastCol = Math.min(row.length, colIndex2 + maxColCount);
        while (colIndex2 < lastCol) {
          if (row[colIndex2].length === 0)
            newRow.push([new Atom("first", context, { mode: atom.mode })]);
          else if (row[colIndex2][0].type !== "first") {
            newRow.push([
              new Atom("first", context, { mode: atom.mode }),
              ...row[colIndex2]
            ]);
          } else
            newRow.push(row[colIndex2]);
          colIndex2 += 1;
        }
        rows.push(newRow);
      }
    }
    if (rows[rows.length - 1].length === 1 && rows[rows.length - 1][0].length === 0)
      rows.pop();
    const result = [];
    for (const row of rows) {
      if (row.length !== colCount) {
        for (let i = row.length; i < colCount; i++) {
          row.push([
            new Atom("first", context, { mode: atom.mode }),
            new PlaceholderAtom(context)
          ]);
        }
      }
      result.push(row);
    }
    let rowIndex = 0;
    let colIndex = 0;
    for (const row of result) {
      colIndex = 0;
      for (const cell of row) {
        for (const element of cell) {
          element.parent = atom;
          element.treeBranch = [rowIndex, colIndex];
        }
        colIndex += 1;
      }
      rowIndex += 1;
    }
    atom.isDirty = true;
    return result;
  }
  var ArrayAtom = class extends Atom {
    constructor(context, envName, array, rowGaps, options = {}) {
      var _a3, _b3;
      super("array", context);
      this.environmentName = envName;
      this.rowGaps = rowGaps;
      if (options.mathstyleName)
        this.mathstyleName = options.mathstyleName;
      if (options.columns) {
        if (options.columns.length === 0)
          this.colFormat = [{ align: "l" }];
        else
          this.colFormat = options.columns;
      }
      if (!this.colFormat) {
        this.colFormat = [
          { align: "l" },
          { align: "l" },
          { align: "l" },
          { align: "l" },
          { align: "l" },
          { align: "l" },
          { align: "l" },
          { align: "l" },
          { align: "l" },
          { align: "l" }
        ];
      }
      this.array = normalizeArray(context, this, array, this.colFormat);
      if (options.leftDelim)
        this.leftDelim = options.leftDelim;
      if (options.rightDelim)
        this.rightDelim = options.rightDelim;
      if (options.jot !== void 0)
        this.jot = options.jot;
      if (options.arraycolsep)
        this.arraycolsep = options.arraycolsep;
      this.colSeparationType = options.colSeparationType;
      this.arraystretch = (_a3 = options.arraystretch) != null ? _a3 : 1;
      this.minColumns = (_b3 = options.minColumns) != null ? _b3 : 1;
    }
    static fromJson(json, context) {
      return new ArrayAtom(
        context,
        json.environmentName,
        json.array,
        json.rowGaps,
        json
      );
    }
    toJson() {
      const result = __spreadProps(__spreadValues({}, super.toJson()), {
        environmentName: this.environmentName,
        array: this.array.map(
          (row) => row.map((col) => col.map((x) => x.toJson()))
        ),
        rowGaps: this.rowGaps,
        columns: this.colFormat,
        colSeparationType: this.colSeparationType
      });
      if (this.arraystretch !== 1)
        result.arraystretch = this.arraystretch;
      if (this.arraycolsep)
        result.arraycolsep = this.arraycolsep;
      if (this.leftDelim)
        result.leftDelim = this.leftDelim;
      if (this.rightDelim)
        result.rightDelim = this.rightDelim;
      if (this.jot !== void 0)
        result.jot = this.jot;
      return result;
    }
    branch(cell) {
      var _a3;
      if (!isCellBranch(cell))
        return void 0;
      return (_a3 = this.array[cell[0]][cell[1]]) != null ? _a3 : void 0;
    }
    get branches() {
      const result = super.branches;
      this.array.forEach((_, col) => {
        this.array[col].forEach((_2, row) => {
          if (this.array[col][row])
            result.push([col, row]);
        });
      });
      return result;
    }
    createBranch(cell) {
      var _a3;
      if (!isCellBranch(cell))
        return [];
      this.isDirty = true;
      return (_a3 = this.branch(cell)) != null ? _a3 : [];
    }
    get rowCount() {
      return this.array.length;
    }
    get colCount() {
      return this.array[0].length;
    }
    get maxColumns() {
      return this.colFormat.filter((col) => Boolean(col["align"])).length;
    }
    removeBranch(name) {
      if (isNamedBranch(name))
        return super.removeBranch(name);
      const children = this.branch(name);
      this.array[name[0]][name[1]] = void 0;
      children.forEach((x) => {
        x.parent = void 0;
        x.treeBranch = void 0;
      });
      console.assert(children[0].type === "first");
      children.shift();
      this.isDirty = true;
      return children;
    }
    get hasChildren() {
      return this.children.length > 0;
    }
    get children() {
      const result = [];
      for (const row of this.array) {
        for (const cell of row) {
          if (cell) {
            for (const atom of cell) {
              result.push(...atom.children);
              result.push(atom);
            }
          }
        }
      }
      return [...result, ...super.children];
    }
    render(context) {
      var _a3, _b3, _c2, _d2, _e;
      const innerContext = new Context(context, this.style, this.mathstyleName);
      const arrayRuleWidth = innerContext.getRegisterAsEm("arrayrulewidth");
      const arrayColSep = innerContext.getRegisterAsEm("arraycolsep");
      const doubleRuleSep = innerContext.getRegisterAsEm("doublerulesep");
      const arraystretch = (_a3 = this.arraystretch) != null ? _a3 : 1;
      let arraycolsep = typeof this.arraycolsep === "number" ? this.arraycolsep : arrayColSep;
      if (this.colSeparationType === "small") {
        const localMultiplier = new Context(context, void 0, "scriptstyle").scalingFactor;
        arraycolsep = 0.2778 * (localMultiplier / context.scalingFactor);
      }
      const arrayskip = arraystretch * BASELINE_SKIP;
      const arstrutHeight = 0.7 * arrayskip;
      const arstrutDepth = 0.3 * arrayskip;
      let totalHeight = 0;
      const body = [];
      let nc = 0;
      const nr = this.array.length;
      for (let r = 0; r < nr; ++r) {
        const inrow = this.array[r];
        nc = Math.max(nc, inrow.length);
        const cellContext = new Context(
          innerContext,
          this.style,
          this.mathstyleName
        );
        let height = arstrutHeight / cellContext.scalingFactor;
        let depth = arstrutDepth / cellContext.scalingFactor;
        const outrow = { cells: [], height: 0, depth: 0, pos: 0 };
        for (const element of inrow) {
          const elt = (_b3 = Atom.createBox(cellContext, element, { newList: true })) != null ? _b3 : new Box(null, { newList: true });
          depth = Math.max(depth, elt.depth);
          height = Math.max(height, elt.height);
          outrow.cells.push(elt);
        }
        let gap = (_c2 = convertDimensionToEm(this.rowGaps[r])) != null ? _c2 : 0;
        if (gap > 0) {
          gap += arstrutDepth;
          depth = Math.max(depth, gap);
          gap = 0;
        }
        if (this.jot !== void 0)
          depth += this.jot;
        outrow.height = height;
        outrow.depth = depth;
        totalHeight += height;
        outrow.pos = totalHeight;
        totalHeight += depth + gap;
        body.push(outrow);
      }
      const offset = totalHeight / 2 + AXIS_HEIGHT;
      const contentCols = [];
      for (let colIndex = 0; colIndex < nc; colIndex++) {
        const stack = [];
        for (const row of body) {
          const element = row.cells[colIndex];
          element.depth = row.depth;
          element.height = row.height;
          stack.push({ box: element, shift: row.pos - offset });
        }
        if (stack.length > 0)
          contentCols.push(new VBox({ individualShift: stack }));
      }
      const cols = [];
      let previousColContent = false;
      let previousColRule = false;
      let currentContentCol = 0;
      let firstColumn = !this.leftDelim;
      const { colFormat } = this;
      for (const colDesc of colFormat) {
        if ("align" in colDesc && currentContentCol >= contentCols.length) {
          break;
        }
        if ("align" in colDesc) {
          if (previousColContent) {
            cols.push(makeColGap(2 * arraycolsep));
          } else if (previousColRule || firstColumn) {
            cols.push(makeColGap(arraycolsep));
          }
          cols.push(
            new Box(contentCols[currentContentCol], {
              classes: "col-align-" + colDesc.align
            })
          );
          currentContentCol++;
          previousColContent = true;
          previousColRule = false;
          firstColumn = false;
        } else if ("gap" in colDesc) {
          if (typeof colDesc.gap === "number") {
            cols.push(makeColGap(colDesc.gap));
          } else {
            const col = makeColOfRepeatingElements(
              context,
              body,
              offset,
              colDesc.gap
            );
            if (col)
              cols.push(col);
          }
          previousColContent = false;
          previousColRule = false;
          firstColumn = false;
        } else if ("separator" in colDesc) {
          const separator = new Box(null, { classes: "vertical-separator" });
          separator.setStyle("height", totalHeight, "em");
          separator.setStyle(
            "border-right",
            `${arrayRuleWidth}em ${colDesc.separator} currentColor`
          );
          separator.setStyle("vertical-align", -(totalHeight - offset), "em");
          let gap = 0;
          if (previousColRule)
            gap = doubleRuleSep - arrayRuleWidth;
          else if (previousColContent)
            gap = arraycolsep - arrayRuleWidth;
          separator.left = gap;
          cols.push(separator);
          previousColContent = false;
          previousColRule = true;
          firstColumn = false;
        }
      }
      if (previousColContent && !this.rightDelim) {
        cols.push(makeColGap(arraycolsep));
      }
      const inner = new Box(cols, { classes: "mtable" });
      if ((!this.leftDelim || this.leftDelim === ".") && (!this.rightDelim || this.rightDelim === ".")) {
        if (this.caret)
          inner.caret = this.caret;
        return inner;
      }
      const innerHeight = inner.height;
      const innerDepth = inner.depth;
      const result = this.bind(
        context,
        new Box(
          [
            this.bind(
              context,
              makeLeftRightDelim(
                "mopen",
                (_d2 = this.leftDelim) != null ? _d2 : ".",
                innerHeight,
                innerDepth,
                innerContext
              )
            ),
            inner,
            this.bind(
              context,
              makeLeftRightDelim(
                "mclose",
                (_e = this.rightDelim) != null ? _e : ".",
                innerHeight,
                innerDepth,
                innerContext
              )
            )
          ],
          { type: "mord" }
        )
      );
      if (!result)
        return null;
      if (this.caret)
        result.caret = this.caret;
      return this.attachSupsub(context, { base: result });
    }
    serialize(options) {
      let result = "\\begin{" + this.environmentName + "}";
      if (this.environmentName === "array") {
        result += "{";
        if (this.colFormat !== void 0) {
          for (const format of this.colFormat) {
            if ("align" in format)
              result += format.align;
            else if ("separator" in format && format.separator === "solid")
              result += "|";
            else if ("separator" in format && format.separator === "dashed")
              result += ":";
          }
        }
        result += "}";
      }
      for (let row = 0; row < this.array.length; row++) {
        for (let col = 0; col < this.array[row].length; col++) {
          if (col > 0)
            result += " & ";
          result = joinLatex([
            result,
            Atom.serialize(this.array[row][col], options)
          ]);
        }
        if (row < this.array.length - 1)
          result += " \\\\ ";
      }
      result += "\\end{" + this.environmentName + "}";
      return result;
    }
    getCell(row, col) {
      return this.array[row][col];
    }
    setCell(row, column, value) {
      console.assert(
        this.type === "array" && Array.isArray(this.array) && this.array[row][column] !== void 0
      );
      for (const atom of this.array[row][column]) {
        atom.parent = void 0;
        atom.treeBranch = void 0;
      }
      let atoms = value;
      if (value.length === 0 || value[0].type !== "first")
        atoms = [new Atom("first", this.context, { mode: this.mode }), ...value];
      this.array[row][column] = atoms;
      for (const atom of atoms) {
        atom.parent = this;
        atom.treeBranch = [row, column];
      }
      this.isDirty = true;
    }
    addRowBefore(row) {
      console.assert(this.type === "array" && Array.isArray(this.array));
      const newRow = [];
      for (let i = 0; i < this.colCount; i++)
        newRow.push(makePlaceholderCell(this));
      this.array.splice(row, 0, newRow);
      for (let i = row; i < this.rowCount; i++) {
        for (let j = 0; j < this.colCount; j++) {
          const atoms = this.array[i][j];
          if (atoms)
            for (const atom of atoms)
              atom.treeBranch = [i, j];
        }
      }
      this.isDirty = true;
    }
    addRowAfter(row) {
      console.assert(this.type === "array" && Array.isArray(this.array));
      const newRow = [];
      for (let i = 0; i < this.colCount; i++)
        newRow.push(makePlaceholderCell(this));
      this.array.splice(row + 1, 0, newRow);
      for (let i = row + 1; i < this.rowCount; i++) {
        for (let j = 0; j < this.colCount; j++) {
          const atoms = this.array[i][j];
          if (atoms)
            for (const atom of atoms)
              atom.treeBranch = [i, j];
        }
      }
      this.isDirty = true;
    }
    removeRow(row) {
      console.assert(
        this.type === "array" && Array.isArray(this.array) && this.rowCount > row
      );
      const deleted = this.array.splice(row, 1);
      for (const column of deleted) {
        for (const cell of column) {
          if (cell) {
            for (const child of cell) {
              child.parent = void 0;
              child.treeBranch = void 0;
            }
          }
        }
      }
      for (let i = row; i < this.rowCount; i++) {
        for (let j = 0; j < this.colCount; j++) {
          const atoms = this.array[i][j];
          if (atoms)
            for (const atom of atoms)
              atom.treeBranch = [i, j];
        }
      }
      this.isDirty = true;
    }
    addColumnBefore(col) {
      console.assert(this.type === "array" && Array.isArray(this.array));
      for (const row of this.array)
        row.splice(col, 0, makePlaceholderCell(this));
      for (let i = 0; i < this.rowCount; i++) {
        for (let j = col; j < this.colCount; j++) {
          const atoms = this.array[i][j];
          if (atoms)
            for (const atom of atoms)
              atom.treeBranch = [i, j];
        }
      }
      this.isDirty = true;
    }
    addColumnAfter(col) {
      console.assert(this.type === "array" && Array.isArray(this.array));
      for (const row of this.array)
        row.splice(col + 1, 0, makePlaceholderCell(this));
      for (let i = 0; i < this.rowCount; i++) {
        for (let j = col + 1; j < this.colCount; j++) {
          const atoms = this.array[i][j];
          if (atoms)
            for (const atom of atoms)
              atom.treeBranch = [i, j];
        }
      }
      this.isDirty = true;
    }
    addColumn() {
      this.addColumnAfter(this.colCount - 1);
    }
    removeColumn(col) {
      console.assert(
        this.type === "array" && Array.isArray(this.array) && this.colCount > col
      );
      for (const row of this.array) {
        const deleted = row.splice(col, 1);
        for (const cell of deleted) {
          if (cell) {
            for (const child of cell) {
              child.parent = void 0;
              child.treeBranch = void 0;
            }
          }
        }
      }
      for (let i = 0; i < this.rowCount; i++) {
        for (let j = col; j < this.colCount; j++) {
          const atoms = this.array[i][j];
          if (atoms)
            for (const atom of atoms)
              atom.treeBranch = [i, j];
        }
      }
      this.isDirty = true;
    }
    get cells() {
      const result = [];
      for (const row of this.array)
        for (const cell of row)
          if (cell)
            result.push(cell);
      return result;
    }
  };
  function makePlaceholderCell(parent) {
    const first = new Atom("first", parent.context, { mode: parent.mode });
    first.parent = parent;
    const placeholder = new PlaceholderAtom(parent.context, {
      mode: parent.mode
    });
    placeholder.parent = parent;
    return [first, placeholder];
  }
  function makeColGap(width) {
    const separator = new Box(null, { classes: "arraycolsep" });
    separator.width = width;
    return separator;
  }
  function makeColOfRepeatingElements(context, rows, offset, element) {
    if (!element)
      return null;
    const col = [];
    for (const row of rows) {
      const cell = Atom.createBox(context, element, { newList: true });
      if (cell) {
        cell.depth = row.depth;
        cell.height = row.height;
        col.push({ box: cell, shift: row.pos - offset });
      }
    }
    return new VBox({ individualShift: col }).wrap(context);
  }

  // src/core-definitions/environments.ts
  defineEnvironment(
    "math",
    "",
    (context, name, array, rowGaps) => {
      if (isEnvironmentEmpty(array)) {
        array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
      }
      return new ArrayAtom(context, name, array, rowGaps, {
        mathstyleName: "textstyle"
      });
    }
  );
  defineEnvironment(
    "displaymath",
    "",
    (context, name, array, rowGaps) => {
      if (isEnvironmentEmpty(array)) {
        array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
      }
      return new ArrayAtom(context, name, array, rowGaps, {
        mathstyleName: "textstyle"
      });
    }
  );
  defineTabularEnvironment(
    "array",
    "{columns:colspec}",
    (context, name, array, rowGaps, args) => {
      if (isEnvironmentEmpty(array)) {
        array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
      }
      return new ArrayAtom(context, name, array, rowGaps, {
        columns: args[0],
        mathstyleName: "textstyle"
      });
    }
  );
  defineTabularEnvironment(
    ["equation", "equation*", "subequations"],
    "",
    (context, name, array, rowGaps) => {
      if (isEnvironmentEmpty(array)) {
        array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
      }
      return new ArrayAtom(context, name, array, rowGaps, {
        columns: [{ align: "c" }]
      });
    }
  );
  defineTabularEnvironment(
    "multline",
    "",
    (context, name, array, rowGaps) => {
      if (isEnvironmentEmpty(array)) {
        array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
      }
      return new ArrayAtom(context, name, array, rowGaps, {
        columns: [{ align: "m" }]
      });
    }
  );
  defineTabularEnvironment(
    ["align", "align*", "aligned", "eqnarray"],
    "",
    (context, name, array, rowGaps) => {
      let colCount = 0;
      if (isEnvironmentEmpty(array)) {
        array = [
          [
            [new Atom("first", context), new PlaceholderAtom(context)],
            [new Atom("first", context), new PlaceholderAtom(context)]
          ]
        ];
      }
      for (const row of array)
        colCount = Math.max(colCount, row.length);
      const colFormat = [
        { gap: 0 },
        { align: "r" },
        { gap: 0.25 },
        { align: "l" }
      ];
      let i = 2;
      while (i < colCount) {
        colFormat.push({ gap: 1 });
        colFormat.push({ align: "r" });
        colFormat.push({ gap: 0.25 });
        colFormat.push({ align: "l" });
        i += 2;
      }
      colFormat.push({ gap: 0 });
      return new ArrayAtom(context, name, array, rowGaps, {
        arraycolsep: 0,
        columns: colFormat,
        colSeparationType: "align",
        jot: 0.3,
        minColumns: 2
      });
    }
  );
  defineTabularEnvironment(
    "split",
    "",
    (context, name, array, rowGaps) => {
      if (isEnvironmentEmpty(array)) {
        array = [
          [
            [new Atom("first", context), new PlaceholderAtom(context)],
            [new Atom("first", context), new PlaceholderAtom(context)]
          ]
        ];
      }
      return new ArrayAtom(context, name, array, rowGaps, {
        columns: [{ align: "r" }, { align: "l" }],
        minColumns: 2
      });
    }
  );
  defineTabularEnvironment(
    ["gather", "gathered"],
    "",
    (context, name, array, rowGaps) => {
      if (isEnvironmentEmpty(array)) {
        array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
      }
      return new ArrayAtom(context, name, array, rowGaps, {
        columns: [{ gap: 0.25 }, { align: "c" }, { gap: 0 }],
        colSeparationType: "gather"
      });
    }
  );
  defineTabularEnvironment(
    [
      "matrix",
      "pmatrix",
      "bmatrix",
      "Bmatrix",
      "vmatrix",
      "Vmatrix",
      "matrix*",
      "pmatrix*",
      "bmatrix*",
      "Bmatrix*",
      "vmatrix*",
      "Vmatrix*"
    ],
    "[columns:colspec]",
    (context, name, array, rowGaps, args) => {
      var _a3;
      if (isEnvironmentEmpty(array)) {
        array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
      }
      let leftDelim = ".";
      let rightDelim = ".";
      switch (name) {
        case "pmatrix":
        case "pmatrix*":
          leftDelim = "(";
          rightDelim = ")";
          break;
        case "bmatrix":
        case "bmatrix*":
          leftDelim = "[";
          rightDelim = "]";
          break;
        case "Bmatrix":
        case "Bmatrix*":
          leftDelim = "\\lbrace";
          rightDelim = "\\rbrace";
          break;
        case "vmatrix":
        case "vmatrix*":
          leftDelim = "\\vert";
          rightDelim = "\\vert";
          break;
        case "Vmatrix":
        case "Vmatrix*":
          leftDelim = "\\Vert";
          rightDelim = "\\Vert";
          break;
        case "matrix":
        case "matrix*":
          leftDelim = ".";
          rightDelim = ".";
          break;
        default:
      }
      return new ArrayAtom(context, name, array, rowGaps, {
        mathstyleName: "textstyle",
        leftDelim,
        rightDelim,
        columns: (_a3 = args[0]) != null ? _a3 : [
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" }
        ]
      });
    }
  );
  defineTabularEnvironment(
    ["smallmatrix", "smallmatrix*"],
    "[columns:colspec]",
    (context, name, array, rowGaps, args) => {
      var _a3;
      if (isEnvironmentEmpty(array)) {
        array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
      }
      return new ArrayAtom(context, name, array, rowGaps, {
        mathstyleName: "scriptstyle",
        columns: (_a3 = args[0]) != null ? _a3 : [
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" },
          { align: "c" }
        ],
        colSeparationType: "small",
        arraystretch: 0.5
      });
    }
  );
  defineTabularEnvironment(
    ["cases", "dcases"],
    "",
    (context, name, array, rowGaps) => {
      if (isEnvironmentEmpty(array)) {
        array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
      }
      return new ArrayAtom(context, name, array, rowGaps, {
        mathstyleName: name === "dcases" ? "displaystyle" : "textstyle",
        arraystretch: 1.2,
        leftDelim: "\\lbrace",
        rightDelim: ".",
        columns: [{ align: "l" }, { gap: 1 }, { align: "l" }]
      });
    }
  );
  defineTabularEnvironment(
    "rcases",
    "",
    (context, name, array, rowGaps) => {
      if (isEnvironmentEmpty(array)) {
        array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
      }
      return new ArrayAtom(context, name, array, rowGaps, {
        arraystretch: 1.2,
        leftDelim: ".",
        rightDelim: "\\rbrace",
        columns: [{ align: "l" }, { gap: 1 }, { align: "l" }]
      });
    }
  );
  defineEnvironment(
    "center",
    "",
    (context, name, array, rowGaps) => {
      if (isEnvironmentEmpty(array)) {
        array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
      }
      return new ArrayAtom(context, name, array, rowGaps, {
        columns: [{ align: "c" }]
      });
    }
  );
  function isEnvironmentEmpty(array) {
    for (const row of array)
      for (const col of row)
        if (col.length > 0)
          return false;
    return true;
  }

  // src/core-definitions/extensible-symbols.ts
  defineFunction(
    [
      "overrightarrow",
      "overleftarrow",
      "Overrightarrow",
      "overleftharpoon",
      "overrightharpoon",
      "overleftrightarrow",
      "overlinesegment",
      "overgroup"
    ],
    "{:auto}",
    {
      createAtom: (command, args, style, context) => new OverunderAtom(command, context, {
        body: args[0],
        skipBoundary: false,
        supsubPlacement: "over-under",
        paddedBody: true,
        boxType: "mrel",
        style,
        // Set the "svgAbove" to the name of a SVG object (which is the same
        // as the command name)
        svgAbove: command.slice(1)
      })
    }
  );
  defineFunction("overbrace", "{:auto}", {
    createAtom: (command, args, style, context) => new OverunderAtom(command, context, {
      body: args[0],
      skipBoundary: false,
      supsubPlacement: "over-under",
      paddedBody: true,
      boxType: "mord",
      style,
      svgAbove: command.slice(1)
    })
  });
  defineFunction(
    [
      "underrightarrow",
      "underleftarrow",
      "underleftrightarrow",
      "underlinesegment",
      "undergroup"
    ],
    "{:auto}",
    {
      createAtom: (command, args, style, context) => new OverunderAtom(command, context, {
        body: args[0],
        skipBoundary: false,
        supsubPlacement: "over-under",
        paddedBody: true,
        boxType: "mrel",
        style,
        // Set the "svgBelow" to the name of a SVG object (which is the same
        // as the command name)
        svgBelow: command.slice(1)
      })
    }
  );
  defineFunction(["underbrace"], "{:auto}", {
    createAtom: (command, args, style, context) => new OverunderAtom(command, context, {
      body: args[0],
      skipBoundary: false,
      supsubPlacement: "over-under",
      paddedBody: true,
      boxType: "mord",
      style,
      svgBelow: command.slice(1)
    })
  });
  defineFunction(
    [
      "xrightarrow",
      "xleftarrow",
      "xRightarrow",
      "xLeftarrow",
      "xleftharpoonup",
      "xleftharpoondown",
      "xrightharpoonup",
      "xrightharpoondown",
      "xlongequal",
      "xtwoheadleftarrow",
      "xtwoheadrightarrow",
      "xleftrightarrow",
      "xLeftrightarrow",
      "xrightleftharpoons",
      "xleftrightharpoons",
      "xhookleftarrow",
      "xhookrightarrow",
      "xmapsto",
      "xtofrom",
      "xrightleftarrows",
      // From mhchem.sty package
      "xrightequilibrium",
      // From mhchem.sty package
      "xleftequilibrium"
      // From mhchem.sty package
    ],
    "[:auto]{:auto}",
    {
      createAtom: (command, args, style, context) => {
        var _a3, _b3;
        return new OverunderAtom(command, context, {
          style,
          // Set the "svgBody" to the name of a SVG object (which is the same
          // as the command name)
          svgBody: command.slice(1),
          // The overscript is optional, i.e. `\xtofrom` is valid
          above: ((_a3 = args[1]) == null ? void 0 : _a3.length) === 0 ? void 0 : args[1],
          below: (_b3 = args[0]) != null ? _b3 : null,
          skipBoundary: false,
          supsubPlacement: "over-under",
          paddedBody: true,
          paddedLabels: true,
          boxType: "mrel",
          serialize: (atom, options) => command + (!atom.hasEmptyBranch("below") ? `[${atom.belowToLatex(options)}]` : "") + `{${atom.aboveToLatex(options)}}${atom.supsubToLatex(options)}`
        });
      }
    }
  );

  // src/core-atoms/operator.ts
  var OperatorAtom = class extends Atom {
    constructor(command, symbol, context, options) {
      var _a3, _b3, _c2, _d2;
      super((_a3 = options.type) != null ? _a3 : "mop", context, {
        command,
        style: options.style,
        isFunction: options == null ? void 0 : options.isFunction
      });
      if (typeof symbol === "string")
        this.value = symbol;
      else
        this.body = symbol;
      this.captureSelection = (_b3 = options.captureSelection) != null ? _b3 : false;
      this.hasArgument = (_c2 = options.hasArgument) != null ? _c2 : false;
      this.variant = options == null ? void 0 : options.variant;
      this.variantStyle = options == null ? void 0 : options.variantStyle;
      this.subsupPlacement = options == null ? void 0 : options.limits;
      this.isExtensibleSymbol = (_d2 = options == null ? void 0 : options.isExtensibleSymbol) != null ? _d2 : false;
    }
    static fromJson(json, context) {
      return new OperatorAtom(
        json.command,
        json.body ? json.body : json.value,
        context,
        json
      );
    }
    toJson() {
      const result = super.toJson();
      if (this.hasArgument)
        result.hasArgument = true;
      if (this.variant)
        result.variant = this.variant;
      if (this.variantStyle)
        result.variantStyle = this.variantStyle;
      if (this.subsupPlacement)
        result.limits = this.subsupPlacement;
      if (this.isExtensibleSymbol)
        result.isExtensibleSymbol = true;
      if (this.value)
        result.symbol = this.value;
      return result;
    }
    render(context) {
      var _a3;
      let base;
      let baseShift = 0;
      let slant = 0;
      if (this.isExtensibleSymbol) {
        const large = context.isDisplayStyle && this.value !== "\\smallint";
        base = new Box(this.value, {
          fontFamily: large ? "Size2-Regular" : "Size1-Regular",
          classes: "op-symbol " + (large ? "large-op" : "small-op"),
          type: "mop",
          maxFontSize: context.scalingFactor
        });
        if (!base)
          return null;
        base.right = base.italic;
        baseShift = (base.height - base.depth) / 2 - AXIS_HEIGHT * context.scalingFactor;
        slant = base.italic;
        base.setStyle("color", this.style.color);
        base.setStyle("background-color", this.style.backgroundColor);
      } else if (this.body) {
        base = Atom.createBox(context, this.body, { newList: true });
        if (!base)
          return null;
        base.setStyle("color", this.style.color);
        base.setStyle("background-color", this.style.backgroundColor);
      } else {
        console.assert(this.type === "mop");
        base = new Box(this.value, {
          type: "mop",
          mode: "math",
          maxFontSize: context.scalingFactor,
          style: {
            color: this.style.color,
            backgroundColor: this.style.backgroundColor,
            letterShapeStyle: context.letterShapeStyle,
            variant: this.variant,
            variantStyle: this.variantStyle
          }
        });
      }
      if (this.isExtensibleSymbol)
        base.setTop(baseShift);
      let result = base;
      if (this.superscript || this.subscript) {
        const limits = (_a3 = this.subsupPlacement) != null ? _a3 : "auto";
        result = limits === "over-under" || limits === "auto" && context.isDisplayStyle ? this.attachLimits(context, { base, baseShift, slant }) : this.attachSupsub(context, { base });
      }
      if (this.caret)
        result.caret = this.caret;
      return new Box(this.bind(context, result), {
        type: "mop",
        classes: "op-group" + (this.isSelected ? " ML__selected" : "")
      });
    }
    serialize(options) {
      if (this.value === "\u200B")
        return this.supsubToLatex(options);
      const result = [];
      result.push(this.command);
      if (this.hasArgument)
        result.push(`{${this.bodyToLatex(options)}}`);
      if (this.explicitSubsupPlacement) {
        if (this.subsupPlacement === "over-under")
          result.push("\\limits");
        if (this.subsupPlacement === "adjacent")
          result.push("\\nolimits");
        if (this.subsupPlacement === "auto")
          result.push("\\displaylimits");
      }
      result.push(this.supsubToLatex(options));
      return joinLatex(result);
    }
  };

  // src/core-atoms/surd.ts
  var SurdAtom = class extends Atom {
    constructor(command, context, options) {
      var _a3;
      super("surd", context, {
        command,
        mode: (_a3 = options.mode) != null ? _a3 : "math",
        style: options.style,
        displayContainsHighlight: true
      });
      this.body = options.body;
      this.above = options.index;
    }
    static fromJson(json, context) {
      return new SurdAtom(json.command, context, __spreadProps(__spreadValues({}, json), {
        index: json.above
      }));
    }
    toJson() {
      return super.toJson();
    }
    serialize(options) {
      let args = "";
      if (this.above)
        args += `[${this.aboveToLatex(options)}]`;
      args += `{${this.bodyToLatex(options)}}`;
      return this.command + args;
    }
    render(parentContext) {
      var _a3;
      const innerContext = new Context(parentContext, this.style, "cramp");
      const innerBox = (_a3 = Atom.createBox(innerContext, this.body, {
        style: this.style,
        newList: true
      })) != null ? _a3 : new Box(null);
      const factor = innerContext.scalingFactor;
      const ruleWidth = innerContext.metrics.defaultRuleThickness / factor;
      const phi = parentContext.isDisplayStyle ? X_HEIGHT : ruleWidth;
      const line = new Box(null, {
        classes: "ML__sqrt-line",
        style: this.style,
        height: ruleWidth
      });
      let lineClearance = factor * (ruleWidth + phi / 4);
      const innerTotalHeight = Math.max(
        factor * 2 * phi,
        innerBox.height + innerBox.depth
      );
      const minDelimiterHeight = innerTotalHeight + lineClearance + ruleWidth;
      const delimContext = new Context(parentContext, this.style);
      const selectClasses = this.isSelected ? " ML__selected" : "";
      const delimBox = this.bind(
        delimContext,
        new Box(
          makeCustomSizedDelim(
            "",
            "\\surd",
            minDelimiterHeight,
            false,
            delimContext,
            { classes: selectClasses }
          ),
          {
            classes: "ML__sqrt-sign" + selectClasses,
            style: this.style
          }
        )
      );
      if (!delimBox)
        return null;
      const delimDepth = delimBox.height + delimBox.depth - ruleWidth;
      if (delimDepth > innerBox.height + innerBox.depth + lineClearance) {
        lineClearance = (lineClearance + delimDepth - (innerBox.height + innerBox.depth)) / 2;
      }
      delimBox.setTop(delimBox.height - innerBox.height - lineClearance);
      const bodyBox = this.bind(
        parentContext,
        new VBox({
          firstBaseline: [
            { box: new Box(innerBox) },
            // Need to wrap the inner for proper selection bound calculation
            lineClearance - 2 * ruleWidth,
            { box: line },
            ruleWidth
          ]
        }).wrap(parentContext)
      );
      const indexBox = Atom.createBox(
        new Context(parentContext, this.style, "scriptscriptstyle"),
        this.above,
        {
          style: this.style,
          newList: true
        }
      );
      if (!indexBox) {
        const result2 = new Box([delimBox, bodyBox], {
          classes: this.containsCaret ? "ML__contains-caret" : "",
          type: "mord"
        });
        if (this.caret)
          result2.caret = this.caret;
        return this.bind(parentContext, result2.wrap(parentContext));
      }
      const indexStack = new VBox({
        shift: -0.6 * (Math.max(delimBox.height, bodyBox.height) - Math.max(delimBox.depth, bodyBox.depth)),
        children: [{ box: indexBox }]
      });
      const result = new Box(
        [new Box(indexStack, { classes: "ML__sqrt-index" }), delimBox, bodyBox],
        { type: "mord", classes: this.containsCaret ? "ML__contains-caret" : "" }
      );
      result.height = delimBox.height;
      result.depth = delimBox.depth;
      if (this.caret)
        result.caret = this.caret;
      return this.bind(parentContext, result.wrap(parentContext));
    }
  };

  // src/core-atoms/genfrac.ts
  var GenfracAtom = class extends Atom {
    constructor(command, above, below, context, options) {
      var _a3, _b3;
      super("genfrac", context, {
        style: options.style,
        command,
        serialize: options.serialize,
        displayContainsHighlight: true
      });
      this.above = above;
      this.below = below;
      this.hasBarLine = (_a3 = options == null ? void 0 : options.hasBarLine) != null ? _a3 : true;
      this.continuousFraction = (_b3 = options == null ? void 0 : options.continuousFraction) != null ? _b3 : false;
      this.numerPrefix = options == null ? void 0 : options.numerPrefix;
      this.denomPrefix = options == null ? void 0 : options.denomPrefix;
      this.mathstyleName = options == null ? void 0 : options.mathstyleName;
      this.leftDelim = options == null ? void 0 : options.leftDelim;
      this.rightDelim = options == null ? void 0 : options.rightDelim;
    }
    static fromJson(json, context) {
      return new GenfracAtom(
        json.command,
        json.above,
        json.below,
        context,
        json
      );
    }
    toJson() {
      const options = {};
      if (this.continuousFraction)
        options.continuousFraction = true;
      if (this.numerPrefix)
        options.numerPrefix = this.numerPrefix;
      if (this.denomPrefix)
        options.denomPrefix = this.denomPrefix;
      if (this.leftDelim)
        options.leftDelim = this.leftDelim;
      if (this.rightDelim)
        options.rightDelim = this.rightDelim;
      if (!this.hasBarLine)
        options.hasBarLine = false;
      if (this.mathstyleName)
        options.mathstyleName = this.mathstyleName;
      return __spreadValues(__spreadValues({}, super.toJson()), options);
    }
    serialize(options) {
      return this.command + `{${this.aboveToLatex(options)}}{${this.belowToLatex(options)}}`;
    }
    // The order of the children, which is used for keyboard navigation order,
    // may be customized for fractions...
    get children() {
      if (this._children)
        return this._children;
      const result = [];
      if (this.context.fractionNavigationOrder === "numerator-denominator") {
        for (const x of this.above) {
          result.push(...x.children);
          result.push(x);
        }
        for (const x of this.below) {
          result.push(...x.children);
          result.push(x);
        }
      } else {
        for (const x of this.below) {
          result.push(...x.children);
          result.push(x);
        }
        for (const x of this.above) {
          result.push(...x.children);
          result.push(x);
        }
      }
      this._children = result;
      return result;
    }
    render(context) {
      var _a3, _b3;
      const fracContext = new Context(context, this.style, this.mathstyleName);
      const metrics = fracContext.metrics;
      const numContext = new Context(
        fracContext,
        this.style,
        this.continuousFraction ? "" : "numerator"
      );
      const numerBox = this.numerPrefix ? new Box(
        [new Box(this.numerPrefix), Atom.createBox(numContext, this.above)],
        { isTight: numContext.isTight, newList: true }
      ) : (_a3 = Atom.createBox(numContext, this.above, { newList: true })) != null ? _a3 : new Box(null, { newList: true });
      const denomContext = new Context(
        fracContext,
        this.style,
        this.continuousFraction ? "" : "denominator"
      );
      const denomBox = this.denomPrefix ? new Box([
        new Box(this.denomPrefix),
        Atom.createBox(denomContext, this.below, { newList: true })
      ]) : (_b3 = Atom.createBox(denomContext, this.below, { newList: true })) != null ? _b3 : new Box(null, { newList: true });
      const ruleWidth = this.hasBarLine ? metrics.defaultRuleThickness : 0;
      let numerShift;
      let clearance = 0;
      let denomShift;
      if (fracContext.isDisplayStyle) {
        numerShift = metrics.num1;
        clearance = ruleWidth > 0 ? 3 * ruleWidth : 7 * ruleWidth;
        denomShift = metrics.denom1;
      } else {
        if (ruleWidth > 0) {
          numerShift = metrics.num2;
          clearance = ruleWidth;
        } else {
          numerShift = metrics.num3;
          clearance = 3 * ruleWidth;
        }
        denomShift = metrics.denom2;
      }
      const classes = [];
      if (this.isSelected)
        classes.push("ML__selected");
      const numerDepth = numerBox.depth;
      const denomHeight = denomBox.height;
      let frac;
      if (ruleWidth <= 0) {
        const candidateClearance = numerShift - numerDepth - (denomHeight - denomShift);
        if (candidateClearance < clearance) {
          numerShift += (clearance - candidateClearance) / 2;
          denomShift += (clearance - candidateClearance) / 2;
        }
        frac = new VBox({
          individualShift: [
            {
              box: numerBox,
              shift: -numerShift,
              classes: [...classes, "ML__center"]
            },
            {
              box: denomBox,
              shift: denomShift,
              classes: [...classes, "ML__center"]
            }
          ]
        }).wrap(fracContext);
      } else {
        const numerLine = AXIS_HEIGHT + ruleWidth / 2;
        const denomLine = AXIS_HEIGHT - ruleWidth / 2;
        if (numerShift < clearance + numerDepth + numerLine)
          numerShift = clearance + numerDepth + numerLine;
        if (denomShift < clearance + denomHeight - denomLine)
          denomShift = clearance + denomHeight - denomLine;
        const fracLine = new Box(null, {
          classes: "ML__frac-line",
          mode: this.mode,
          style: this.style
        });
        fracLine.height = ruleWidth / 2;
        fracLine.depth = ruleWidth / 2;
        frac = new VBox({
          individualShift: [
            {
              box: denomBox,
              shift: denomShift,
              classes: [...classes, "ML__center"]
            },
            { box: fracLine, shift: -denomLine + ruleWidth / 2, classes },
            {
              box: numerBox,
              shift: -numerShift,
              classes: [...classes, "ML__center"]
            }
          ]
        }).wrap(fracContext);
      }
      const delimSize = fracContext.isDisplayStyle ? metrics.delim1 : metrics.delim2;
      const selectClasses = this.isSelected ? " ML__selected" : "";
      const leftDelim = this.leftDelim ? this.bind(
        context,
        makeCustomSizedDelim(
          "mopen",
          this.leftDelim,
          delimSize,
          true,
          context,
          { style: this.style, mode: this.mode, classes: selectClasses }
        )
      ) : makeNullDelimiter(fracContext, "mopen");
      let rightDelim = null;
      if (this.continuousFraction) {
        rightDelim = new Box(null, { type: "mclose" });
      } else if (!this.rightDelim)
        rightDelim = makeNullDelimiter(fracContext, "mclose");
      else {
        rightDelim = this.bind(
          context,
          makeCustomSizedDelim(
            "mclose",
            this.rightDelim,
            delimSize,
            true,
            context,
            { style: this.style, mode: this.mode, classes: selectClasses }
          )
        );
      }
      const result = this.bind(
        context,
        new Box([leftDelim, frac, rightDelim], {
          isTight: fracContext.isTight,
          type: "mord",
          classes: "mfrac"
        })
      );
      if (!result)
        return null;
      if (this.caret)
        result.caret = this.caret;
      return this.attachSupsub(context, { base: result });
    }
  };

  // src/core-atoms/delim.ts
  var DelimAtom = class extends Atom {
    constructor(command, delim, context, options) {
      super("delim", context, { command, style: options == null ? void 0 : options.style });
      this.value = delim;
      this.size = options == null ? void 0 : options.size;
    }
    static fromJson(json, context) {
      return new DelimAtom(json.command, json.delim, context, json);
    }
    toJson() {
      return __spreadProps(__spreadValues({}, super.toJson()), { delim: this.value, size: this.size });
    }
    render(_context) {
      const box = new Box(null);
      box.delim = this.value;
      return box;
    }
    serialize(_options) {
      if (this.value.length === 1)
        return this.command + this.value;
      return `${this.command}{${this.value}}`;
    }
  };
  var SizedDelimAtom = class extends Atom {
    constructor(command, delim, context, options) {
      super("sizeddelim", context, { command, style: options.style });
      this.value = delim;
      this.delimClass = options.delimClass;
      this.size = options.size;
    }
    static fromJson(json, context) {
      return new SizedDelimAtom(json.command, json.delim, context, json);
    }
    toJson() {
      return __spreadProps(__spreadValues({}, super.toJson()), {
        delim: this.value,
        size: this.size,
        delimClass: this.delimClass
      });
    }
    render(context) {
      let result = makeSizedDelim(this.value, this.size, context, {
        classes: this.delimClass
      });
      if (!result)
        return null;
      result = this.bind(context, result);
      if (this.caret)
        result.caret = this.caret;
      return result;
    }
    serialize(_options) {
      if (this.value.length === 1)
        return this.command + this.value;
      return `${this.command}{${this.value}}`;
    }
  };

  // src/core-definitions/functions.ts
  defineFunction(
    [
      "arccos",
      "arcsin",
      "arctan",
      "arctg",
      // Not LaTeX standard. Used in France
      "arcctg",
      // Not LaTeX standard. Used in France
      "arg",
      "ch",
      // Not LaTeX standard. \cosh
      "cos",
      "cosh",
      "cot",
      "cotg",
      // Not LaTeX standard. Used in France
      "coth",
      "ctg",
      // Not LaTeX standard. Used in France
      "cth",
      "csc",
      // Not LaTeX standard. \cth
      "cosec",
      // Not LaTeX standard.
      "dim",
      "exp",
      "hom",
      "inf",
      "ker",
      "lb",
      // Not LaTeX standard. US Dept of Commerce recommendation for log2
      "lg",
      // Not LaTeX standard. In German and Russian literature,  log10.
      // Sometimes used as the log2
      "ln",
      "log",
      "Pr",
      "sec",
      "sh",
      // Not LaTeX standard. \sinh
      "sin",
      "sinh",
      "sup",
      "tan",
      "tanh",
      "tg",
      // Not LaTeX standard. Used in France
      "th",
      // Not LaTeX standard. \tanh
      "arcsec",
      "arccsc",
      "arsinh",
      "arcosh",
      "artanh",
      "arcsech",
      "arccsch"
    ],
    "",
    {
      isFunction: true,
      createAtom: (command, _args, style, context) => new OperatorAtom(command, command.slice(1), context, {
        limits: "adjacent",
        isFunction: true,
        variant: "main",
        variantStyle: "up",
        style
      })
    }
  );
  defineFunction(["liminf", "limsup"], "", {
    createAtom: (command, _args, style, context) => new OperatorAtom(
      command,
      { "\\liminf": "lim inf", "\\limsup": "lim sup" }[command],
      context,
      {
        limits: "over-under",
        variant: "main",
        style
      }
    )
  });
  defineFunction(["lim", "mod"], "", {
    createAtom: (command, _args, style, context) => new OperatorAtom(command, command.slice(1), context, {
      limits: "over-under",
      variant: "main",
      style
    })
  });
  defineFunction(["det", "max", "min"], "", {
    isFunction: true,
    createAtom: (command, _args, style, context) => new OperatorAtom(command, command.slice(1), context, {
      limits: "over-under",
      isFunction: true,
      variant: "main",
      style
    })
  });
  defineFunction(["ang"], "{:math}", {
    isFunction: true,
    createAtom: (_command, args, style, context) => new GroupAtom(
      [
        ...args[0],
        new Atom("mord", context, { value: "\xB0", style })
      ],
      context,
      {
        mode: "math",
        latexOpen: "\\ang{",
        latexClose: "}",
        style
      }
    )
  });
  defineFunction("sqrt", "[index:auto]{radicand:auto}", {
    createAtom: (command, args, style, context) => new SurdAtom(command, context, {
      body: args[1],
      index: args[0],
      style
    })
  });
  defineFunction(
    ["frac", "dfrac", "tfrac", "cfrac", "binom", "dbinom", "tbinom"],
    "{numerator}{denominator}",
    {
      createAtom: (command, args, style, context) => {
        const options = { style };
        switch (command) {
          case "\\dfrac":
          case "\\frac":
          case "\\tfrac":
            options.hasBarLine = true;
            break;
          case "\\atopfrac":
            options.hasBarLine = false;
            break;
          case "\\dbinom":
          case "\\binom":
          case "\\tbinom":
            options.hasBarLine = false;
            options.leftDelim = "(";
            options.rightDelim = ")";
            break;
          default:
        }
        switch (command) {
          case "\\dfrac":
          case "\\dbinom":
            options.mathstyleName = "displaystyle";
            break;
          case "\\tfrac":
          case "\\tbinom":
            options.mathstyleName = "textstyle";
            break;
          case "\\cfrac":
            options.hasBarLine = true;
            options.continuousFraction = true;
            break;
          default:
        }
        return new GenfracAtom(
          command,
          args[0],
          args[1],
          context,
          options
        );
      }
    }
  );
  defineFunction(["brace", "brack"], "", {
    infix: true,
    createAtom: (command, args, style, context) => new GenfracAtom(command, args[0], args[1], context, {
      hasBarLine: false,
      leftDelim: command === "\\brace" ? "\\lbrace" : "\\lbrack",
      rightDelim: command === "\\brace" ? "\\rbrace" : "\\rbrack",
      style,
      serialize: (atom, options) => joinLatex([
        atom.aboveToLatex(options),
        atom.command,
        atom.belowToLatex(options)
      ])
    })
  });
  defineFunction(["over", "atop", "choose"], "", {
    infix: true,
    createAtom: (command, args, style, context) => {
      let leftDelim = void 0;
      let rightDelim = void 0;
      if (command === "\\choose") {
        leftDelim = "(";
        rightDelim = ")";
      }
      return new GenfracAtom(
        command,
        args[0],
        args[1],
        context,
        {
          hasBarLine: command === "\\over",
          leftDelim,
          rightDelim,
          style,
          serialize: (atom, options) => joinLatex([
            atom.aboveToLatex(options),
            atom.command,
            atom.belowToLatex(options)
          ])
        }
      );
    }
  });
  defineFunction(
    ["overwithdelims", "atopwithdelims"],
    "{numer:auto}{denom:auto}{left-delim:delim}{right-delim:delim}",
    {
      infix: true,
      createAtom: (name, args, style, context) => new GenfracAtom(name, args[0], args[1], context, {
        leftDelim: args[2],
        rightDelim: args[3],
        hasBarLine: false,
        style,
        serialize: (atom, options) => `${atom.aboveToLatex(options)} ${atom.command}${atom.leftDelim}${atom.rightDelim}${atom.belowToLatex(options)}`
      })
    }
  );
  defineFunction("pdiff", "{numerator}{denominator}", {
    createAtom: (command, args, style, context) => new GenfracAtom(command, args[0], args[1], context, {
      hasBarLine: true,
      numerPrefix: "\u2202",
      denomPrefix: "\u2202",
      style
    })
  });
  defineFunction(
    [
      "sum",
      "prod",
      "bigcup",
      "bigcap",
      "coprod",
      "bigvee",
      "bigwedge",
      "biguplus",
      "bigotimes",
      "bigoplus",
      "bigodot",
      "bigsqcup",
      "intop"
    ],
    "",
    {
      createAtom: (command, args, style, context) => new OperatorAtom(
        command,
        {
          coprod: "\u2210",
          bigvee: "\u22C1",
          bigwedge: "\u22C0",
          biguplus: "\u2A04",
          bigcap: "\u22C2",
          bigcup: "\u22C3",
          intop: "\u222B",
          prod: "\u220F",
          sum: "\u2211",
          bigotimes: "\u2A02",
          bigoplus: "\u2A01",
          bigodot: "\u2A00",
          bigsqcup: "\u2A06",
          smallint: "\u222B"
        }[command.slice(1)],
        context,
        {
          isExtensibleSymbol: true,
          limits: "auto",
          variant: "main",
          style
        }
      )
    }
  );
  defineFunction("smallint", "", {
    createAtom: (command, _args, style, context) => new OperatorAtom(command, "\u222B", context, {
      limits: "adjacent",
      isExtensibleSymbol: false,
      style,
      variant: "main"
    })
  });
  var EXTENSIBLE_SYMBOLS = {
    int: "\u222B",
    iint: "\u222C",
    iiint: "\u222D",
    oint: "\u222E",
    oiint: "\u222F",
    oiiint: "\u2230",
    intclockwise: "\u2231",
    varointclockwise: "\u2232",
    ointctrclockwise: "\u2233",
    intctrclockwise: "\u2A11",
    sqcup: "\u2294",
    sqcap: "\u2293",
    uplus: "\u228E",
    wr: "\u2240",
    amalg: "\u2A3F",
    Cap: "\u22D2",
    Cup: "\u22D3",
    doublecap: "\u22D2",
    doublecup: "\u22D3"
  };
  defineFunction(Object.keys(EXTENSIBLE_SYMBOLS), "", {
    createAtom: (command, _args, style, context) => new OperatorAtom(command, EXTENSIBLE_SYMBOLS[command.slice(1)], context, {
      limits: "adjacent",
      isExtensibleSymbol: true,
      style,
      variant: { "\u22D2": "ams", "\u22D3": "ams" }[EXTENSIBLE_SYMBOLS[command.slice(1)]]
    })
  });
  defineFunction(["Re", "Im"], "", {
    createAtom: (command, _args, style, context) => new OperatorAtom(
      command,
      { "\\Re": "\u211C", "\\Im": "\u2111" }[command],
      context,
      {
        limits: "adjacent",
        style,
        isFunction: true,
        variant: "fraktur"
      }
    )
  });
  defineFunction("middle", "{:delim}", {
    createAtom: (command, args, style, context) => new DelimAtom(command, args[0], context, { size: 1, style })
  });

  // src/core-definitions/mhchem.ts
  var ChemAtom = class extends Atom {
    constructor(command, arg, context) {
      super("chem", context, { command, mode: "math" });
      const tex = texify.go(
        mhchemParser.go(arg, command === "\\pu" ? "pu" : "ce"),
        false
      );
      this.body = parseLatex(tex, context);
      this.verbatimLatex = command + "{" + arg + "}";
      this.arg = arg;
      this.captureSelection = true;
    }
    static fromJson(json, context) {
      return new ChemAtom(json.command, json.arg, context);
    }
    toJson() {
      return __spreadProps(__spreadValues({}, super.toJson()), { arg: this.arg });
    }
    render(context) {
      const box = Atom.createBox(context, this.body, {
        type: "chem",
        newList: true
      });
      if (this.caret)
        box.caret = this.caret;
      return this.bind(context, box);
    }
    serialize(_options) {
      return this.verbatimLatex;
    }
  };
  defineFunction(["ce", "pu"], "{chemformula:balanced-string}", {
    createAtom: (command, args, _style, context) => new ChemAtom(command, args[0], context)
  });
  var mhchemParser = {
    //
    // Parses mchem \ce syntax
    //
    // Call like
    //   go("H2O");
    //
    go: function(input, stateMachine) {
      if (!input) {
        return [];
      }
      if (stateMachine === void 0) {
        stateMachine = "ce";
      }
      var state = "0";
      var buffer = {};
      buffer["parenthesisLevel"] = 0;
      input = input.replace(/\n/g, " ");
      input = input.replace(/[\u2212\u2013\u2014\u2010]/g, "-");
      input = input.replace(/[\u2026]/g, "...");
      var lastInput;
      var watchdog = 10;
      var output = [];
      while (true) {
        if (lastInput !== input) {
          watchdog = 10;
          lastInput = input;
        } else {
          watchdog--;
        }
        var machine = mhchemParser.stateMachines[stateMachine];
        var t = machine.transitions[state] || machine.transitions["*"];
        iterateTransitions:
          for (var i = 0; i < t.length; i++) {
            var matches = mhchemParser.patterns.match_(t[i].pattern, input);
            if (matches) {
              var task = t[i].task;
              for (var iA = 0; iA < task.action_.length; iA++) {
                var o;
                if (machine.actions[task.action_[iA].type_]) {
                  o = machine.actions[task.action_[iA].type_](
                    buffer,
                    matches.match_,
                    task.action_[iA].option
                  );
                } else if (mhchemParser.actions[task.action_[iA].type_]) {
                  o = mhchemParser.actions[task.action_[iA].type_](
                    buffer,
                    matches.match_,
                    task.action_[iA].option
                  );
                } else {
                  throw [
                    "MhchemBugA",
                    "mhchem bug A. Please report. (" + task.action_[iA].type_ + ")"
                  ];
                }
                mhchemParser.concatArray(output, o);
              }
              state = task.nextState || state;
              if (input.length > 0) {
                if (!task.revisit) {
                  input = matches.remainder;
                }
                if (!task.toContinue) {
                  break iterateTransitions;
                }
              } else {
                return output;
              }
            }
          }
        if (watchdog <= 0) {
          throw ["MhchemBugU", "mhchem bug U. Please report."];
        }
      }
    },
    concatArray: function(a, b) {
      if (b) {
        if (Array.isArray(b)) {
          for (var iB = 0; iB < b.length; iB++) {
            a.push(b[iB]);
          }
        } else {
          a.push(b);
        }
      }
    },
    patterns: {
      //
      // Matching patterns
      // either regexps or function that return null or {match_:"a", remainder:"bc"}
      //
      patterns: {
        // property names must not look like integers ("2") for correct property traversal order, later on
        "empty": /^$/,
        "else": /^./,
        "else2": /^./,
        "space": /^\s/,
        "space A": /^\s(?=[A-Z\\$])/,
        "space$": /^\s$/,
        "a-z": /^[a-z]/,
        "x": /^x/,
        "x$": /^x$/,
        "i$": /^i$/,
        "letters": /^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,
        "\\greek": /^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,
        "one lowercase latin letter $": /^(?:([a-z])(?:$|[^a-zA-Z]))$/,
        "$one lowercase latin letter$ $": /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,
        "one lowercase greek letter $": /^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,
        "digits": /^[0-9]+/,
        "-9.,9": /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,
        "-9.,9 no missing 0": /^[+\-]?[0-9]+(?:[.,][0-9]+)?/,
        "(-)(9.,9)(e)(99)": function(input) {
          var m = input.match(
            /^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/
          );
          if (m && m[0]) {
            return {
              match_: m.splice(1),
              remainder: input.substr(m[0].length)
            };
          }
          return null;
        },
        "(-)(9)^(-9)": function(input) {
          var m = input.match(
            /^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/
          );
          if (m && m[0]) {
            return {
              match_: m.splice(1),
              remainder: input.substr(m[0].length)
            };
          }
          return null;
        },
        "state of aggregation $": function(input) {
          var a = mhchemParser.patterns.findObserveGroups(
            input,
            "",
            /^\([a-z]{1,3}(?=[\),])/,
            ")",
            ""
          );
          if (a && a.remainder.match(/^($|[\s,;\)\]\}])/)) {
            return a;
          }
          var m = input.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);
          if (m) {
            return {
              match_: m[0],
              remainder: input.substr(m[0].length)
            };
          }
          return null;
        },
        "_{(state of aggregation)}$": /^_\{(\([a-z]{1,3}\))\}/,
        "{[(": /^(?:\\\{|\[|\()/,
        ")]}": /^(?:\)|\]|\\\})/,
        ", ": /^[,;]\s*/,
        ",": /^[,;]/,
        ".": /^[.]/,
        ". ": /^([.\u22C5\u00B7\u2022])\s*/,
        "...": /^\.\.\.(?=$|[^.])/,
        "* ": /^([*])\s*/,
        "^{(...)}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "^{",
            "",
            "",
            "}"
          );
        },
        "^($...$)": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "^",
            "$",
            "$",
            ""
          );
        },
        "^a": /^\^([0-9]+|[^\\_])/,
        "^\\x{}{}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "^",
            /^\\[a-zA-Z]+\{/,
            "}",
            "",
            "",
            "{",
            "}",
            "",
            true
          );
        },
        "^\\x{}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "^",
            /^\\[a-zA-Z]+\{/,
            "}",
            ""
          );
        },
        "^\\x": /^\^(\\[a-zA-Z]+)\s*/,
        "^(-1)": /^\^(-?\d+)/,
        "'": /^'/,
        "_{(...)}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "_{",
            "",
            "",
            "}"
          );
        },
        "_($...$)": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "_",
            "$",
            "$",
            ""
          );
        },
        "_9": /^_([+\-]?[0-9]+|[^\\])/,
        "_\\x{}{}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "_",
            /^\\[a-zA-Z]+\{/,
            "}",
            "",
            "",
            "{",
            "}",
            "",
            true
          );
        },
        "_\\x{}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "_",
            /^\\[a-zA-Z]+\{/,
            "}",
            ""
          );
        },
        "_\\x": /^_(\\[a-zA-Z]+)\s*/,
        "^_": /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,
        "{}": /^\{\}/,
        "{...}": function(input) {
          return mhchemParser.patterns.findObserveGroups(input, "", "{", "}", "");
        },
        "{(...)}": function(input) {
          return mhchemParser.patterns.findObserveGroups(input, "{", "", "", "}");
        },
        "$...$": function(input) {
          return mhchemParser.patterns.findObserveGroups(input, "", "$", "$", "");
        },
        "${(...)}$": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "${",
            "",
            "",
            "}$"
          );
        },
        "$(...)$": function(input) {
          return mhchemParser.patterns.findObserveGroups(input, "$", "", "", "$");
        },
        "=<>": /^[=<>]/,
        "#": /^[#\u2261]/,
        "+": /^\+/,
        "-$": /^-(?=[\s_},;\]/]|$|\([a-z]+\))/,
        // -space -, -; -] -/ -$ -state-of-aggregation
        "-9": /^-(?=[0-9])/,
        "- orbital overlap": /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,
        "-": /^-/,
        "pm-operator": /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,
        "operator": /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,
        "arrowUpDown": /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,
        "\\bond{(...)}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "\\bond{",
            "",
            "",
            "}"
          );
        },
        "->": /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,
        "CMT": /^[CMT](?=\[)/,
        "[(...)]": function(input) {
          return mhchemParser.patterns.findObserveGroups(input, "[", "", "", "]");
        },
        "1st-level escape": /^(&|\\\\|\\hline)\s*/,
        "\\,": /^(?:\\[,\ ;:])/,
        // \\x - but output no space before
        "\\x{}{}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "",
            /^\\[a-zA-Z]+\{/,
            "}",
            "",
            "",
            "{",
            "}",
            "",
            true
          );
        },
        "\\x{}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "",
            /^\\[a-zA-Z]+\{/,
            "}",
            ""
          );
        },
        "\\ca": /^\\ca(?:\s+|(?![a-zA-Z]))/,
        "\\x": /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,
        "orbital": /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,
        // only those with numbers in front, because the others will be formatted correctly anyway
        "others": /^[\/~|]/,
        "\\frac{(...)}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "\\frac{",
            "",
            "",
            "}",
            "{",
            "",
            "",
            "}"
          );
        },
        "\\overset{(...)}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "\\overset{",
            "",
            "",
            "}",
            "{",
            "",
            "",
            "}"
          );
        },
        "\\underset{(...)}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "\\underset{",
            "",
            "",
            "}",
            "{",
            "",
            "",
            "}"
          );
        },
        "\\underbrace{(...)}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "\\underbrace{",
            "",
            "",
            "}_",
            "{",
            "",
            "",
            "}"
          );
        },
        "\\color{(...)}0": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "\\color{",
            "",
            "",
            "}"
          );
        },
        "\\color{(...)}{(...)}1": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "\\color{",
            "",
            "",
            "}",
            "{",
            "",
            "",
            "}"
          );
        },
        "\\color(...){(...)}2": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "\\color",
            "\\",
            "",
            /^(?=\{)/,
            "{",
            "",
            "",
            "}"
          );
        },
        "\\ce{(...)}": function(input) {
          return mhchemParser.patterns.findObserveGroups(
            input,
            "\\ce{",
            "",
            "",
            "}"
          );
        },
        "oxidation$": /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
        "d-oxidation$": /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
        // 0 could be oxidation or charge
        "roman numeral": /^[IVX]+/,
        "1/2$": /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,
        "amount": function(input) {
          var match;
          match = input.match(
            /^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/
          );
          if (match) {
            return {
              match_: match[0],
              remainder: input.substr(match[0].length)
            };
          }
          var a = mhchemParser.patterns.findObserveGroups(
            input,
            "",
            "$",
            "$",
            ""
          );
          if (a) {
            match = a.match_.match(
              /^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/
            );
            if (match) {
              return {
                match_: match[0],
                remainder: input.substr(match[0].length)
              };
            }
          }
          return null;
        },
        "amount2": function(input) {
          return this["amount"](input);
        },
        "(KV letters),": /^(?:[A-Z][a-z]{0,2}|i)(?=,)/,
        "formula$": function(input) {
          if (input.match(/^\([a-z]+\)$/)) {
            return null;
          }
          var match = input.match(
            /^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/
          );
          if (match) {
            return {
              match_: match[0],
              remainder: input.substr(match[0].length)
            };
          }
          return null;
        },
        "uprightEntities": /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,
        "/": /^\s*(\/)\s*/,
        "//": /^\s*(\/\/)\s*/,
        "*": /^\s*[*.]\s*/
      },
      findObserveGroups: function(input, begExcl, begIncl, endIncl, endExcl, beg2Excl, beg2Incl, end2Incl, end2Excl, combine) {
        var _match = function(input2, pattern) {
          if (typeof pattern === "string") {
            if (input2.indexOf(pattern) !== 0) {
              return null;
            }
            return pattern;
          } else {
            var match2 = input2.match(pattern);
            if (!match2) {
              return null;
            }
            return match2[0];
          }
        };
        var _findObserveGroups = function(input2, i, endChars) {
          var braces = 0;
          while (i < input2.length) {
            var a = input2.charAt(i);
            var match2 = _match(input2.substr(i), endChars);
            if (match2 !== null && braces === 0) {
              return {
                endMatchBegin: i,
                endMatchEnd: i + match2.length
              };
            } else if (a === "{") {
              braces++;
            } else if (a === "}") {
              if (braces === 0) {
                throw [
                  "ExtraCloseMissingOpen",
                  "Extra close brace or missing open brace"
                ];
              } else {
                braces--;
              }
            }
            i++;
          }
          if (braces > 0) {
            return null;
          }
          return null;
        };
        var match = _match(input, begExcl);
        if (match === null) {
          return null;
        }
        input = input.substr(match.length);
        match = _match(input, begIncl);
        if (match === null) {
          return null;
        }
        var e = _findObserveGroups(input, match.length, endIncl || endExcl);
        if (e === null) {
          return null;
        }
        var match1 = input.substring(
          0,
          endIncl ? e.endMatchEnd : e.endMatchBegin
        );
        if (!(beg2Excl || beg2Incl)) {
          return {
            match_: match1,
            remainder: input.substr(e.endMatchEnd)
          };
        } else {
          var group2 = this.findObserveGroups(
            input.substr(e.endMatchEnd),
            beg2Excl,
            beg2Incl,
            end2Incl,
            end2Excl
          );
          if (group2 === null) {
            return null;
          }
          var matchRet = [match1, group2.match_];
          return {
            match_: combine ? matchRet.join("") : matchRet,
            remainder: group2.remainder
          };
        }
      },
      //
      // Matching function
      // e.g. match("a", input) will look for the regexp called "a" and see if it matches
      // returns null or {match_:"a", remainder:"bc"}
      //
      match_: function(m, input) {
        var pattern = mhchemParser.patterns.patterns[m];
        if (pattern === void 0) {
          throw ["MhchemBugP", "mhchem bug P. Please report. (" + m + ")"];
        } else if (typeof pattern === "function") {
          return mhchemParser.patterns.patterns[m](input);
        } else {
          var match = input.match(pattern);
          if (match) {
            var mm;
            if (match[2]) {
              mm = [match[1], match[2]];
            } else if (match[1]) {
              mm = match[1];
            } else {
              mm = match[0];
            }
            return {
              match_: mm,
              remainder: input.substr(match[0].length)
            };
          }
          return null;
        }
      }
    },
    //
    // Generic state machine actions
    //
    actions: {
      "a=": function(buffer, m) {
        buffer.a = (buffer.a || "") + m;
      },
      "b=": function(buffer, m) {
        buffer.b = (buffer.b || "") + m;
      },
      "p=": function(buffer, m) {
        buffer.p = (buffer.p || "") + m;
      },
      "o=": function(buffer, m) {
        buffer.o = (buffer.o || "") + m;
      },
      "q=": function(buffer, m) {
        buffer.q = (buffer.q || "") + m;
      },
      "d=": function(buffer, m) {
        buffer.d = (buffer.d || "") + m;
      },
      "rm=": function(buffer, m) {
        buffer.rm = (buffer.rm || "") + m;
      },
      "text=": function(buffer, m) {
        buffer.text_ = (buffer.text_ || "") + m;
      },
      "insert": function(buffer, m, a) {
        return { type_: a };
      },
      "insert+p1": function(buffer, m, a) {
        return { type_: a, p1: m };
      },
      "insert+p1+p2": function(buffer, m, a) {
        return { type_: a, p1: m[0], p2: m[1] };
      },
      "copy": function(buffer, m) {
        return m;
      },
      "rm": function(buffer, m) {
        return { type_: "rm", p1: m || "" };
      },
      "text": function(buffer, m) {
        return mhchemParser.go(m, "text");
      },
      "{text}": function(buffer, m) {
        var ret = ["{"];
        mhchemParser.concatArray(ret, mhchemParser.go(m, "text"));
        ret.push("}");
        return ret;
      },
      "tex-math": function(buffer, m) {
        return mhchemParser.go(m, "tex-math");
      },
      "tex-math tight": function(buffer, m) {
        return mhchemParser.go(m, "tex-math tight");
      },
      "bond": function(buffer, m, k) {
        return { type_: "bond", kind_: k || m };
      },
      "color0-output": function(buffer, m) {
        return { type_: "color0", color: m[0] };
      },
      "ce": function(buffer, m) {
        return mhchemParser.go(m);
      },
      "1/2": function(buffer, m) {
        var ret = [];
        if (m.match(/^[+\-]/)) {
          ret.push(m.substr(0, 1));
          m = m.substr(1);
        }
        var n = m.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
        n[1] = n[1].replace(/\$/g, "");
        ret.push({ type_: "frac", p1: n[1], p2: n[2] });
        if (n[3]) {
          n[3] = n[3].replace(/\$/g, "");
          ret.push({ type_: "tex-math", p1: n[3] });
        }
        return ret;
      },
      "9,9": function(buffer, m) {
        return mhchemParser.go(m, "9,9");
      }
    },
    //
    // createTransitions
    // convert  { 'letter': { 'state': { action_: 'output' } } }  to  { 'state' => [ { pattern: 'letter', task: { action_: [{type_: 'output'}] } } ] }
    // with expansion of 'a|b' to 'a' and 'b' (at 2 places)
    //
    createTransitions: function(o) {
      var pattern, state;
      var stateArray;
      var i;
      var transitions = {};
      for (pattern in o) {
        for (state in o[pattern]) {
          stateArray = state.split("|");
          o[pattern][state].stateArray = stateArray;
          for (i = 0; i < stateArray.length; i++) {
            transitions[stateArray[i]] = [];
          }
        }
      }
      for (pattern in o) {
        for (state in o[pattern]) {
          stateArray = o[pattern][state].stateArray || [];
          for (i = 0; i < stateArray.length; i++) {
            var p = o[pattern][state];
            if (p.action_) {
              p.action_ = [].concat(p.action_);
              for (var k = 0; k < p.action_.length; k++) {
                if (typeof p.action_[k] === "string") {
                  p.action_[k] = { type_: p.action_[k] };
                }
              }
            } else {
              p.action_ = [];
            }
            var patternArray = pattern.split("|");
            for (var j = 0; j < patternArray.length; j++) {
              if (stateArray[i] === "*") {
                for (var t in transitions) {
                  transitions[t].push({
                    pattern: patternArray[j],
                    task: p
                  });
                }
              } else {
                transitions[stateArray[i]].push({
                  pattern: patternArray[j],
                  task: p
                });
              }
            }
          }
        }
      }
      return transitions;
    },
    stateMachines: {}
  };
  mhchemParser.stateMachines = {
    //
    // \ce state machines
    //
    //#region ce
    "ce": {
      // main parser
      transitions: mhchemParser.createTransitions({
        "empty": {
          "*": { action_: "output" }
        },
        "else": {
          "0|1|2": {
            action_: "beginsWithBond=false",
            revisit: true,
            toContinue: true
          }
        },
        "oxidation$": {
          "0": { action_: "oxidation-output" }
        },
        "CMT": {
          r: { action_: "rdt=", nextState: "rt" },
          rd: { action_: "rqt=", nextState: "rdt" }
        },
        "arrowUpDown": {
          "0|1|2|as": {
            action_: ["sb=false", "output", "operator"],
            nextState: "1"
          }
        },
        "uprightEntities": {
          "0|1|2": { action_: ["o=", "output"], nextState: "1" }
        },
        "orbital": {
          "0|1|2|3": { action_: "o=", nextState: "o" }
        },
        "->": {
          "0|1|2|3": { action_: "r=", nextState: "r" },
          "a|as": { action_: ["output", "r="], nextState: "r" },
          "*": { action_: ["output", "r="], nextState: "r" }
        },
        "+": {
          "o": { action_: "d= kv", nextState: "d" },
          "d|D": { action_: "d=", nextState: "d" },
          "q": { action_: "d=", nextState: "qd" },
          "qd|qD": { action_: "d=", nextState: "qd" },
          "dq": { action_: ["output", "d="], nextState: "d" },
          "3": {
            action_: ["sb=false", "output", "operator"],
            nextState: "0"
          }
        },
        "amount": {
          "0|2": { action_: "a=", nextState: "a" }
        },
        "pm-operator": {
          "0|1|2|a|as": {
            action_: [
              "sb=false",
              "output",
              { type_: "operator", option: "\\pm" }
            ],
            nextState: "0"
          }
        },
        "operator": {
          "0|1|2|a|as": {
            action_: ["sb=false", "output", "operator"],
            nextState: "0"
          }
        },
        "-$": {
          "o|q": {
            action_: ["charge or bond", "output"],
            nextState: "qd"
          },
          "d": { action_: "d=", nextState: "d" },
          "D": {
            action_: ["output", { type_: "bond", option: "-" }],
            nextState: "3"
          },
          "q": { action_: "d=", nextState: "qd" },
          "qd": { action_: "d=", nextState: "qd" },
          "qD|dq": {
            action_: ["output", { type_: "bond", option: "-" }],
            nextState: "3"
          }
        },
        "-9": {
          "3|o": {
            action_: ["output", { type_: "insert", option: "hyphen" }],
            nextState: "3"
          }
        },
        "- orbital overlap": {
          o: {
            action_: ["output", { type_: "insert", option: "hyphen" }],
            nextState: "2"
          },
          d: {
            action_: ["output", { type_: "insert", option: "hyphen" }],
            nextState: "2"
          }
        },
        "-": {
          "0|1|2": {
            action_: [
              { type_: "output", option: 1 },
              "beginsWithBond=true",
              { type_: "bond", option: "-" }
            ],
            nextState: "3"
          },
          "3": { action_: { type_: "bond", option: "-" } },
          "a": {
            action_: ["output", { type_: "insert", option: "hyphen" }],
            nextState: "2"
          },
          "as": {
            action_: [
              { type_: "output", option: 2 },
              { type_: "bond", option: "-" }
            ],
            nextState: "3"
          },
          "b": { action_: "b=" },
          "o": {
            action_: { type_: "- after o/d", option: false },
            nextState: "2"
          },
          "q": {
            action_: { type_: "- after o/d", option: false },
            nextState: "2"
          },
          "d|qd|dq": {
            action_: { type_: "- after o/d", option: true },
            nextState: "2"
          },
          "D|qD|p": {
            action_: ["output", { type_: "bond", option: "-" }],
            nextState: "3"
          }
        },
        "amount2": {
          "1|3": { action_: "a=", nextState: "a" }
        },
        "letters": {
          "0|1|2|3|a|as|b|p|bp|o": { action_: "o=", nextState: "o" },
          "q|dq": { action_: ["output", "o="], nextState: "o" },
          "d|D|qd|qD": { action_: "o after d", nextState: "o" }
        },
        "digits": {
          "o": { action_: "q=", nextState: "q" },
          "d|D": { action_: "q=", nextState: "dq" },
          "q": { action_: ["output", "o="], nextState: "o" },
          "a": { action_: "o=", nextState: "o" }
        },
        "space A": {
          "b|p|bp": {}
        },
        "space": {
          "a": { nextState: "as" },
          "0": { action_: "sb=false" },
          "1|2": { action_: "sb=true" },
          "r|rt|rd|rdt|rdq": { action_: "output", nextState: "0" },
          "*": { action_: ["output", "sb=true"], nextState: "1" }
        },
        "1st-level escape": {
          "1|2": {
            action_: [
              "output",
              { type_: "insert+p1", option: "1st-level escape" }
            ]
          },
          "*": {
            action_: [
              "output",
              { type_: "insert+p1", option: "1st-level escape" }
            ],
            nextState: "0"
          }
        },
        "[(...)]": {
          "r|rt": { action_: "rd=", nextState: "rd" },
          "rd|rdt": { action_: "rq=", nextState: "rdq" }
        },
        "...": {
          "o|d|D|dq|qd|qD": {
            action_: ["output", { type_: "bond", option: "..." }],
            nextState: "3"
          },
          "*": {
            action_: [
              { type_: "output", option: 1 },
              { type_: "insert", option: "ellipsis" }
            ],
            nextState: "1"
          }
        },
        ". |* ": {
          "*": {
            action_: ["output", { type_: "insert", option: "addition compound" }],
            nextState: "1"
          }
        },
        "state of aggregation $": {
          "*": {
            action_: ["output", "state of aggregation"],
            nextState: "1"
          }
        },
        "{[(": {
          "a|as|o": {
            action_: ["o=", "output", "parenthesisLevel++"],
            nextState: "2"
          },
          "0|1|2|3": {
            action_: ["o=", "output", "parenthesisLevel++"],
            nextState: "2"
          },
          "*": {
            action_: ["output", "o=", "output", "parenthesisLevel++"],
            nextState: "2"
          }
        },
        ")]}": {
          "0|1|2|3|b|p|bp|o": {
            action_: ["o=", "parenthesisLevel--"],
            nextState: "o"
          },
          "a|as|d|D|q|qd|qD|dq": {
            action_: ["output", "o=", "parenthesisLevel--"],
            nextState: "o"
          }
        },
        ", ": {
          "*": { action_: ["output", "comma"], nextState: "0" }
        },
        "^_": {
          // ^ and _ without a sensible argument
          "*": {}
        },
        "^{(...)}|^($...$)": {
          "0|1|2|as": { action_: "b=", nextState: "b" },
          "p": { action_: "b=", nextState: "bp" },
          "3|o": { action_: "d= kv", nextState: "D" },
          "q": { action_: "d=", nextState: "qD" },
          "d|D|qd|qD|dq": { action_: ["output", "d="], nextState: "D" }
        },
        "^a|^\\x{}{}|^\\x{}|^\\x|'": {
          "0|1|2|as": { action_: "b=", nextState: "b" },
          "p": { action_: "b=", nextState: "bp" },
          "3|o": { action_: "d= kv", nextState: "d" },
          "q": { action_: "d=", nextState: "qd" },
          "d|qd|D|qD": { action_: "d=" },
          "dq": { action_: ["output", "d="], nextState: "d" }
        },
        "_{(state of aggregation)}$": {
          "d|D|q|qd|qD|dq": { action_: ["output", "q="], nextState: "q" }
        },
        "_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x": {
          "0|1|2|as": { action_: "p=", nextState: "p" },
          "b": { action_: "p=", nextState: "bp" },
          "3|o": { action_: "q=", nextState: "q" },
          "d|D": { action_: "q=", nextState: "dq" },
          "q|qd|qD|dq": { action_: ["output", "q="], nextState: "q" }
        },
        "=<>": {
          "0|1|2|3|a|as|o|q|d|D|qd|qD|dq": {
            action_: [{ type_: "output", option: 2 }, "bond"],
            nextState: "3"
          }
        },
        "#": {
          "0|1|2|3|a|as|o": {
            action_: [
              { type_: "output", option: 2 },
              { type_: "bond", option: "#" }
            ],
            nextState: "3"
          }
        },
        "{}": {
          "*": {
            action_: { type_: "output", option: 1 },
            nextState: "1"
          }
        },
        "{...}": {
          "0|1|2|3|a|as|b|p|bp": { action_: "o=", nextState: "o" },
          "o|d|D|q|qd|qD|dq": {
            action_: ["output", "o="],
            nextState: "o"
          }
        },
        "$...$": {
          "a": { action_: "a=" },
          // 2$n$
          "0|1|2|3|as|b|p|bp|o": { action_: "o=", nextState: "o" },
          // not 'amount'
          "as|o": { action_: "o=" },
          "q|d|D|qd|qD|dq": { action_: ["output", "o="], nextState: "o" }
        },
        "\\bond{(...)}": {
          "*": {
            action_: [{ type_: "output", option: 2 }, "bond"],
            nextState: "3"
          }
        },
        "\\frac{(...)}": {
          "*": {
            action_: [{ type_: "output", option: 1 }, "frac-output"],
            nextState: "3"
          }
        },
        "\\overset{(...)}": {
          "*": {
            action_: [{ type_: "output", option: 2 }, "overset-output"],
            nextState: "3"
          }
        },
        "\\underset{(...)}": {
          "*": {
            action_: [{ type_: "output", option: 2 }, "underset-output"],
            nextState: "3"
          }
        },
        "\\underbrace{(...)}": {
          "*": {
            action_: [{ type_: "output", option: 2 }, "underbrace-output"],
            nextState: "3"
          }
        },
        "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
          "*": {
            action_: [{ type_: "output", option: 2 }, "color-output"],
            nextState: "3"
          }
        },
        "\\color{(...)}0": {
          "*": {
            action_: [{ type_: "output", option: 2 }, "color0-output"]
          }
        },
        "\\ce{(...)}": {
          "*": {
            action_: [{ type_: "output", option: 2 }, "ce"],
            nextState: "3"
          }
        },
        "\\,": {
          "*": {
            action_: [{ type_: "output", option: 1 }, "copy"],
            nextState: "1"
          }
        },
        "\\x{}{}|\\x{}|\\x": {
          "0|1|2|3|a|as|b|p|bp|o|c0": {
            action_: ["o=", "output"],
            nextState: "3"
          },
          "*": { action_: ["output", "o=", "output"], nextState: "3" }
        },
        "others": {
          "*": {
            action_: [{ type_: "output", option: 1 }, "copy"],
            nextState: "3"
          }
        },
        "else2": {
          "a": { action_: "a to o", nextState: "o", revisit: true },
          "as": {
            action_: ["output", "sb=true"],
            nextState: "1",
            revisit: true
          },
          "r|rt|rd|rdt|rdq": {
            action_: ["output"],
            nextState: "0",
            revisit: true
          },
          "*": { action_: ["output", "copy"], nextState: "3" }
        }
      }),
      actions: {
        "o after d": function(buffer, m) {
          var ret;
          if ((buffer.d || "").match(/^[0-9]+$/)) {
            var tmp = buffer.d;
            buffer.d = void 0;
            ret = this["output"](buffer);
            buffer.b = tmp;
          } else {
            ret = this["output"](buffer);
          }
          mhchemParser.actions["o="](buffer, m);
          return ret;
        },
        "d= kv": function(buffer, m) {
          buffer.d = m;
          buffer.dType = "kv";
        },
        "charge or bond": function(buffer, m) {
          if (buffer["beginsWithBond"]) {
            var ret = [];
            mhchemParser.concatArray(ret, this["output"](buffer));
            mhchemParser.concatArray(
              ret,
              mhchemParser.actions["bond"](buffer, m, "-")
            );
            return ret;
          } else {
            buffer.d = m;
          }
        },
        "- after o/d": function(buffer, m, isAfterD) {
          var c1 = mhchemParser.patterns.match_("orbital", buffer.o || "");
          var c2 = mhchemParser.patterns.match_(
            "one lowercase greek letter $",
            buffer.o || ""
          );
          var c3 = mhchemParser.patterns.match_(
            "one lowercase latin letter $",
            buffer.o || ""
          );
          var c4 = mhchemParser.patterns.match_(
            "$one lowercase latin letter$ $",
            buffer.o || ""
          );
          var hyphenFollows = m === "-" && (c1 && c1.remainder === "" || c2 || c3 || c4);
          if (hyphenFollows && !buffer.a && !buffer.b && !buffer.p && !buffer.d && !buffer.q && !c1 && c3) {
            buffer.o = "$" + buffer.o + "$";
          }
          var ret = [];
          if (hyphenFollows) {
            mhchemParser.concatArray(ret, this["output"](buffer));
            ret.push({ type_: "hyphen" });
          } else {
            c1 = mhchemParser.patterns.match_("digits", buffer.d || "");
            if (isAfterD && c1 && c1.remainder === "") {
              mhchemParser.concatArray(
                ret,
                mhchemParser.actions["d="](buffer, m)
              );
              mhchemParser.concatArray(ret, this["output"](buffer));
            } else {
              mhchemParser.concatArray(ret, this["output"](buffer));
              mhchemParser.concatArray(
                ret,
                mhchemParser.actions["bond"](buffer, m, "-")
              );
            }
          }
          return ret;
        },
        "a to o": function(buffer) {
          buffer.o = buffer.a;
          buffer.a = void 0;
        },
        "sb=true": function(buffer) {
          buffer.sb = true;
        },
        "sb=false": function(buffer) {
          buffer.sb = false;
        },
        "beginsWithBond=true": function(buffer) {
          buffer["beginsWithBond"] = true;
        },
        "beginsWithBond=false": function(buffer) {
          buffer["beginsWithBond"] = false;
        },
        "parenthesisLevel++": function(buffer) {
          buffer["parenthesisLevel"]++;
        },
        "parenthesisLevel--": function(buffer) {
          buffer["parenthesisLevel"]--;
        },
        "state of aggregation": function(buffer, m) {
          return {
            type_: "state of aggregation",
            p1: mhchemParser.go(m, "o")
          };
        },
        "comma": function(buffer, m) {
          var a = m.replace(/\s*$/, "");
          var withSpace = a !== m;
          if (withSpace && buffer["parenthesisLevel"] === 0) {
            return { type_: "comma enumeration L", p1: a };
          } else {
            return { type_: "comma enumeration M", p1: a };
          }
        },
        "output": function(buffer, m, entityFollows) {
          var ret;
          if (!buffer.r) {
            ret = [];
            if (!buffer.a && !buffer.b && !buffer.p && !buffer.o && !buffer.q && !buffer.d && !entityFollows) {
            } else {
              if (buffer.sb) {
                ret.push({ type_: "entitySkip" });
              }
              if (!buffer.o && !buffer.q && !buffer.d && !buffer.b && !buffer.p && entityFollows !== 2) {
                buffer.o = buffer.a;
                buffer.a = void 0;
              } else if (!buffer.o && !buffer.q && !buffer.d && (buffer.b || buffer.p)) {
                buffer.o = buffer.a;
                buffer.d = buffer.b;
                buffer.q = buffer.p;
                buffer.a = buffer.b = buffer.p = void 0;
              } else {
                if (buffer.o && buffer.dType === "kv" && mhchemParser.patterns.match_("d-oxidation$", buffer.d || "")) {
                  buffer.dType = "oxidation";
                } else if (buffer.o && buffer.dType === "kv" && !buffer.q) {
                  buffer.dType = void 0;
                }
              }
              ret.push({
                type_: "chemfive",
                a: mhchemParser.go(buffer.a, "a"),
                b: mhchemParser.go(buffer.b, "bd"),
                p: mhchemParser.go(buffer.p, "pq"),
                o: mhchemParser.go(buffer.o, "o"),
                q: mhchemParser.go(buffer.q, "pq"),
                d: mhchemParser.go(
                  buffer.d,
                  buffer.dType === "oxidation" ? "oxidation" : "bd"
                ),
                dType: buffer.dType
              });
            }
          } else {
            var rd;
            if (buffer.rdt === "M") {
              rd = mhchemParser.go(buffer.rd, "tex-math");
            } else if (buffer.rdt === "T") {
              rd = [{ type_: "text", p1: buffer.rd || "" }];
            } else {
              rd = mhchemParser.go(buffer.rd);
            }
            var rq;
            if (buffer.rqt === "M") {
              rq = mhchemParser.go(buffer.rq, "tex-math");
            } else if (buffer.rqt === "T") {
              rq = [{ type_: "text", p1: buffer.rq || "" }];
            } else {
              rq = mhchemParser.go(buffer.rq);
            }
            ret = {
              type_: "arrow",
              r: buffer.r,
              rd,
              rq
            };
          }
          for (var p in buffer) {
            if (p !== "parenthesisLevel" && p !== "beginsWithBond") {
              delete buffer[p];
            }
          }
          return ret;
        },
        "oxidation-output": function(buffer, m) {
          var ret = ["{"];
          mhchemParser.concatArray(ret, mhchemParser.go(m, "oxidation"));
          ret.push("}");
          return ret;
        },
        "frac-output": function(buffer, m) {
          return {
            type_: "frac-ce",
            p1: mhchemParser.go(m[0]),
            p2: mhchemParser.go(m[1])
          };
        },
        "overset-output": function(buffer, m) {
          return {
            type_: "overset",
            p1: mhchemParser.go(m[0]),
            p2: mhchemParser.go(m[1])
          };
        },
        "underset-output": function(buffer, m) {
          return {
            type_: "underset",
            p1: mhchemParser.go(m[0]),
            p2: mhchemParser.go(m[1])
          };
        },
        "underbrace-output": function(buffer, m) {
          return {
            type_: "underbrace",
            p1: mhchemParser.go(m[0]),
            p2: mhchemParser.go(m[1])
          };
        },
        "color-output": function(buffer, m) {
          return {
            type_: "color",
            color1: m[0],
            color2: mhchemParser.go(m[1])
          };
        },
        "r=": function(buffer, m) {
          buffer.r = m;
        },
        "rdt=": function(buffer, m) {
          buffer.rdt = m;
        },
        "rd=": function(buffer, m) {
          buffer.rd = m;
        },
        "rqt=": function(buffer, m) {
          buffer.rqt = m;
        },
        "rq=": function(buffer, m) {
          buffer.rq = m;
        },
        "operator": function(buffer, m, p1) {
          return { type_: "operator", kind_: p1 || m };
        }
      }
    },
    "a": {
      transitions: mhchemParser.createTransitions({
        "empty": {
          "*": {}
        },
        "1/2$": {
          "0": { action_: "1/2" }
        },
        "else": {
          "0": { nextState: "1", revisit: true }
        },
        "$(...)$": {
          "*": { action_: "tex-math tight", nextState: "1" }
        },
        ",": {
          "*": { action_: { type_: "insert", option: "commaDecimal" } }
        },
        "else2": {
          "*": { action_: "copy" }
        }
      }),
      actions: {}
    },
    "o": {
      transitions: mhchemParser.createTransitions({
        "empty": {
          "*": {}
        },
        "1/2$": {
          "0": { action_: "1/2" }
        },
        "else": {
          "0": { nextState: "1", revisit: true }
        },
        "letters": {
          "*": { action_: "rm" }
        },
        "\\ca": {
          "*": { action_: { type_: "insert", option: "circa" } }
        },
        "\\x{}{}|\\x{}|\\x": {
          "*": { action_: "copy" }
        },
        "${(...)}$|$(...)$": {
          "*": { action_: "tex-math" }
        },
        "{(...)}": {
          "*": { action_: "{text}" }
        },
        "else2": {
          "*": { action_: "copy" }
        }
      }),
      actions: {}
    },
    "text": {
      transitions: mhchemParser.createTransitions({
        "empty": {
          "*": { action_: "output" }
        },
        "{...}": {
          "*": { action_: "text=" }
        },
        "${(...)}$|$(...)$": {
          "*": { action_: "tex-math" }
        },
        "\\greek": {
          "*": { action_: ["output", "rm"] }
        },
        "\\,|\\x{}{}|\\x{}|\\x": {
          "*": { action_: ["output", "copy"] }
        },
        "else": {
          "*": { action_: "text=" }
        }
      }),
      actions: {
        output: function(buffer) {
          if (buffer.text_) {
            var ret = { type_: "text", p1: buffer.text_ };
            for (var p in buffer) {
              delete buffer[p];
            }
            return ret;
          }
        }
      }
    },
    "pq": {
      transitions: mhchemParser.createTransitions({
        "empty": {
          "*": {}
        },
        "state of aggregation $": {
          "*": { action_: "state of aggregation" }
        },
        "i$": {
          "0": { nextState: "!f", revisit: true }
        },
        "(KV letters),": {
          "0": { action_: "rm", nextState: "0" }
        },
        "formula$": {
          "0": { nextState: "f", revisit: true }
        },
        "1/2$": {
          "0": { action_: "1/2" }
        },
        "else": {
          "0": { nextState: "!f", revisit: true }
        },
        "${(...)}$|$(...)$": {
          "*": { action_: "tex-math" }
        },
        "{(...)}": {
          "*": { action_: "text" }
        },
        "a-z": {
          f: { action_: "tex-math" }
        },
        "letters": {
          "*": { action_: "rm" }
        },
        "-9.,9": {
          "*": { action_: "9,9" }
        },
        ",": {
          "*": {
            action_: {
              type_: "insert+p1",
              option: "comma enumeration S"
            }
          }
        },
        "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
          "*": { action_: "color-output" }
        },
        "\\color{(...)}0": {
          "*": { action_: "color0-output" }
        },
        "\\ce{(...)}": {
          "*": { action_: "ce" }
        },
        "\\,|\\x{}{}|\\x{}|\\x": {
          "*": { action_: "copy" }
        },
        "else2": {
          "*": { action_: "copy" }
        }
      }),
      actions: {
        "state of aggregation": function(buffer, m) {
          return {
            type_: "state of aggregation subscript",
            p1: mhchemParser.go(m, "o")
          };
        },
        "color-output": function(buffer, m) {
          return {
            type_: "color",
            color1: m[0],
            color2: mhchemParser.go(m[1], "pq")
          };
        }
      }
    },
    "bd": {
      transitions: mhchemParser.createTransitions({
        "empty": {
          "*": {}
        },
        "x$": {
          "0": { nextState: "!f", revisit: true }
        },
        "formula$": {
          "0": { nextState: "f", revisit: true }
        },
        "else": {
          "0": { nextState: "!f", revisit: true }
        },
        "-9.,9 no missing 0": {
          "*": { action_: "9,9" }
        },
        ".": {
          "*": { action_: { type_: "insert", option: "electron dot" } }
        },
        "a-z": {
          f: { action_: "tex-math" }
        },
        "x": {
          "*": { action_: { type_: "insert", option: "KV x" } }
        },
        "letters": {
          "*": { action_: "rm" }
        },
        "'": {
          "*": { action_: { type_: "insert", option: "prime" } }
        },
        "${(...)}$|$(...)$": {
          "*": { action_: "tex-math" }
        },
        "{(...)}": {
          "*": { action_: "text" }
        },
        "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
          "*": { action_: "color-output" }
        },
        "\\color{(...)}0": {
          "*": { action_: "color0-output" }
        },
        "\\ce{(...)}": {
          "*": { action_: "ce" }
        },
        "\\,|\\x{}{}|\\x{}|\\x": {
          "*": { action_: "copy" }
        },
        "else2": {
          "*": { action_: "copy" }
        }
      }),
      actions: {
        "color-output": function(buffer, m) {
          return {
            type_: "color",
            color1: m[0],
            color2: mhchemParser.go(m[1], "bd")
          };
        }
      }
    },
    "oxidation": {
      transitions: mhchemParser.createTransitions({
        "empty": {
          "*": {}
        },
        "roman numeral": {
          "*": { action_: "roman-numeral" }
        },
        "${(...)}$|$(...)$": {
          "*": { action_: "tex-math" }
        },
        "else": {
          "*": { action_: "copy" }
        }
      }),
      actions: {
        "roman-numeral": function(buffer, m) {
          return { type_: "roman numeral", p1: m || "" };
        }
      }
    },
    "tex-math": {
      transitions: mhchemParser.createTransitions({
        "empty": {
          "*": { action_: "output" }
        },
        "\\ce{(...)}": {
          "*": { action_: ["output", "ce"] }
        },
        "{...}|\\,|\\x{}{}|\\x{}|\\x": {
          "*": { action_: "o=" }
        },
        "else": {
          "*": { action_: "o=" }
        }
      }),
      actions: {
        output: function(buffer) {
          if (buffer.o) {
            var ret = { type_: "tex-math", p1: buffer.o };
            for (var p in buffer) {
              delete buffer[p];
            }
            return ret;
          }
        }
      }
    },
    "tex-math tight": {
      transitions: mhchemParser.createTransitions({
        "empty": {
          "*": { action_: "output" }
        },
        "\\ce{(...)}": {
          "*": { action_: ["output", "ce"] }
        },
        "{...}|\\,|\\x{}{}|\\x{}|\\x": {
          "*": { action_: "o=" }
        },
        "-|+": {
          "*": { action_: "tight operator" }
        },
        "else": {
          "*": { action_: "o=" }
        }
      }),
      actions: {
        "tight operator": function(buffer, m) {
          buffer.o = (buffer.o || "") + "{" + m + "}";
        },
        "output": function(buffer) {
          if (buffer.o) {
            var ret = { type_: "tex-math", p1: buffer.o };
            for (var p in buffer) {
              delete buffer[p];
            }
            return ret;
          }
        }
      }
    },
    "9,9": {
      transitions: mhchemParser.createTransitions({
        "empty": {
          "*": {}
        },
        ",": {
          "*": { action_: "comma" }
        },
        "else": {
          "*": { action_: "copy" }
        }
      }),
      actions: {
        comma: function() {
          return { type_: "commaDecimal" };
        }
      }
    },
    //#endregion
    //
    // \pu state machines
    //
    //#region pu
    "pu": {
      transitions: mhchemParser.createTransitions({
        "empty": {
          "*": { action_: "output" }
        },
        "space$": {
          "*": { action_: ["output", "space"] }
        },
        "{[(|)]}": {
          "0|a": { action_: "copy" }
        },
        "(-)(9)^(-9)": {
          "0": { action_: "number^", nextState: "a" }
        },
        "(-)(9.,9)(e)(99)": {
          "0": { action_: "enumber", nextState: "a" }
        },
        "space": {
          "0|a": {}
        },
        "pm-operator": {
          "0|a": {
            action_: { type_: "operator", option: "\\pm" },
            nextState: "0"
          }
        },
        "operator": {
          "0|a": { action_: "copy", nextState: "0" }
        },
        "//": {
          d: { action_: "o=", nextState: "/" }
        },
        "/": {
          d: { action_: "o=", nextState: "/" }
        },
        "{...}|else": {
          "0|d": { action_: "d=", nextState: "d" },
          "a": { action_: ["space", "d="], nextState: "d" },
          "/|q": { action_: "q=", nextState: "q" }
        }
      }),
      actions: {
        "enumber": function(buffer, m) {
          var ret = [];
          if (m[0] === "+-" || m[0] === "+/-") {
            ret.push("\\pm ");
          } else if (m[0]) {
            ret.push(m[0]);
          }
          if (m[1]) {
            mhchemParser.concatArray(ret, mhchemParser.go(m[1], "pu-9,9"));
            if (m[2]) {
              if (m[2].match(/[,.]/)) {
                mhchemParser.concatArray(ret, mhchemParser.go(m[2], "pu-9,9"));
              } else {
                ret.push(m[2]);
              }
            }
            m[3] = m[4] || m[3];
            if (m[3]) {
              m[3] = m[3].trim();
              if (m[3] === "e" || m[3].substr(0, 1) === "*") {
                ret.push({ type_: "cdot" });
              } else {
                ret.push({ type_: "times" });
              }
            }
          }
          if (m[3]) {
            ret.push("10^{" + m[5] + "}");
          }
          return ret;
        },
        "number^": function(buffer, m) {
          var ret = [];
          if (m[0] === "+-" || m[0] === "+/-") {
            ret.push("\\pm ");
          } else if (m[0]) {
            ret.push(m[0]);
          }
          mhchemParser.concatArray(ret, mhchemParser.go(m[1], "pu-9,9"));
          ret.push("^{" + m[2] + "}");
          return ret;
        },
        "operator": function(buffer, m, p1) {
          return { type_: "operator", kind_: p1 || m };
        },
        "space": function() {
          return { type_: "pu-space-1" };
        },
        "output": function(buffer) {
          var ret;
          var md = mhchemParser.patterns.match_("{(...)}", buffer.d || "");
          if (md && md.remainder === "") {
            buffer.d = md.match_;
          }
          var mq = mhchemParser.patterns.match_("{(...)}", buffer.q || "");
          if (mq && mq.remainder === "") {
            buffer.q = mq.match_;
          }
          if (buffer.d) {
            buffer.d = buffer.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
            buffer.d = buffer.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
          }
          if (buffer.q) {
            buffer.q = buffer.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
            buffer.q = buffer.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
            var b5 = {
              d: mhchemParser.go(buffer.d, "pu"),
              q: mhchemParser.go(buffer.q, "pu")
            };
            if (buffer.o === "//") {
              ret = { type_: "pu-frac", p1: b5.d, p2: b5.q };
            } else {
              ret = b5.d;
              if (b5.d.length > 1 || b5.q.length > 1) {
                ret.push({ type_: " / " });
              } else {
                ret.push({ type_: "/" });
              }
              mhchemParser.concatArray(ret, b5.q);
            }
          } else {
            ret = mhchemParser.go(buffer.d, "pu-2");
          }
          for (var p in buffer) {
            delete buffer[p];
          }
          return ret;
        }
      }
    },
    "pu-2": {
      transitions: mhchemParser.createTransitions({
        "empty": {
          "*": { action_: "output" }
        },
        "*": {
          "*": { action_: ["output", "cdot"], nextState: "0" }
        },
        "\\x": {
          "*": { action_: "rm=" }
        },
        "space": {
          "*": { action_: ["output", "space"], nextState: "0" }
        },
        "^{(...)}|^(-1)": {
          "1": { action_: "^(-1)" }
        },
        "-9.,9": {
          "0": { action_: "rm=", nextState: "0" },
          "1": { action_: "^(-1)", nextState: "0" }
        },
        "{...}|else": {
          "*": { action_: "rm=", nextState: "1" }
        }
      }),
      actions: {
        "cdot": function() {
          return { type_: "tight cdot" };
        },
        "^(-1)": function(buffer, m) {
          buffer.rm += "^{" + m + "}";
        },
        "space": function() {
          return { type_: "pu-space-2" };
        },
        "output": function(buffer) {
          var ret = [];
          if (buffer.rm) {
            var mrm = mhchemParser.patterns.match_("{(...)}", buffer.rm || "");
            if (mrm && mrm.remainder === "") {
              ret = mhchemParser.go(mrm.match_, "pu");
            } else {
              ret = { type_: "rm", p1: buffer.rm };
            }
          }
          for (var p in buffer) {
            delete buffer[p];
          }
          return ret;
        }
      }
    },
    "pu-9,9": {
      transitions: mhchemParser.createTransitions({
        "empty": {
          "0": { action_: "output-0" },
          "o": { action_: "output-o" }
        },
        ",": {
          "0": { action_: ["output-0", "comma"], nextState: "o" }
        },
        ".": {
          "0": { action_: ["output-0", "copy"], nextState: "o" }
        },
        "else": {
          "*": { action_: "text=" }
        }
      }),
      actions: {
        "comma": function() {
          return { type_: "commaDecimal" };
        },
        "output-0": function(buffer) {
          var ret = [];
          buffer.text_ = buffer.text_ || "";
          if (buffer.text_.length > 4) {
            var a = buffer.text_.length % 3;
            if (a === 0) {
              a = 3;
            }
            for (var i = buffer.text_.length - 3; i > 0; i -= 3) {
              ret.push(buffer.text_.substr(i, 3));
              ret.push({ type_: "1000 separator" });
            }
            ret.push(buffer.text_.substr(0, a));
            ret.reverse();
          } else {
            ret.push(buffer.text_);
          }
          for (var p in buffer) {
            delete buffer[p];
          }
          return ret;
        },
        "output-o": function(buffer) {
          var ret = [];
          buffer.text_ = buffer.text_ || "";
          if (buffer.text_.length > 4) {
            var a = buffer.text_.length - 3;
            for (var i = 0; i < a; i += 3) {
              ret.push(buffer.text_.substr(i, 3));
              ret.push({ type_: "1000 separator" });
            }
            ret.push(buffer.text_.substr(i));
          } else {
            ret.push(buffer.text_);
          }
          for (var p in buffer) {
            delete buffer[p];
          }
          return ret;
        }
      }
    }
    //#endregion
  };
  var texify = {
    go: function(input, isInner) {
      if (!input) {
        return "";
      }
      var res = "";
      var cee = false;
      for (var i = 0; i < input.length; i++) {
        var inputi = input[i];
        if (typeof inputi === "string") {
          res += inputi;
        } else {
          res += texify._go2(inputi);
          if (inputi.type_ === "1st-level escape") {
            cee = true;
          }
        }
      }
      if (!isInner && !cee && res) {
        res = "{" + res + "}";
      }
      return res;
    },
    _goInner: function(input) {
      if (!input) {
        return input;
      }
      return texify.go(input, true);
    },
    _go2: function(buf) {
      var res;
      switch (buf.type_) {
        case "chemfive":
          res = "";
          var b5 = {
            a: texify._goInner(buf.a),
            b: texify._goInner(buf.b),
            p: texify._goInner(buf.p),
            o: texify._goInner(buf.o),
            q: texify._goInner(buf.q),
            d: texify._goInner(buf.d)
          };
          if (b5.a) {
            if (b5.a.match(/^[+\-]/)) {
              b5.a = "{" + b5.a + "}";
            }
            res += b5.a + "\\,";
          }
          if (b5.b || b5.p) {
            res += "{\\vphantom{X}}";
            res += "^{\\hphantom{" + (b5.b || "") + "}}_{\\hphantom{" + (b5.p || "") + "}}";
            res += "{\\vphantom{X}}";
            res += "^{\\smash[t]{\\vphantom{2}}\\mathllap{" + (b5.b || "") + "}}";
            res += "_{\\vphantom{2}\\mathllap{\\smash[t]{" + (b5.p || "") + "}}}";
          }
          if (b5.o) {
            if (b5.o.match(/^[+\-]/)) {
              b5.o = "{" + b5.o + "}";
            }
            res += b5.o;
          }
          if (buf.dType === "kv") {
            if (b5.d || b5.q) {
              res += "{\\vphantom{X}}";
            }
            if (b5.d) {
              res += "^{" + b5.d + "}";
            }
            if (b5.q) {
              res += "_{\\smash[t]{" + b5.q + "}}";
            }
          } else if (buf.dType === "oxidation") {
            if (b5.d) {
              res += "{\\vphantom{X}}";
              res += "^{" + b5.d + "}";
            }
            if (b5.q) {
              res += "{\\vphantom{X}}";
              res += "_{\\smash[t]{" + b5.q + "}}";
            }
          } else {
            if (b5.q) {
              res += "{\\vphantom{X}}";
              res += "_{\\smash[t]{" + b5.q + "}}";
            }
            if (b5.d) {
              res += "{\\vphantom{X}}";
              res += "^{" + b5.d + "}";
            }
          }
          break;
        case "rm":
          res = "\\mathrm{" + buf.p1 + "}";
          break;
        case "text":
          if (buf.p1.match(/[\^_]/)) {
            buf.p1 = buf.p1.replace(" ", "~").replace("-", "\\text{-}");
            res = "\\mathrm{" + buf.p1 + "}";
          } else {
            res = "\\text{" + buf.p1 + "}";
          }
          break;
        case "roman numeral":
          res = "\\mathrm{" + buf.p1 + "}";
          break;
        case "state of aggregation":
          res = "\\mskip2mu " + texify._goInner(buf.p1);
          break;
        case "state of aggregation subscript":
          res = "\\mskip1mu " + texify._goInner(buf.p1);
          break;
        case "bond":
          res = texify._getBond(buf.kind_);
          if (!res) {
            throw [
              "MhchemErrorBond",
              "mhchem Error. Unknown bond type (" + buf.kind_ + ")"
            ];
          }
          break;
        case "frac":
          var c = "\\frac{" + buf.p1 + "}{" + buf.p2 + "}";
          res = "\\mathchoice{\\textstyle" + c + "}{" + c + "}{" + c + "}{" + c + "}";
          break;
        case "pu-frac":
          var d = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          res = "\\mathchoice{\\textstyle" + d + "}{" + d + "}{" + d + "}{" + d + "}";
          break;
        case "tex-math":
          res = buf.p1 + " ";
          break;
        case "frac-ce":
          res = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case "overset":
          res = "\\overset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case "underset":
          res = "\\underset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case "underbrace":
          res = "\\underbrace{" + texify._goInner(buf.p1) + "}_{" + texify._goInner(buf.p2) + "}";
          break;
        case "color":
          res = "{\\color{" + buf.color1 + "}{" + texify._goInner(buf.color2) + "}}";
          break;
        case "color0":
          res = "\\color{" + buf.color + "}";
          break;
        case "arrow":
          var b6 = {
            rd: texify._goInner(buf.rd),
            rq: texify._goInner(buf.rq)
          };
          var arrow = "\\x" + texify._getArrow(buf.r);
          if (b6.rq) {
            arrow += "[{" + b6.rq + "}]";
          }
          if (b6.rd) {
            arrow += "{" + b6.rd + "}";
          } else {
            arrow += "{}";
          }
          res = arrow;
          break;
        case "operator":
          res = texify._getOperator(buf.kind_);
          break;
        case "1st-level escape":
          res = buf.p1 + " ";
          break;
        case "space":
          res = " ";
          break;
        case "entitySkip":
          res = "~";
          break;
        case "pu-space-1":
          res = "~";
          break;
        case "pu-space-2":
          res = "\\mkern3mu ";
          break;
        case "1000 separator":
          res = "\\mkern2mu ";
          break;
        case "commaDecimal":
          res = "{,}";
          break;
        case "comma enumeration L":
          res = "{" + buf.p1 + "}\\mkern6mu ";
          break;
        case "comma enumeration M":
          res = "{" + buf.p1 + "}\\mkern3mu ";
          break;
        case "comma enumeration S":
          res = "{" + buf.p1 + "}\\mkern1mu ";
          break;
        case "hyphen":
          res = "\\text{-}";
          break;
        case "addition compound":
          res = "\\,{\\cdot}\\,";
          break;
        case "electron dot":
          res = "\\mkern1mu \\bullet\\mkern1mu ";
          break;
        case "KV x":
          res = "{\\times}";
          break;
        case "prime":
          res = "\\prime ";
          break;
        case "cdot":
          res = "\\cdot ";
          break;
        case "tight cdot":
          res = "\\mkern1mu{\\cdot}\\mkern1mu ";
          break;
        case "times":
          res = "\\times ";
          break;
        case "circa":
          res = "{\\sim}";
          break;
        case "^":
          res = "uparrow";
          break;
        case "v":
          res = "downarrow";
          break;
        case "ellipsis":
          res = "\\ldots ";
          break;
        case "/":
          res = "/";
          break;
        case " / ":
          res = "\\,/\\,";
          break;
        default:
          assertNever(buf);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
      assertString(res);
      return res;
    },
    _getArrow: function(a) {
      switch (a) {
        case "->":
          return "rightarrow";
        case "\u2192":
          return "rightarrow";
        case "\u27F6":
          return "rightarrow";
        case "<-":
          return "leftarrow";
        case "<->":
          return "leftrightarrow";
        case "<-->":
          return "rightleftarrows";
        case "<=>":
          return "rightleftharpoons";
        case "\u21CC":
          return "rightleftharpoons";
        case "<=>>":
          return "rightequilibrium";
        case "<<=>":
          return "leftequilibrium";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    },
    _getBond: function(a) {
      switch (a) {
        case "-":
          return "{-}";
        case "1":
          return "{-}";
        case "=":
          return "{=}";
        case "2":
          return "{=}";
        case "#":
          return "{\\equiv}";
        case "3":
          return "{\\equiv}";
        case "~":
          return "{\\tripledash}";
        case "~-":
          return "{\\mathrlap{\\raisebox{-.1em}{$-$}}\\raisebox{.1em}{$\\tripledash$}}";
        case "~=":
          return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$\\tripledash$}}-}";
        case "~--":
          return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$\\tripledash$}}-}";
        case "-~-":
          return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$-$}}\\tripledash}";
        case "...":
          return "{{\\cdot}{\\cdot}{\\cdot}}";
        case "....":
          return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
        case "->":
          return "{\\rightarrow}";
        case "<-":
          return "{\\leftarrow}";
        case "<":
          return "{<}";
        case ">":
          return "{>}";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    },
    _getOperator: function(a) {
      switch (a) {
        case "+":
          return " {}+{} ";
        case "-":
          return " {}-{} ";
        case "=":
          return " {}={} ";
        case "<":
          return " {}<{} ";
        case ">":
          return " {}>{} ";
        case "<<":
          return " {}\\ll{} ";
        case ">>":
          return " {}\\gg{} ";
        case "\\pm":
          return " {}\\pm{} ";
        case "\\approx":
          return " {}\\approx{} ";
        case "$\\approx$":
          return " {}\\approx{} ";
        case "v":
          return " \\downarrow{} ";
        case "(v)":
          return " \\downarrow{} ";
        case "^":
          return " \\uparrow{} ";
        case "(^)":
          return " \\uparrow{} ";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    }
  };
  function assertNever(a) {
  }
  function assertString(a) {
  }

  // src/core-atoms/box.ts
  var BoxAtom = class extends Atom {
    constructor(command, body, context, options) {
      super("box", context, {
        command,
        serialize: options.serialize,
        style: options.style
      });
      this.body = body;
      this.framecolor = options.framecolor;
      this.verbatimFramecolor = options.verbatimBackgroundcolor;
      this.backgroundcolor = options.backgroundcolor;
      this.verbatimBackgroundcolor = options.verbatimBackgroundcolor;
      this.padding = options.padding;
      this.border = options.border;
    }
    static fromJson(json, context) {
      return new BoxAtom(json.command, json.body, context, json);
    }
    toJson() {
      return __spreadProps(__spreadValues({}, super.toJson()), {
        framecolor: this.framecolor,
        verbatimFramecolor: this.verbatimFramecolor,
        backgroundcolor: this.backgroundcolor,
        verbatimBackgroundcolor: this.verbatimBackgroundcolor,
        padding: this.padding,
        border: this.border
      });
    }
    render(parentContext) {
      const context = new Context(parentContext, this.style);
      const fboxsep = convertDimensionToEm(
        context.getRegisterAsDimension("fboxsep")
      );
      const padding = this.padding === void 0 ? fboxsep : convertDimensionToEm(
        convertToDimension(this.padding, __spreadProps(__spreadValues({}, this.context), {
          registers: parentContext.registers
        }))
      );
      const content = Atom.createBox(parentContext, this.body);
      if (!content)
        return null;
      content.setStyle("vertical-align", -content.height, "em");
      const base = new Box(content, { type: "mord" });
      const box = new Box(null, { classes: "ML__box" });
      box.height = base.height + padding;
      box.depth = base.depth + padding;
      box.setStyle("box-sizing", "border-box");
      box.setStyle("position", "absolute");
      box.setStyle("height", base.height + base.depth + 2 * padding, "em");
      if (padding === 0)
        box.setStyle("width", "100%");
      else {
        box.setStyle("width", `calc(100% + ${2 * padding}em)`);
        box.setStyle("top", fboxsep, "em");
        box.setStyle("left", -padding, "em");
      }
      if (this.backgroundcolor)
        box.setStyle("background-color", this.backgroundcolor);
      if (this.framecolor) {
        box.setStyle(
          "border",
          `${convertDimensionToEm(
            context.getRegisterAsDimension("fboxrule")
          )}em solid ${this.framecolor}`
        );
      }
      if (this.border)
        box.setStyle("border", this.border);
      base.setStyle("display", "inline-block");
      base.setStyle("height", content.height + content.depth, "em");
      base.setStyle("vertical-align", -padding, "em");
      const result = new Box([box, base]);
      result.setStyle("position", "relative");
      result.setStyle("display", "inline-block");
      result.setStyle("line-height", 0);
      result.height = base.height + padding;
      result.depth = base.depth + padding;
      result.left = padding;
      result.right = padding;
      result.setStyle("height", base.height + padding, "em");
      result.setStyle("top", base.depth - base.height, "em");
      result.setStyle("vertical-align", base.depth + padding, "em");
      if (this.caret)
        result.caret = this.caret;
      return this.attachSupsub(parentContext, { base: result });
    }
  };

  // src/core-atoms/composition.ts
  var CompositionAtom = class extends Atom {
    constructor(value, context, options) {
      var _a3;
      super("composition", context, { mode: (_a3 = options == null ? void 0 : options.mode) != null ? _a3 : "math", value });
    }
    static fromJson(json, context) {
      return new CompositionAtom(json.value, context, json);
    }
    toJson() {
      return super.toJson();
    }
    get computedStyle() {
      return {};
    }
    render(context) {
      const result = new Box(this.value, {
        classes: "ML__composition",
        type: "composition"
      });
      this.bind(context, result);
      if (this.caret)
        result.caret = this.caret;
      return result;
    }
    serialize(_options) {
      return "";
    }
  };

  // src/core-atoms/latex.ts
  var LatexAtom = class extends Atom {
    // Display errors with wavy red line
    constructor(value, context, options) {
      var _a3;
      super("latex", context, { value, mode: "latex" });
      this.isSuggestion = (_a3 = options == null ? void 0 : options.isSuggestion) != null ? _a3 : false;
      this.isError = false;
      this.verbatimLatex = value;
    }
    static fromJson(json, context) {
      const result = new LatexAtom(json.command, context);
      if (json.isSuggestion)
        result.isSuggestion = true;
      if (json.isError)
        result.isError = true;
      return result;
    }
    toJson() {
      const options = {};
      if (this.isSuggestion)
        options.isSuggestion = true;
      if (this.isError)
        options.isError = true;
      return __spreadValues(__spreadValues({}, super.toJson()), options);
    }
    get computedStyle() {
      return {};
    }
    render(context) {
      const result = new Box(this.value, {
        classes: this.isSuggestion ? "ML__suggestion" : this.isError ? "ML__error" : "",
        type: "latex",
        maxFontSize: 1
      });
      if (!result)
        return null;
      if (this.caret)
        result.caret = this.caret;
      return this.bind(context, result);
    }
  };
  var LatexGroupAtom = class extends Atom {
    constructor(latex, context) {
      super("latexgroup", context, { mode: "latex" });
      this.body = [...latex].map((x) => new LatexAtom(x, context));
      this.skipBoundary = false;
    }
    static fromJson(_json, context) {
      return new LatexGroupAtom("", context);
    }
    toJson() {
      return super.toJson();
    }
    render(context) {
      const box = Atom.createBox(context, this.body, { newList: true });
      if (!box)
        return null;
      if (this.caret)
        box.caret = this.caret;
      return this.bind(context, box);
    }
    serialize(_options) {
      var _a3, _b3;
      return (_b3 = (_a3 = this.body) == null ? void 0 : _a3.map((x) => x.value).join("")) != null ? _b3 : "";
    }
  };

  // src/core-atoms/line.ts
  var LineAtom = class extends Atom {
    constructor(command, body, context, options) {
      super("line", context, { command, style: options.style });
      this.skipBoundary = true;
      this.body = body;
      this.position = options.position;
    }
    static fromJson(json, context) {
      return new LineAtom(json.command, json.body, context, json);
    }
    toJson() {
      return __spreadProps(__spreadValues({}, super.toJson()), { position: this.position });
    }
    render(parentContext) {
      const context = new Context(parentContext, this.style, "cramp");
      const inner = Atom.createBox(context, this.body);
      if (!inner)
        return null;
      const ruleWidth = context.metrics.defaultRuleThickness / context.scalingFactor;
      const line = new Box(null, { classes: this.position + "-line" });
      line.height = ruleWidth;
      line.maxFontSize = ruleWidth * 1.125 * context.scalingFactor;
      let stack;
      if (this.position === "overline") {
        stack = new VBox({
          shift: 0,
          children: [{ box: inner }, 3 * ruleWidth, { box: line }, ruleWidth]
        });
      } else {
        stack = new VBox({
          top: inner.height,
          children: [ruleWidth, { box: line }, 3 * ruleWidth, { box: inner }]
        });
      }
      if (this.caret)
        stack.caret = this.caret;
      return new Box(stack, {
        classes: this.position,
        type: "mord"
      });
    }
  };

  // src/core-atoms/overlap.ts
  var OverlapAtom = class extends Atom {
    constructor(command, body, context, options) {
      var _a3, _b3;
      super("overlap", context, { command, style: options == null ? void 0 : options.style });
      this.skipBoundary = true;
      if (typeof body === "string")
        this.body = [new Atom("mord", context, { value: body })];
      else
        this.body = body;
      this.align = (_a3 = options == null ? void 0 : options.align) != null ? _a3 : "left";
      this.boxType = (_b3 = options == null ? void 0 : options.boxType) != null ? _b3 : "mord";
    }
    static fromJson(json, context) {
      return new OverlapAtom(json.command, json.body, context, json);
    }
    toJson() {
      const options = {};
      if (this.align)
        options.align = this.align;
      if (this.boxType)
        options.boxType = this.boxType;
      return __spreadValues(__spreadValues({}, super.toJson()), options);
    }
    render(context) {
      const inner = Atom.createBox(context, this.body, { classes: "inner" });
      if (!inner)
        return null;
      if (this.caret)
        inner.caret = this.caret;
      return this.bind(
        context,
        new Box([inner, new Box(null, { classes: "fix" })], {
          classes: this.align === "left" ? "llap" : "rlap",
          type: this.boxType
        })
      );
    }
  };

  // src/core-atoms/phantom.ts
  var PhantomAtom = class extends Atom {
    constructor(command, body, context, options) {
      var _a3, _b3, _c2, _d2;
      super("phantom", context, { command, style: options.style });
      this.captureSelection = true;
      this.body = body;
      this.isInvisible = (_a3 = options.isInvisible) != null ? _a3 : false;
      this.smashDepth = (_b3 = options.smashDepth) != null ? _b3 : false;
      this.smashHeight = (_c2 = options.smashHeight) != null ? _c2 : false;
      this.smashWidth = (_d2 = options.smashWidth) != null ? _d2 : false;
    }
    static fromJson(json, context) {
      return new PhantomAtom(json.command, json.body, context, json);
    }
    toJson() {
      const options = {};
      if (this.isInvisible)
        options.isInvisible = true;
      if (this.smashDepth)
        options.smashDepth = true;
      if (this.smashHeight)
        options.smashHeight = true;
      if (this.smashWidth)
        options.smashWidth = true;
      return __spreadValues(__spreadValues({}, super.toJson()), options);
    }
    render(context) {
      const phantom = new Context(context, { isPhantom: true });
      if (!this.smashDepth && !this.smashHeight && !this.smashWidth) {
        console.assert(this.isInvisible);
        return Atom.createBox(phantom, this.body, { classes: "inner" });
      }
      const content = Atom.createBox(
        this.isInvisible ? phantom : context,
        this.body
      );
      if (!content)
        return null;
      if (this.smashWidth) {
        const fix = new Box(null, { classes: "fix" });
        return new Box([content, fix], { classes: "rlap" }).wrap(context);
      }
      if (!this.smashHeight && !this.smashDepth)
        return content;
      if (this.smashHeight)
        content.height = 0;
      if (this.smashDepth)
        content.depth = 0;
      if (content.children) {
        for (const box of content.children) {
          if (this.smashHeight)
            box.height = 0;
          if (this.smashDepth)
            box.depth = 0;
        }
      }
      return new VBox(
        { firstBaseline: [{ box: content }] },
        { type: "mord" }
      ).wrap(context);
    }
  };

  // src/core-atoms/rule.ts
  var RuleAtom = class extends Atom {
    constructor(command, context, options) {
      var _a3;
      super("rule", context, { command, style: options.style });
      this.shift = (_a3 = options.shift) != null ? _a3 : { dimension: 0 };
      this.height = options.height;
      this.width = options.width;
    }
    static fromJson(json, context) {
      return new RuleAtom(json.command, context, json);
    }
    toJson() {
      const options = {
        height: this.height,
        width: this.width
      };
      if (this.shift)
        options.shift = this.shift;
      return __spreadValues(__spreadValues({}, super.toJson()), options);
    }
    render(parentContext) {
      const context = new Context(parentContext, this.style, "textstyle");
      const shift = convertDimensionToEm(this.shift);
      const width = convertDimensionToEm(this.width);
      const height = convertDimensionToEm(this.height);
      const result = new Box(null, { classes: "rule", type: "mord" });
      result.setStyle("border-right-width", width, "em");
      result.setStyle("border-top-width", height, "em");
      result.setStyle("border-color", this.style.color);
      result.setStyle("vertical-align", shift, "em");
      if (this.isSelected)
        result.setStyle("opacity", "50%");
      result.width = width;
      result.height = height + shift;
      result.depth = -shift;
      this.bind(parentContext, result);
      if (this.caret)
        result.caret = this.caret;
      return result.wrap(context);
    }
    serialize(_options) {
      var _a3;
      let result = (_a3 = this.command) != null ? _a3 : "";
      if (this.shift)
        result += `[${serializeDimension(this.shift)}]`;
      result += `{${serializeDimension(this.width)}}{${serializeDimension(
        this.height
      )}}`;
      return result;
    }
  };

  // src/core/registers.ts
  var DEFAULT_DIMENSION_REGISTERS = {
    "p@": "1pt ",
    "z@": "0pt",
    "maxdimen": "16383.99999pt",
    "hfuzz": "0.1pt",
    "vfuzz": "0.1pt",
    "overfullrule": "5pt",
    "hsize": "6.5in",
    "vsize": "8.9in",
    "parindent": "20pt",
    "maxdepth": "4pt",
    "splitmaxdepth": "\\maxdimen",
    "boxmaxdepth": "\\maxdimen",
    "delimitershortfall": "5pt",
    //      @todo used in makeLeftRightDelim()
    "nulldelimiterspace": "1.2pt",
    //       @todo use in makeNullDelimiter
    "scriptspace": "0.5pt",
    // In pt.
    "topskip": "10pt",
    "splittopskip": "10pt",
    "normalbaselineskip": "12pt",
    "normallineskip": "1pt",
    "normallineskiplimit": "0pt",
    // @todo: The vertical space between the lines for all math expressions which
    // allow multiple lines (see array, multline)
    "jot": "3pt",
    // The space between adjacent `|` columns in an array definition.
    // From article.cls.txt:455
    "doublerulesep": "2pt",
    // The width of separator lines in {array} environments.
    "arrayrulewidth": "0.4pt",
    "arraycolsep": "5pt",
    // Two values from LaTeX source2e:
    "fboxsep": "3pt",
    // From letter.dtx:1626
    "fboxrule": "0.4pt"
    // From letter.dtx:1627
  };
  var DEFAULT_GLUE_REGISTERS = {
    "z@skip": "0pt plust0pt minus0pt",
    "hideskip": "-1000pt plust 1fill",
    // LaTeX
    "@flushglue": "0pt plust 1fill",
    // LaTeX
    "parskip": "0pt plus 1pt",
    // @todo  the "shortskip" are used if the formula starts to the right of the
    // line before (i.e. centered and short line before)
    "abovedisplayskip": "12pt plus 3pt minus 9pt",
    "abovedisplayshortskip": "0pt plus 3pt",
    "belowdisplayskip": "12pt plus 3pt minus 9pt",
    "belowdisplayshortskip": "7pt plus 3pt minus 4pt",
    "parfillskip": "0pt plus 1fil",
    "thinmuskip": "3mu",
    //  @todo for inter atom spacing
    "medmuskip": "4mu plus 2mu minus 4mu",
    // @todo for inter atom spacing
    "thickmuskip": "5mu plus 5mu",
    //  @todo for inter atom spacing
    "smallskipamount": "3pt plus1pt minus1pt",
    "medskipamount": "6pt plus2pt minus2pt",
    "bigskipamount": "12pt plus4pt minus4pt"
  };
  var DEFAULT_NUMBER_REGISTERS = {
    // 'voidb@x'
    pretolerance: 100,
    tolerance: 200,
    hbadness: 1e3,
    vbadness: 1e3,
    linepenalty: 10,
    hyphenpenalty: 50,
    exhyphenpenalty: 50,
    binoppenalty: 700,
    relpenalty: 500,
    clubpenalty: 150,
    widowpenalty: 150,
    displaywidowpenalty: 50,
    brokenpenalty: 100,
    predisplaypenalty: 1e4,
    doublehyphendemerits: 1e4,
    finalhyphendemerits: 5e3,
    adjdemerits: 1e4,
    tracinglostchars: 1,
    uchyph: 1,
    delimiterfactor: 901,
    defaulthyphenchar: "\\-",
    defaultskewchar: -1,
    newlinechar: -1,
    showboxbreadth: 5,
    showboxdepth: 3,
    errorcontextlines: 5,
    interdisplaylinepenalty: 100,
    interfootnotelinepenalty: 100,
    baselineSkip: 1.2,
    // @todo:
    arraystretch: "",
    month: (/* @__PURE__ */ new Date()).getMonth() + 1,
    day: (/* @__PURE__ */ new Date()).getDate(),
    year: (/* @__PURE__ */ new Date()).getFullYear()
  };
  var gDefaultRegisters;
  function getDefaultRegisters(context) {
    var _a3, _b3;
    if (gDefaultRegisters)
      return gDefaultRegisters;
    gDefaultRegisters = __spreadValues({}, DEFAULT_NUMBER_REGISTERS);
    for (const reg of Object.keys(DEFAULT_DIMENSION_REGISTERS)) {
      gDefaultRegisters[reg] = (_a3 = convertToDimension(DEFAULT_DIMENSION_REGISTERS[reg], __spreadProps(__spreadValues({}, context), {
        registers: gDefaultRegisters
      }))) != null ? _a3 : 0;
    }
    for (const reg of Object.keys(DEFAULT_GLUE_REGISTERS)) {
      gDefaultRegisters[reg] = (_b3 = convertToGlue(DEFAULT_GLUE_REGISTERS[reg], __spreadProps(__spreadValues({}, context), {
        registers: gDefaultRegisters
      }))) != null ? _b3 : 0;
    }
    return gDefaultRegisters;
  }

  // src/core/context-utils.ts
  function defaultGlobalContext() {
    const result = {
      registers: {},
      smartFence: false,
      fractionNavigationOrder: "numerator-denominator",
      placeholderSymbol: "\u25A2",
      letterShapeStyle: l10n.locale.startsWith("fr") ? "french" : "tex",
      colorMap: defaultColorMap,
      backgroundColorMap: defaultBackgroundColorMap,
      getDefinition: defaultGetDefinition,
      getMacro(token) {
        return getMacroDefinition(token, getMacros());
      }
    };
    return __spreadProps(__spreadValues({}, result), { registers: getDefaultRegisters(result) });
  }

  // src/core-atoms/tooltip.ts
  var TooltipAtom = class extends Atom {
    constructor(body, tooltip, context, options) {
      super("tooltip", context, {
        command: options == null ? void 0 : options.command,
        mode: "math",
        serialize: options == null ? void 0 : options.serialize,
        style: options == null ? void 0 : options.style,
        displayContainsHighlight: true
      });
      this.body = body;
      const tooltipContext = defaultGlobalContext();
      this.tooltip = new Atom("root", tooltipContext, { style: {} });
      this.tooltip.body = tooltip;
      this.skipBoundary = true;
      this.captureSelection = false;
    }
    static fromJson(json, context) {
      return new TooltipAtom(
        json.body,
        fromJson(json.tooltip, context),
        context,
        json
      );
    }
    toJson() {
      var _a3;
      const tooltip = (_a3 = this.tooltip.body) == null ? void 0 : _a3.filter((x) => x.type !== "first").map((x) => x.toJson());
      return __spreadProps(__spreadValues({}, super.toJson()), { tooltip });
    }
    render(context) {
      const body = Atom.createBox(context, this.body, {
        style: this.style
      });
      if (!body)
        return null;
      const tooltipContext = new Context(
        { registers: context.registers },
        { fontSize: DEFAULT_FONT_SIZE },
        "displaystyle"
      );
      const tooltip = coalesce(
        adjustInterAtomSpacing(
          new Box(this.tooltip.render(tooltipContext), {
            classes: "ML__tooltip-content"
          }),
          tooltipContext
        )
      );
      const box = new Box([tooltip, body], { classes: "ML__tooltip-container" });
      if (this.caret)
        box.caret = this.caret;
      return this.bind(context, box);
    }
    serialize(options) {
      return `${this.command}{${this.bodyToLatex(options)}}{${Atom.serialize(
        this.tooltip.body,
        options
      )}}`;
    }
  };

  // src/core/atom.ts
  function fromJson(json, context) {
    if (isArray(json))
      return json.map((x) => fromJson(x, context));
    json = __spreadValues({}, json);
    for (const branch of NAMED_BRANCHES) {
      if (json[branch])
        json[branch] = fromJson(json[branch], context);
    }
    if (json.array)
      json.array = fromJson(json.array, context);
    const type = json.type;
    let result = void 0;
    if (type === "accent")
      result = AccentAtom.fromJson(json, context);
    if (type === "array")
      result = ArrayAtom.fromJson(json, context);
    if (type === "box")
      result = BoxAtom.fromJson(json, context);
    if (type === "chem")
      result = ChemAtom.fromJson(json, context);
    if (type === "choice")
      result = ChoiceAtom.fromJson(json, context);
    if (type === "composition")
      result = CompositionAtom.fromJson(json, context);
    if (type === "delim")
      result = DelimAtom.fromJson(json, context);
    if (type === "enclose")
      result = EncloseAtom.fromJson(json, context);
    if (type === "error")
      result = ErrorAtom.fromJson(json, context);
    if (type === "genfrac")
      result = GenfracAtom.fromJson(json, context);
    if (type === "group")
      result = GroupAtom.fromJson(json, context);
    if (type === "latex")
      result = LatexAtom.fromJson(json, context);
    if (type === "latexgroup")
      result = LatexGroupAtom.fromJson(json, context);
    if (type === "leftright")
      result = LeftRightAtom.fromJson(json, context);
    if (type === "line")
      result = LineAtom.fromJson(json, context);
    if (type === "macro")
      result = MacroAtom.fromJson(json, context);
    if (type === "msubsup")
      result = SubsupAtom.fromJson(json, context);
    if (type === "overlap")
      result = OverlapAtom.fromJson(json, context);
    if (type === "overunder")
      result = OverunderAtom.fromJson(json, context);
    if (type === "placeholder")
      result = PlaceholderAtom.fromJson(json, context);
    if (type === "prompt")
      result = PromptAtom.fromJson(json, context);
    if (type === "phantom")
      result = PhantomAtom.fromJson(json, context);
    if (type === "rule")
      result = RuleAtom.fromJson(json, context);
    if (type === "sizeddelim")
      result = SizedDelimAtom.fromJson(json, context);
    if (type === "spacing")
      result = SpacingAtom.fromJson(json, context);
    if (type === "surd")
      result = SurdAtom.fromJson(json, context);
    if (type === "text")
      result = TextAtom.fromJson(json, context);
    if (type === "tooltip")
      result = TooltipAtom.fromJson(json, context);
    if (type === "mop")
      result = OperatorAtom.fromJson(json, context);
    if (!result) {
      console.assert(
        [
          "first",
          "mbin",
          "mrel",
          "mclose",
          "minner",
          "mopen",
          "mord",
          "mpunct",
          "root",
          "space"
        ].includes(type),
        `MathLive 0.91.2: an unexpected atom type "${type}" was encountered. Add new atom constructors to \`fromJson()\` in "atom.ts"`
      );
      result = Atom.fromJson(json, context);
    }
    for (const branch of NAMED_BRANCHES)
      if (json[branch])
        result.setChildren(json[branch], branch);
    if (json.verbatimLatex !== void 0)
      result.verbatimLatex = json.verbatimLatex;
    if (json.subsupPlacement)
      result.subsupPlacement = json.subsupPlacement;
    if (json.explicitSubsupPlacement)
      result.explicitSubsupPlacement = true;
    if (json.isFunction)
      result.isFunction = true;
    if (json.isExtensibleSymbol)
      result.isExtensibleSymbol = true;
    if (json.skipBoundary)
      result.skipBoundary = true;
    if (json.captureSelection)
      result.captureSelection = true;
    return result;
  }

  // src/core-atoms/choice.ts
  var ChoiceAtom = class extends Atom {
    constructor(choices, context) {
      super("choice", context);
      this.choices = choices;
      this.skipBoundary = true;
    }
    static fromJson(json, context) {
      return new ChoiceAtom(
        [
          fromJson(json.choices[0], context),
          fromJson(json.choices[1], context),
          fromJson(json.choices[2], context),
          fromJson(json.choices[3], context)
        ],
        context
      );
    }
    toJson() {
      const choices = [];
      for (const choice of this.choices) {
        choices.push(
          choice.filter((x) => x.type !== "first").map((x) => x.toJson())
        );
      }
      return __spreadProps(__spreadValues({}, super.toJson()), { choices });
    }
    render(context) {
      const box = Atom.createBox(
        context,
        this.choices[Math.floor(context.mathstyle.id / 2)]
      );
      if (!box)
        return null;
      if (this.caret)
        box.caret = this.caret;
      return this.bind(context, box);
    }
    serialize(options) {
      return `\\mathchoice{${Atom.serialize(
        this.choices[0],
        options
      )}}{${Atom.serialize(this.choices[1], options)}}{${Atom.serialize(
        this.choices[2],
        options
      )}}{${Atom.serialize(this.choices[3], options)}}`;
    }
  };

  // src/core-definitions/styling.ts
  defineFunction("mathtip", "{:math}{:math}", {
    createAtom: (name, args, style, context) => new TooltipAtom(args[0], args[1], context, {
      command: name,
      content: "math",
      style
    })
  });
  defineFunction("texttip", "{:math}{:text}", {
    createAtom: (name, args, style, context) => new TooltipAtom(args[0], args[1], context, {
      command: name,
      content: "text",
      style
    })
  });
  defineFunction("error", "{:math}", {
    createAtom: (_name, args, style, context) => new GroupAtom(args[0], context, {
      mode: "math",
      command: "\\error",
      customClass: "ML__error",
      style,
      serialize: (atom, options) => `\\error{${atom.bodyToLatex(options)}}`
    })
  });
  defineFunction("ensuremath", "{:math}", {
    createAtom: (_name, args, style, context) => new GroupAtom(args[0], context, {
      mode: "math",
      latexOpen: "\\ensuremath{",
      latexClose: "}",
      style
      // mathstyleName: 'textstyle',
    })
  });
  defineFunction("color", "{:string}", {
    applyStyle: (_name, args, context) => {
      var _a3, _b3;
      const color = args[0];
      return {
        verbatimColor: args[0],
        color: (_b3 = (_a3 = context.colorMap) == null ? void 0 : _a3.call(context, color)) != null ? _b3 : color
      };
    }
  });
  defineFunction("textcolor", "{:string}{content:auto*}", {
    applyStyle: (_name, args, context) => {
      var _a3, _b3;
      const color = args[0];
      return {
        verbatimColor: color,
        color: (_b3 = (_a3 = context.colorMap) == null ? void 0 : _a3.call(context, color)) != null ? _b3 : color
      };
    }
  });
  defineFunction("boxed", "{content:math}", {
    createAtom: (name, args, style, context) => new BoxAtom(name, args[0], context, {
      framecolor: "black",
      style
    })
  });
  defineFunction("colorbox", "{:string}{content:auto*}", {
    applyMode: "text",
    applyStyle: (_name, args, context) => {
      var _a3, _b3;
      const color = args[0];
      return {
        verbatimBackgroundColor: args[0],
        backgroundColor: (_b3 = (_a3 = context.backgroundColorMap) == null ? void 0 : _a3.call(context, color)) != null ? _b3 : color
      };
    }
  });
  defineFunction(
    "fcolorbox",
    "{frame-color:string}{background-color:string}{content:auto}",
    {
      applyMode: "text",
      createAtom: (name, args, style, context) => {
        var _a3, _b3, _c2, _d2;
        const color = args[0];
        const bgColor = args[1];
        return new BoxAtom(name, args[2], context, {
          verbatimFramecolor: color,
          // Save this value to restore it verbatim later
          framecolor: (_b3 = (_a3 = context.colorMap) == null ? void 0 : _a3.call(context, color)) != null ? _b3 : color,
          verbatimBackgroundcolor: args[1],
          // Save this value to restore it verbatim later
          backgroundcolor: (_d2 = (_c2 = context.backgroundColorMap) == null ? void 0 : _c2.call(context, bgColor)) != null ? _d2 : bgColor,
          style,
          serialize: (atom, options) => {
            var _a4, _b4;
            return `${atom.command}{${(_a4 = atom.verbatimFramecolor) != null ? _a4 : atom.framecolor}{${(_b4 = atom.verbatimBackgroundcolor) != null ? _b4 : atom.backgroundcolor}}{${atom.bodyToLatex(options)}}`;
          }
        });
      }
    }
  );
  defineFunction("bbox", "[:bbox]{body:auto}", {
    createAtom: (name, args, style, context) => {
      if (args[0]) {
        const arg = args[0];
        return new BoxAtom(name, args[1], context, {
          padding: arg.padding,
          border: arg.border,
          backgroundcolor: arg.backgroundcolor,
          style,
          serialize: (atom, options) => {
            var _a3;
            let result = name;
            if (Number.isFinite(atom.padding) || atom.border !== void 0 || atom.backgroundcolor !== void 0) {
              const bboxParameters = [];
              if (atom.padding)
                bboxParameters.push(atom.padding);
              if (atom.border)
                bboxParameters.push(`border: ${atom.border}`);
              if (atom.verbatimBackgroundcolor || atom.backgroundcolor) {
                bboxParameters.push(
                  (_a3 = atom.verbatimBackgroundcolor) != null ? _a3 : atom.backgroundcolor
                );
              }
              result += `[${bboxParameters.join(",")}]`;
            }
            return result + `{${atom.bodyToLatex(options)}}`;
          }
        });
      }
      return new BoxAtom(name, args[1], context, { style });
    }
  });
  defineFunction(
    ["displaystyle", "textstyle", "scriptstyle", "scriptscriptstyle"],
    "{:rest}",
    {
      createAtom: (name, args, style, context) => new GroupAtom(args[0], context, {
        latexOpen: `{${name} `,
        latexClose: "}",
        style,
        mathstyleName: name.slice(1)
      })
    }
  );
  defineFunction(
    [
      "tiny",
      "scriptsize",
      "footnotesize",
      "small",
      "normalsize",
      "large",
      "Large",
      "LARGE",
      "huge",
      "Huge"
    ],
    "",
    {
      // TeX behaves very inconsistently when sizing commands are applied
      // to math mode. We allow sizing commands to be applied in both math and
      // text mode
      applyStyle: (name, _args) => {
        return {
          fontSize: {
            "\\tiny": 1,
            "\\scriptsize": 2,
            // Not to be confused with \scriptstyle
            "\\footnotesize": 3,
            "\\small": 4,
            "\\normalsize": 5,
            "\\large": 6,
            "\\Large": 7,
            "\\LARGE": 8,
            "\\huge": 9,
            "\\Huge": 10
          }[name]
        };
      }
    }
  );
  defineFunction("fontseries", "{:string}", {
    ifMode: "text",
    applyStyle: (_name, args) => {
      return { fontSeries: args[0] };
    }
  });
  defineFunction("fontshape", "{:string}", {
    ifMode: "text",
    applyStyle: (_name, args) => {
      return { fontShape: args[0] };
    }
  });
  defineFunction("fontfamily", "{:string}", {
    ifMode: "text",
    applyStyle: (_name, args) => {
      return { fontFamily: args[0] };
    }
  });
  defineFunction("selectfont", "", {
    ifMode: "text",
    applyStyle: (_name, _args) => {
      return {};
    }
  });
  defineFunction("bf", "", {
    applyStyle: (_name, _args) => {
      return { fontSeries: "b", fontShape: "n", fontFamily: "cmr" };
    }
  });
  defineFunction(["boldsymbol", "bm"], "{:math*}", {
    applyMode: "math",
    createAtom: (name, args, style, context) => new GroupAtom(args[0], context, {
      latexOpen: `${name}{`,
      latexClose: "}",
      style,
      customClass: "ML__boldsymbol"
    })
  });
  defineFunction("bold", "{:math*}", {
    applyMode: "math",
    applyStyle: (_name, _args) => {
      return { variantStyle: "bold" };
    }
  });
  defineFunction("bfseries", "", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontSeries: "b" };
    }
  });
  defineFunction("mdseries", "", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontSeries: "m" };
    }
  });
  defineFunction("upshape", "", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontShape: "n" };
    }
  });
  defineFunction("slshape", "", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontShape: "sl" };
    }
  });
  defineFunction("scshape", "", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontShape: "sc" };
    }
  });
  defineFunction("textbf", "{:text*}", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontSeries: "b" };
    }
  });
  defineFunction("textmd", "{:text*}", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontSeries: "m" };
    }
  });
  defineFunction("textup", "{:text*}", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontShape: "n" };
    }
  });
  defineFunction("textnormal", "{:text*}", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontShape: "n", fontSeries: "m" };
    }
  });
  defineFunction("textsl", "{:text*}", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontShape: "sl" };
    }
  });
  defineFunction("textit", "{:text*}", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontShape: "it" };
    }
  });
  defineFunction("textsc", "{:text*}", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontShape: "sc" };
    }
  });
  defineFunction("textrm", "{:text*}", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontFamily: "roman" };
    }
  });
  defineFunction("textsf", "{:text*}", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontFamily: "sans-serif" };
    }
  });
  defineFunction("texttt", "{:text*}", {
    applyMode: "text",
    applyStyle: (_name, _args) => {
      return { fontFamily: "monospace" };
    }
  });
  defineFunction("mathbf", "{:math*}", {
    applyMode: "math",
    applyStyle: (_name, _args) => {
      return { variant: "normal", variantStyle: "bold" };
    }
  });
  defineFunction("mathit", "{:math*}", {
    applyMode: "math",
    applyStyle: (_name, _args) => {
      return { variant: "main", variantStyle: "italic" };
    }
  });
  defineFunction("mathnormal", "{:math*}", {
    applyMode: "math",
    applyStyle: (_name, _args) => {
      return { variant: "normal", variantStyle: "italic" };
    }
  });
  defineFunction("mathbfit", "{:math*}", {
    applyMode: "math",
    applyStyle: (_name, _args) => {
      return { variant: "main", variantStyle: "bolditalic" };
    }
  });
  defineFunction("mathrm", "{:math*}", {
    applyMode: "math",
    applyStyle: (_name, _args) => {
      return { variant: "normal", variantStyle: "up" };
    }
  });
  defineFunction("mathsf", "{:math*}", {
    applyMode: "math",
    applyStyle: (_name, _args) => {
      return { variant: "sans-serif", variantStyle: "up" };
    }
  });
  defineFunction("mathtt", "{:math*}", {
    applyMode: "math",
    applyStyle: (_name, _args) => {
      return { variant: "monospace", variantStyle: "up" };
    }
  });
  defineFunction("it", "", {
    applyStyle: (_name, _args) => {
      return {
        fontSeries: "m",
        fontShape: "it",
        fontFamily: "cmr",
        variantStyle: "italic"
        // For math mode
      };
    }
  });
  defineFunction("rmfamily", "", {
    applyStyle: (_name, _args) => {
      return { fontFamily: "roman" };
    }
  });
  defineFunction("sffamily", "", {
    applyStyle: (_name, _args) => {
      return { fontFamily: "sans-serif" };
    }
  });
  defineFunction("ttfamily", "", {
    applyStyle: (_name, _args) => {
      return { fontFamily: "monospace" };
    }
  });
  defineFunction(["Bbb", "mathbb"], "{:math*}", {
    applyStyle: (_name, _args) => {
      return { variant: "double-struck", variantStyle: "up" };
    }
  });
  defineFunction(["frak", "mathfrak"], "{:math*}", {
    applyStyle: (_name, _args) => {
      return { variant: "fraktur", variantStyle: "up" };
    }
  });
  defineFunction("mathcal", "{:math*}", {
    applyStyle: (_name, _args) => {
      return { variant: "calligraphic", variantStyle: "up" };
    }
  });
  defineFunction("mathscr", "{:math*}", {
    applyStyle: (_name, _args) => {
      return { variant: "script", variantStyle: "up" };
    }
  });
  defineFunction("mbox", "{:text}", {
    ifMode: "math",
    createAtom: (command, args, style, context) => new GroupAtom(args[0], context, {
      changeMode: true,
      style,
      mode: "text",
      command,
      serialize: (atom, options) => `\\mbox{${atom.bodyToLatex(__spreadProps(__spreadValues({}, options), {
        skipModeCommand: true
      }))}}`
    })
  });
  defineFunction("text", "{:text}", {
    ifMode: "math",
    applyMode: "text"
  });
  defineFunction("class", "{name:string}{content:auto*}", {
    createAtom: (_command, args, style, context) => new GroupAtom(args[1], context, {
      customClass: args[0],
      style
    })
  });
  defineFunction("cssId", "{id:string}{content:auto}", {
    createAtom: (command, args, style, context) => new GroupAtom(args[1], context, {
      cssId: args[0],
      style
    })
  });
  defineFunction("htmlData", "{data:string}{content:auto}", {
    createAtom: (command, args, style, context) => new GroupAtom(args[1], context, {
      htmlData: args[0],
      style
    })
  });
  defineFunction("htmlStyle", "{data:string}{content:auto}", {
    createAtom: (command, args, style, context) => new GroupAtom(args[1], context, {
      htmlStyle: args[0],
      style
    })
  });
  defineFunction("em", "{:auto*}", {
    createAtom: (command, args, style, context) => new GroupAtom(args[0], context, {
      latexOpen: "\\em",
      latexClose: "",
      customClass: "ML__emph",
      style
    })
  });
  defineFunction("emph", "{:auto}", {
    createAtom: (command, args, style, context) => new GroupAtom(args[0], context, {
      latexOpen: "\\emph{",
      latexClose: "}",
      customClass: "ML__emph",
      style
    })
  });
  var DELIMITER_SIZES = {
    "\\bigl": { mclass: "mopen", size: 1 },
    "\\Bigl": { mclass: "mopen", size: 2 },
    "\\biggl": { mclass: "mopen", size: 3 },
    "\\Biggl": { mclass: "mopen", size: 4 },
    "\\bigr": { mclass: "mclose", size: 1 },
    "\\Bigr": { mclass: "mclose", size: 2 },
    "\\biggr": { mclass: "mclose", size: 3 },
    "\\Biggr": { mclass: "mclose", size: 4 },
    "\\bigm": { mclass: "mrel", size: 1 },
    "\\Bigm": { mclass: "mrel", size: 2 },
    "\\biggm": { mclass: "mrel", size: 3 },
    "\\Biggm": { mclass: "mrel", size: 4 },
    "\\big": { mclass: "mord", size: 1 },
    "\\Big": { mclass: "mord", size: 2 },
    "\\bigg": { mclass: "mord", size: 3 },
    "\\Bigg": { mclass: "mord", size: 4 }
  };
  defineFunction(
    [
      "bigl",
      "Bigl",
      "biggl",
      "Biggl",
      "bigr",
      "Bigr",
      "biggr",
      "Biggr",
      "bigm",
      "Bigm",
      "biggm",
      "Biggm",
      "big",
      "Big",
      "bigg",
      "Bigg"
    ],
    "{:delim}",
    {
      createAtom: (name, args, style, context) => new SizedDelimAtom(name, args[0], context, {
        size: DELIMITER_SIZES[name].size,
        delimClass: DELIMITER_SIZES[name].mclass,
        style
      })
    }
  );
  defineFunction(
    [
      "hspace",
      "hspace*"
      // \hspace* inserts a non-breakable space, but since we don't line break...
      // it's the same as \hspace.
    ],
    "{width:glue}",
    {
      createAtom: (name, args, style, context) => {
        var _a3;
        return new SpacingAtom(
          name,
          style,
          context,
          (_a3 = args[0]) != null ? _a3 : { glue: { dimension: 0 } }
        );
      }
    }
  );
  defineFunction(
    [
      "mkern",
      "kern"
      // mkern accepts `mu` as a unit. We're lenient and
      // also accept it with `kern`
    ],
    "{width:glue}",
    {
      createAtom: (name, args, style, context) => {
        var _a3;
        return new SpacingAtom(
          name,
          style,
          context,
          (_a3 = args[0]) != null ? _a3 : { glue: { dimension: 0 } }
        );
      }
    }
  );
  defineFunction("mspace", "{width:glue}", {
    createAtom: (name, args, style, context) => {
      var _a3;
      return new SpacingAtom(
        name,
        style,
        context,
        (_a3 = args[0]) != null ? _a3 : { glue: { dimension: 0 } }
      );
    }
  });
  defineFunction("mathop", "{:auto}", {
    createAtom: (command, args, style, context) => new OperatorAtom(command, args[0], context, {
      type: "mop",
      captureSelection: true,
      limits: "over-under",
      isFunction: true,
      hasArgument: true,
      style
    })
  });
  defineFunction("mathchoice", "{:math}{:math}{:math}{:math}", {
    createAtom: (_command, args, _style, context) => new ChoiceAtom(args, context)
  });
  defineFunction(
    [
      "mathbin",
      "mathrel",
      "mathopen",
      "mathclose",
      "mathpunct",
      "mathord",
      "mathinner"
    ],
    "{:auto}",
    {
      createAtom: (command, args, style, context) => new OperatorAtom(command, args[0], context, {
        type: {
          "\\mathbin": "mbin",
          "\\mathrel": "mrel",
          "\\mathopen": "mopen",
          "\\mathclose": "mclose",
          "\\mathpunct": "mpunct",
          "\\mathord": "mord",
          "\\mathinner": "minner"
        }[command],
        captureSelection: true,
        hasArgument: true,
        style
      })
    }
  );
  defineFunction(["operatorname", "operatorname*"], "{operator:math}", {
    createAtom: (name, args, style, context) => {
      const result = new OperatorAtom(name, args[0], context, {
        isFunction: true,
        hasArgument: true,
        limits: name === "\\operatorname" ? "adjacent" : "over-under",
        style
      });
      result.captureSelection = true;
      if (result.body) {
        result.body.forEach((x) => {
          var _a3;
          if (x.type !== "first") {
            x.type = "mord";
            x.value = (_a3 = { "\u2217": "*", "\u2212": "-" }[x.value]) != null ? _a3 : x.value;
            x.isFunction = false;
            if (!x.style.variant && !x.style.variantStyle) {
              x.style.variant = "main";
              x.style.variantStyle = "up";
            }
          }
        });
      }
      return result;
    }
  });
  var UnicodeAtom = class extends Atom {
    constructor(arg, style, context) {
      let codepoint = Number.parseInt(arg);
      if (!Number.isFinite(codepoint))
        codepoint = 10067;
      super("mord", context, {
        value: String.fromCodePoint(codepoint),
        style
      });
      this.codepoint = codepoint;
    }
    serialize(_options) {
      return '\\unicode"' + ("000000" + this.codepoint.toString(16)).toUpperCase().slice(-6);
    }
  };
  defineFunction("unicode", "{charcode:number}", {
    createAtom: (name, args, style, context) => new UnicodeAtom(args[0], style, context)
  });
  defineFunction("rule", "[raise:dimen]{width:dimen}{thickness:dimen}", {
    createAtom: (name, args, style, context) => new RuleAtom(name, context, {
      shift: args[0],
      width: args[1],
      height: args[2],
      style
    })
  });
  defineFunction("overline", "{:auto}", {
    createAtom: (name, args, style, context) => new LineAtom(name, args[0], context, {
      position: "overline",
      style
    })
  });
  defineFunction("underline", "{:auto}", {
    createAtom: (name, args, style, context) => new LineAtom(name, args[0], context, {
      position: "underline",
      style
    })
  });
  defineFunction("overset", "{above:auto}{base:auto}", {
    createAtom: (name, args, style, context) => new OverunderAtom(name, context, {
      above: args[0],
      body: args[1],
      skipBoundary: false,
      style,
      boxType: binRelType(args[1]),
      serialize: (atom, options) => `${atom.command}{${atom.aboveToLatex(options)}}{${atom.bodyToLatex(options)}}`
    })
  });
  defineFunction("underset", "{below:auto}{base:auto}", {
    createAtom: (name, args, style, context) => new OverunderAtom(name, context, {
      below: args[0],
      body: args[1],
      skipBoundary: false,
      style,
      boxType: binRelType(args[1]),
      serialize: (atom, options) => `${name}{${atom.belowToLatex(options)}}{${atom.bodyToLatex(options)}}`
    })
  });
  defineFunction("overunderset", "{above:auto}{below:auto}{base:auto}", {
    createAtom: (name, args, style, context) => new OverunderAtom(name, context, {
      above: args[0],
      below: args[1],
      body: args[2],
      skipBoundary: false,
      style,
      boxType: binRelType(args[2]),
      serialize: (atom, options) => `${atom.command}{${atom.aboveToLatex(options)}}{${atom.bodyToLatex(options)}}`
    })
  });
  defineFunction(
    ["stackrel", "stackbin"],
    "[below:auto]{above:auto}{base:auto}",
    {
      createAtom: (name, args, style, context) => new OverunderAtom(name, context, {
        body: args[2],
        above: args[1],
        below: args[0],
        skipBoundary: false,
        style,
        boxType: name === "\\stackrel" ? "mrel" : "mbin",
        serialize: (atom, options) => `${atom.command}{${atom.aboveToLatex(options)}}{${atom.bodyToLatex(options)}}`
      })
    }
  );
  defineFunction("smash", "[:string]{:auto}", {
    createAtom: (name, args, style, context) => {
      if (!args[0]) {
        return new PhantomAtom(name, args[1], context, {
          smashHeight: true,
          smashDepth: true,
          style
        });
      }
      return new PhantomAtom(name, args[1], context, {
        smashHeight: args[0].includes("t"),
        smashDepth: args[0].includes("b"),
        style
      });
    }
  });
  defineFunction(["vphantom"], "{:auto*}", {
    createAtom: (name, args, style, context) => new PhantomAtom(name, args[1], context, {
      isInvisible: true,
      smashWidth: true,
      style
    })
  });
  defineFunction(["hphantom"], "{:auto*}", {
    createAtom: (name, args, style, context) => new PhantomAtom(name, args[1], context, {
      isInvisible: true,
      smashHeight: true,
      smashDepth: true,
      style
    })
  });
  defineFunction(["phantom"], "{:auto*}", {
    createAtom: (name, args, style, context) => new PhantomAtom(name, args[1], context, {
      isInvisible: true,
      style
    })
  });
  defineFunction("not", "{:math}", {
    createAtom: (name, args, style, context) => {
      if (args.length < 1 || args[0] === null) {
        return new Atom("mrel", context, {
          command: name,
          style,
          value: "\uE020"
        });
      }
      const arg = args[0];
      return new GroupAtom(
        [
          new OverlapAtom(name, "\uE020", context, {
            align: "right",
            style,
            boxType: "mrel"
          }),
          ...arg
        ],
        context,
        {
          boxType: "mrel",
          captureSelection: true,
          command: "\\not",
          serialize: (_atom, options) => {
            const argLatex = Atom.serialize(arg, options);
            if (argLatex.length === 1 && !/[a-zA-Z]/.test(argLatex))
              return "\\not" + argLatex;
            return `\\not{${argLatex}}`;
          }
        }
      );
    }
  });
  defineFunction(["ne", "neq"], "", {
    createAtom: (name, _args, style, context) => new GroupAtom(
      [
        new OverlapAtom(name, "\uE020", context, {
          align: "right",
          style,
          boxType: "mrel"
        }),
        new Atom("mrel", context, { style, value: "=" })
      ],
      context,
      {
        boxType: "mrel",
        captureSelection: true,
        serialize: () => name,
        command: name
      }
    )
  });
  defineFunction("rlap", "{:auto}", {
    createAtom: (name, args, style, context) => new OverlapAtom(name, args[0], context, {
      align: "right",
      style
    })
  });
  defineFunction("llap", "{:auto}", {
    createAtom: (name, args, style, context) => new OverlapAtom(name, args[0], context, { style })
  });
  defineFunction("mathllap", "{:auto}", {
    createAtom: (name, args, style, context) => new OverlapAtom(name, args[0], context, { style })
  });
  defineFunction("mathrlap", "{:auto}", {
    createAtom: (name, args, style, context) => new OverlapAtom(name, args[0], context, {
      align: "right",
      style
    })
  });

  // src/core-definitions/symbols.ts
  newSymbols("0123456789/@.?!");
  newSymbolRange(65, 90);
  newSymbolRange(97, 122);
  newSymbols([
    ["\\forall", 8704],
    ["\\exists", 8707],
    ["\\nexists", 8708, "mord", "ams"],
    ["\\mid", 8739, "mrel"],
    ["\\top", 8868],
    ["\\bot", 8869]
  ]);
  newSymbols([
    ["\\sharp", 9839],
    ["\\flat", 9837],
    ["\\natural", 9838],
    ["\\#", 35],
    ["\\&", 38],
    ["\\clubsuit", 9827],
    ["\\heartsuit", 9825],
    ["\\spadesuit", 9824],
    ["\\diamondsuit", 9826],
    ["\\parallelogram", 9649]
  ]);
  newSymbols([
    ["\\backslash", 92],
    ["\\nabla", 8711],
    ["\\partial", 8706],
    ["\\ell", 8467],
    ["\\hbar", 8463],
    ["\\Q", 81, "mord", "double-struck"],
    // NOTE: Check if standard LaTeX
    ["\\C", 67, "mord", "double-struck"],
    // NOTE: Check if standard LaTeX
    ["\\P", 80, "mord", "double-struck"],
    // NOTE: Check if standard LaTeX
    ["\\pounds", 163],
    ["\\euro", 8364]
    // NOTE: not TeX built-in, but textcomp package
    // TODO Koppa, Stigma, Sampi
  ]);
  newSymbols(
    [
      ["\\rightarrow", 8594],
      ["\\to", 8594],
      ["\\leftarrow", 8592],
      ["\\gets", 8592],
      ["\\Rightarrow", 8658],
      ["\\Leftarrow", 8656],
      ["\\longrightarrow", 10230],
      ["\\longleftarrow", 10229],
      ["\\Longrightarrow", 10233],
      ["\\implies", 10233],
      ["\\Longleftarrow", 10232],
      ["\\impliedby", 10232],
      ["\\longleftrightarrow", 10231],
      ["\\biconditional", 10231],
      ["\\Longleftrightarrow", 10234],
      ["\\mapsto", 8614],
      ["\\longmapsto", 10236],
      ["\\uparrow", 8593],
      ["\\downarrow", 8595],
      ["\\Uparrow", 8657],
      ["\\Downarrow", 8659],
      ["\\updownarrow", 8597],
      ["\\Updownarrow", 8661],
      ["\\hookrightarrow", 8618],
      ["\\hookleftarrow", 8617],
      ["\\rightharpoonup", 8640],
      ["\\leftharpoonup", 8636],
      ["\\rightharpoondown", 8641],
      ["\\leftharpoondown", 8637],
      ["\\searrow", 8600],
      ["\\nearrow", 8599],
      ["\\swarrow", 8601],
      ["\\nwarrow", 8598],
      ["\\originalof", 8886],
      ["\\laplace", 8886],
      ["\\imageof", 8887],
      ["\\Laplace", 8887]
    ],
    "mrel"
  );
  newSymbols([
    // 'ams' Delimiters
    ["\\lbrace", 123, "mopen"],
    ["\\rbrace", 125, "mclose"],
    ["\\lparen", 40, "mopen"],
    ["\\rparen", 41, "mclose"],
    ["\\langle", 10216, "mopen"],
    ["\\rangle", 10217, "mclose"],
    ["\\lfloor", 8970, "mopen"],
    ["\\rfloor", 8971, "mclose"],
    ["\\lceil", 8968, "mopen"],
    ["\\rceil", 8969, "mclose"],
    ["\\vert", 8739],
    ["\\lvert", 8739, "mopen"],
    ["\\rvert", 8739, "mclose"],
    ["\\|", 8741],
    ["\\Vert", 8741],
    ["\\mVert", 8741],
    ["\\lVert", 8741, "mopen"],
    ["\\rVert", 8741, "mclose"],
    ["\\lbrack", 91, "mopen"],
    ["\\rbrack", 93, "mclose"],
    ["\\{", 123, "mopen"],
    ["\\}", 125, "mclose"],
    ["(", 40, "mopen"],
    [")", 41, "mclose"],
    ["[", 91, "mopen"],
    ["]", 93, "mclose"],
    ["\\ulcorner", 9484, "mopen", "ams"],
    ["\\urcorner", 9488, "mclose", "ams"],
    ["\\llcorner", 9492, "mopen", "ams"],
    ["\\lrcorner", 9496, "mclose", "ams"],
    // Large Delimiters
    ["\\lgroup", 10222, "mopen"],
    ["\\rgroup", 10223, "mclose"],
    ["\\lmoustache", 9136, "mopen"],
    ["\\rmoustache", 9137, "mclose"]
    // defineSymbol('\\ne', 0x2260, 'mrel'],
    // defineSymbol('\\neq', 0x2260, 'mrel'],
    // DefineSymbol( '\\longequal', 0xF7D9,  'mrel',  MAIN],   // NOTE: Not TeX
  ]);
  newSymbols(
    [
      // 'ams' arrows
      ["\\dashrightarrow", 8674],
      ["\\dashleftarrow", 8672],
      ["\\Rrightarrow", 8667],
      ["\\Lleftarrow", 8666],
      ["\\leftrightarrows", 8646],
      ["\\rightleftarrows", 8644],
      ["\\curvearrowright", 8631],
      ["\\curvearrowleft", 8630],
      ["\\rightrightarrows", 8649],
      ["\\leftleftarrows", 8647],
      ["\\upuparrows", 8648],
      ["\\downdownarrows", 8650],
      ["\\vartriangle", 9651],
      ["\\triangleq", 8796],
      ["\\vartriangleleft", 8882],
      ["\\trianglelefteq", 8884],
      ["\\ntriangleleft", 8938],
      ["\\ntrianglelefteq", 8940],
      ["\\vartriangleright", 8883],
      ["\\trianglerighteq", 8885],
      ["\\ntriangleright", 8939],
      ["\\ntrianglerighteq", 8941],
      ["\\blacktriangleleft", 9664],
      ["\\blacktriangleright", 9654],
      ["\\leftarrowtail", 8610],
      ["\\rightarrowtail", 8611],
      ["\\looparrowright", 8620],
      ["\\looparrowleft", 8619],
      ["\\twoheadleftarrow", 8606],
      ["\\twoheadrightarrow", 8608],
      ["\\twoheadrightarrowtail", 10518],
      ["\\rightleftharpoons", 8652],
      ["\\leftrightharpoons", 8651],
      ["\\Rsh", 8625],
      ["\\Lsh", 8624],
      // 'ams' Relations
      ["\\circlearrowright", 8635],
      ["\\circlearrowleft", 8634],
      ["\\restriction", 8638],
      ["\\upharpoonright", 8638],
      ["\\upharpoonleft", 8639],
      ["\\downharpoonright", 8642],
      ["\\downharpoonleft", 8643],
      ["\\rightsquigarrow", 8669],
      ["\\leadsto", 8669],
      ["\\leftrightsquigarrow", 8621],
      ["\\multimap", 8888],
      // 'ams' Negated Arrows
      ["\\nleftarrow", 8602],
      ["\\nrightarrow", 8603],
      ["\\nRightarrow", 8655],
      ["\\nLeftarrow", 8653],
      ["\\nleftrightarrow", 8622],
      ["\\nLeftrightarrow", 8654],
      ["\\nvrightarrow", 8696],
      ["\\nvtwoheadrightarrow", 10496],
      ["\\nvrightarrowtail", 10516],
      ["\\nvtwoheadrightarrowtail", 10519],
      // 'ams' Negated Relations
      ["\\shortparallel", 8741],
      ["\\nless", 8814],
      ["\\nleqslant", 57360],
      ["\\lneq", 10887],
      ["\\lneqq", 8808],
      ["\\nleqq", 57361],
      ["\\lvertneqq", 57356],
      ["\\lnsim", 8934],
      ["\\lnapprox", 10889],
      ["\\nprec", 8832],
      ["\\npreceq", 8928],
      ["\\precnsim", 8936],
      ["\\precnapprox", 10937],
      ["\\nsim", 8769],
      ["\\nshortmid", 57350],
      ["\\nmid", 8740],
      ["\\nvdash", 8876],
      ["\\nvDash", 8877],
      ["\\ngtr", 8815],
      ["\\ngeqslant", 57359],
      ["\\ngeqq", 57358],
      ["\\gneq", 10888],
      ["\\gneqq", 8809],
      ["\\gvertneqq", 57357],
      ["\\gnsim", 8935],
      ["\\gnapprox", 10890],
      ["\\nsucc", 8833],
      ["\\nsucceq", 8929],
      ["\\succnsim", 8937],
      ["\\succnapprox", 10938],
      ["\\ncong", 8774],
      ["\\nshortparallel", 57351],
      ["\\nparallel", 8742],
      ["\\nVDash", 8879],
      ["\\nsupseteqq", 57368],
      ["\\supsetneq", 8843],
      ["\\varsupsetneq", 57371],
      ["\\supsetneqq", 10956],
      ["\\varsupsetneqq", 57369],
      ["\\nVdash", 8878],
      ["\\precneqq", 10933],
      ["\\succneqq", 10934],
      ["\\nsubseteqq", 57366],
      ["\\leqslant", 10877],
      ["\\geqslant", 10878],
      ["\\gtrsim", 8819],
      ["\\approxeq", 8778],
      ["\\thickapprox", 8776],
      ["\\lessapprox", 10885],
      ["\\gtrapprox", 10886],
      ["\\precapprox", 10935],
      ["\\succapprox", 10936],
      ["\\thicksim", 8764],
      ["\\succsim", 8831],
      ["\\precsim", 8830],
      ["\\backsim", 8765],
      ["\\eqsim", 8770],
      ["\\backsimeq", 8909],
      ["\\lesssim", 8818],
      ["\\nleq", 8816],
      ["\\ngeq", 8817],
      ["\\smallsmile", 8995],
      ["\\smallfrown", 8994],
      ["\\leqq", 8806],
      ["\\eqslantless", 10901],
      ["\\lll", 8920],
      ["\\lessgtr", 8822],
      ["\\lesseqgtr", 8922],
      ["\\lesseqqgtr", 10891],
      ["\\risingdotseq", 8787],
      ["\\fallingdotseq", 8786],
      ["\\subseteqq", 10949],
      ["\\Subset", 8912],
      ["\\sqsubset", 8847],
      ["\\preccurlyeq", 8828],
      ["\\curlyeqprec", 8926],
      ["\\vDash", 8872],
      ["\\Vvdash", 8874],
      ["\\bumpeq", 8783],
      ["\\Bumpeq", 8782],
      ["\\geqq", 8807],
      ["\\eqslantgtr", 10902],
      ["\\ggg", 8921],
      ["\\gtrless", 8823],
      ["\\gtreqless", 8923],
      ["\\gtreqqless", 10892],
      ["\\supseteqq", 10950],
      ["\\Supset", 8913],
      ["\\sqsupset", 8848],
      ["\\succcurlyeq", 8829],
      ["\\curlyeqsucc", 8927],
      ["\\Vdash", 8873],
      ["\\shortmid", 8739],
      ["\\between", 8812],
      ["\\pitchfork", 8916],
      ["\\varpropto", 8733],
      ["\\backepsilon", 8717],
      ["\\llless", 8920],
      ["\\gggtr", 8921],
      ["\\doteqdot", 8785],
      ["\\Doteq", 8785],
      ["\\eqcirc", 8790],
      ["\\circeq", 8791],
      ["\\therefore", 8756],
      ["\\because", 8757]
    ],
    "mrel",
    "ams"
  );
  newSymbols(
    [
      ["+", 43],
      ["-", 8722],
      ["\u2212", 8722],
      ["\\pm", 177],
      ["\\mp", 8723],
      ["*", 8727],
      ["\\times", 215],
      ["\\div", 247],
      ["\\divides", 8739],
      ["\\cdot", 8901],
      ["\\cap", 8745],
      ["\\cup", 8746],
      ["\\setminus", 8726],
      ["\\land", 8743],
      ["\\wedge", 8743],
      ["\\lor", 8744],
      ["\\vee", 8744],
      ["\\circ", 8728],
      ["\\bigcirc", 9711],
      ["\\bullet", 8729],
      ["\\oplus", 8853],
      ["\\ominus", 8854],
      ["\\otimes", 8855],
      ["\\odot", 8857],
      ["\\oslash", 8856],
      ["\\bigtriangleup", 9651],
      ["\\bigtriangledown", 9661],
      ["\\triangleleft", 9667],
      ["\\triangleright", 9657],
      ["\\And", 38],
      ["\\dagger", 8224],
      ["\\dag", 8224],
      ["\\ddag", 8225],
      ["\\ddagger", 8225],
      ["\\ast", 8727],
      ["\\star", 8902],
      ["\\bigstar", 9733],
      ["\\diamond", 8900]
    ],
    "mbin"
  );
  newSymbols(
    [
      ["\\lhd", 8882],
      ["\\rhd", 8883],
      ["\\lessdot", 8918],
      ["\\gtrdot", 8919],
      ["\\ltimes", 8905],
      ["\\rtimes", 8906],
      ["\\leftthreetimes", 8907],
      ["\\rightthreetimes", 8908],
      ["\\intercal", 8890],
      ["\\dotplus", 8724],
      ["\\doublebarwedge", 10846],
      ["\\divideontimes", 8903],
      ["\\centerdot", 8901],
      ["\\smallsetminus", 8726],
      ["\\barwedge", 8892],
      ["\\veebar", 8891],
      ["\\nor", 8891],
      // NOTE: Not TeX, Mathematica
      ["\\curlywedge", 8911],
      ["\\curlyvee", 8910],
      ["\\boxminus", 8863],
      ["\\boxplus", 8862],
      ["\\boxtimes", 8864],
      ["\\boxdot", 8865],
      ["\\circleddash", 8861],
      ["\\circledast", 8859],
      ["\\circledcirc", 8858],
      ["\\unlhd", 8884],
      ["\\unrhd", 8885]
    ],
    "mbin",
    "ams"
  );
  newSymbols([
    ["\\surd", 8730],
    // From MnSymbol package
    ["\\infty", 8734],
    ["\\prime", 8242],
    ["\\doubleprime", 8243],
    // NOTE: Not in TeX, but Mathematica
    ["\\angle", 8736],
    ["`", 8216],
    ["\\$", 36],
    ["\\%", 37],
    ["\\_", 95],
    // Note: In TeX, greek symbols are only available in Math mode
    ["\\alpha", 945],
    ["\\beta", 946],
    ["\\gamma", 947],
    ["\\delta", 948],
    ["\\epsilon", 1013],
    ["\\varepsilon", 949],
    ["\\zeta", 950],
    ["\\eta", 951],
    ["\\theta", 952],
    ["\\vartheta", 977],
    ["\\iota", 953],
    ["\\kappa", 954],
    ["\\varkappa", 1008, "mord", "ams"],
    ["\\lambda", 955],
    ["\\mu", 956],
    ["\\nu", 957],
    ["\\xi", 958],
    ["\\omicron", 111],
    ["\\pi", 960],
    ["\\varpi", 982],
    ["\\rho", 961],
    ["\\varrho", 1009],
    ["\\sigma", 963],
    ["\\varsigma", 962],
    ["\\tau", 964],
    ["\\phi", 981],
    ["\\varphi", 966],
    ["\\upsilon", 965],
    ["\\chi", 967],
    ["\\psi", 968],
    ["\\omega", 969],
    ["\\Gamma", 915],
    ["\\Delta", 916],
    ["\\Theta", 920],
    ["\\Lambda", 923],
    ["\\Xi", 926],
    ["\\Pi", 928],
    ["\\Sigma", 931],
    ["\\Upsilon", 933],
    ["\\Phi", 934],
    ["\\Psi", 936],
    ["\\Omega", 937],
    // 'ams' Greek
    ["\\digamma", 989, "mord", "ams"],
    ["\\emptyset", 8709]
  ]);
  newSymbols(
    [
      ["=", 61],
      ["<", 60],
      ["\\lt", 60],
      [">", 62],
      ["\\gt", 62],
      ["\\le", 8804],
      ["\\leq", 8804],
      ["\\ge", 8805],
      ["\\geq", 8805],
      ["\\ll", 8810],
      ["\\gg", 8811],
      ["\\coloneq", 8788],
      ["\\measeq", 8797],
      // MEASSURED BY
      ["\\eqdef", 8798],
      ["\\questeq", 8799],
      // QUESTIONED EQUAL TO
      [":", 58],
      ["\\cong", 8773],
      ["\\equiv", 8801],
      ["\\prec", 8826],
      ["\\preceq", 10927],
      ["\\succ", 8827],
      ["\\succeq", 10928],
      ["\\perp", 8869],
      ["\\propto", 8733],
      ["\\Colon", 8759],
      ["\\smile", 8995],
      ["\\frown", 8994],
      ["\\sim", 8764],
      ["\\doteq", 8784],
      ["\\bowtie", 8904],
      ["\\Join", 8904],
      ["\\asymp", 8781],
      ["\\sqsubseteq", 8849],
      ["\\sqsupseteq", 8850],
      ["\\approx", 8776],
      // In TeX, '~' is a spacing command (non-breaking space).
      // However, '~' is used as an ASCII Math shortctut character, so define a \\~
      // command which maps to the '~' character
      ["\\~", 126],
      ["\\leftrightarrow", 8596],
      ["\\Leftrightarrow", 8660],
      ["\\models", 8872],
      ["\\vdash", 8866],
      ["\\dashv", 8867],
      ["\\roundimplies", 10608],
      ["\\in", 8712],
      ["\\notin", 8713],
      // defineSymbol('\\not', 0x0338],
      // defineSymbol('\\not', 0xe020],
      ["\\ni", 8715],
      ["\\owns", 8715],
      ["\\subset", 8834],
      ["\\supset", 8835],
      ["\\subseteq", 8838],
      ["\\supseteq", 8839],
      ["\\differencedelta", 8710],
      ["\\mvert", 8739],
      ["\\parallel", 8741],
      ["\\simeq", 8771]
    ],
    "mrel"
  );
  newSymbols(
    [
      ["\\lnot", 172],
      ["\\neg", 172],
      ["\\triangle", 9651],
      ["\\subsetneq", 8842],
      ["\\varsubsetneq", 57370],
      ["\\subsetneqq", 10955],
      ["\\varsubsetneqq", 57367],
      ["\\nsubset", 8836],
      // NOTE: Not TeX?
      ["\\nsupset", 8837],
      // NOTE: Not TeX?
      ["\\nsubseteq", 8840],
      ["\\nsupseteq", 8841]
    ],
    "mrel",
    "ams"
  );
  newSymbols([
    ["\\wp", 8472],
    ["\\aleph", 8501]
  ]);
  newSymbols(
    [
      ["\\blacktriangle", 9650],
      ["\\hslash", 8463],
      ["\\Finv", 8498],
      ["\\Game", 8513],
      ["\\eth", 240],
      ["\\mho", 8487],
      ["\\Bbbk", 107],
      ["\\yen", 165],
      ["\\square", 9633],
      ["\\Box", 9633],
      ["\\blacksquare", 9632],
      ["\\circledS", 9416],
      ["\\circledR", 174],
      ["\\triangledown", 9661],
      ["\\blacktriangledown", 9660],
      ["\\checkmark", 10003],
      ["\\diagup", 9585],
      ["\\measuredangle", 8737],
      ["\\sphericalangle", 8738],
      ["\\backprime", 8245],
      ["\\backdoubleprime", 8246],
      ["\\Diamond", 9674],
      ["\\lozenge", 9674],
      ["\\blacklozenge", 10731],
      ["\\varnothing", 8709],
      ["\\complement", 8705],
      ["\\maltese", 10016],
      // 'ams' Hebrew
      ["\\beth", 8502],
      ["\\daleth", 8504],
      ["\\gimel", 8503]
    ],
    "mord",
    "ams"
  );
  newSymbols(
    [
      // See http://tex.stackexchange.com/questions/41476/lengths-and-when-to-use-them
      ["\\ ", 160],
      ["~", 160],
      ["\\space", 160]
    ],
    "space"
  );
  defineFunction(["!", ",", ":", ";", "enskip", "enspace", "quad", "qquad"], "", {
    createAtom: (command, _args, style, context) => new SpacingAtom(command, style, context)
  });
  newSymbols(
    [
      ["\\colon", 58],
      ["\\cdotp", 8901],
      ["\\vdots", 8942, "mord"],
      ["\\ldotp", 46],
      [",", 44],
      [";", 59]
    ],
    "mpunct"
  );
  newSymbols(
    [
      ["\\cdots", 8943],
      ["\\ddots", 8945],
      ["\\ldots", 8230],
      ["\\mathellipsis", 8230]
    ],
    "minner"
  );
  newSymbols([
    ["\\/", 47],
    ["|", 8739, "mord"],
    ["\\imath", 305],
    ["\\jmath", 567],
    ["\\degree", 176],
    ["'", 8242],
    // Prime
    ['"', 8221]
    // Double Prime
    // defineSymbol( "\'', 0x2033,  'mord',  MAIN],       // Double Prime
  ]);

  // src/editor-model/selection-utils.ts
  function compareSelection(a, b) {
    if (a.direction === b.direction) {
      const l = a.ranges.length;
      if (b.ranges.length === l) {
        let i = 0;
        while (i < l && compareRange(a.ranges[i], b.ranges[i]) === "equal")
          i++;
        return i === l ? "equal" : "different";
      }
    }
    return "different";
  }
  function compareRange(a, b) {
    if (a[0] === b[0] && a[1] === b[1])
      return "equal";
    return "different";
  }
  function range(selection) {
    let first = Infinity;
    let last = -Infinity;
    for (const range2 of selection.ranges) {
      first = Math.min(first, range2[0], range2[1]);
      last = Math.max(last, range2[0], range2[1]);
    }
    return [first, last];
  }

  // src/editor/shortcuts.ts
  function validateShortcut(siblings, shortcut) {
    if (!shortcut)
      return "";
    if (typeof shortcut === "string")
      return shortcut;
    if (!siblings || shortcut.after === void 0)
      return shortcut.value;
    let nothing = false;
    let letter = false;
    let digit = false;
    let isFunction = false;
    let frac = false;
    let surd = false;
    let binop = false;
    let relop = false;
    let operator = false;
    let punct = false;
    let array = false;
    let openfence = false;
    let closefence = false;
    let text = false;
    let space = false;
    let sibling = siblings[0];
    let index = 0;
    while (sibling && /msubsup|placeholder/.test(sibling.type)) {
      index += 1;
      sibling = siblings[index];
    }
    nothing = !sibling || sibling.type === "first";
    if (sibling) {
      text = sibling.mode === "text";
      letter = !text && sibling.type === "mord" && LETTER.test(sibling.value);
      digit = !text && sibling.type === "mord" && /\d+$/.test(sibling.value);
      isFunction = !text && sibling.isFunction;
      frac = sibling.type === "genfrac";
      surd = sibling.type === "surd";
      binop = sibling.type === "mbin";
      relop = sibling.type === "mrel";
      operator = sibling.type === "mop";
      punct = sibling.type === "mpunct" || sibling.type === "minner";
      array = sibling.type === "array";
      openfence = sibling.type === "mopen";
      closefence = sibling.type === "mclose" || sibling.type === "leftright";
      space = sibling.type === "space";
    }
    if (shortcut.after.includes("nothing") && nothing || shortcut.after.includes("letter") && letter || shortcut.after.includes("digit") && digit || shortcut.after.includes("function") && isFunction || shortcut.after.includes("frac") && frac || shortcut.after.includes("surd") && surd || shortcut.after.includes("binop") && binop || shortcut.after.includes("relop") && relop || shortcut.after.includes("operator") && operator || shortcut.after.includes("punct") && punct || shortcut.after.includes("array") && array || shortcut.after.includes("openfence") && openfence || shortcut.after.includes("closefence") && closefence || shortcut.after.includes("text") && text || shortcut.after.includes("space") && space)
      return shortcut.value;
    return "";
  }
  function getInlineShortcut(context, s, shortcuts) {
    if (!shortcuts)
      return "";
    return validateShortcut(context, shortcuts[s]);
  }

  // src/editor/shortcuts-definitions.ts
  var INLINE_SHORTCUTS = {
    "&": "\\&",
    "%": "\\%",
    // Primes
    "''": "^{\\doubleprime}",
    // Greek letters
    "alpha": "\\alpha",
    "delta": "\\delta",
    "Delta": "\\Delta",
    "pi": "\\pi",
    "Pi": "\\Pi",
    "theta": "\\theta",
    "Theta": "\\Theta",
    // Letter-like
    "ii": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\imaginaryI"
    },
    "jj": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\imaginaryJ"
    },
    "ee": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\exponentialE"
    },
    "nabla": "\\nabla",
    "grad": "\\nabla",
    "del": "\\partial",
    "deg": { after: "digit+space", value: "\\degree" },
    "infty": "\\infty",
    "\u221E": "\\infty",
    // @TODO: doesn't work
    // '&infin;': '\\infty',
    // '&#8734;': '\\infty',
    "oo": {
      after: "nothing+digit+frac+surd+binop+relop+punct+array+openfence+closefence+space",
      value: "\\infty"
    },
    // Big operators
    "\u2211": "\\sum",
    "sum": "\\sum_{#?}^{#?}",
    "int": "\\int_{#?}^{#?}",
    "prod": "\\prod_{#?}^{#?}",
    "sqrt": "\\sqrt{#?}",
    // '':                    '\\int',             // There's a alt-B command for this
    "\u2206": "\\differentialD",
    // @TODO: is \\diffD most common?
    "\u2202": "\\differentialD",
    // Functions
    "arcsin": "\\arcsin",
    "arccos": "\\arccos",
    "arctan": "\\arctan",
    "arcsec": "\\arcsec",
    "arccsc": "\\arccsc",
    "arsinh": "\\arsinh",
    "arcosh": "\\arcosh",
    "artanh": "\\artanh",
    "arcsech": "\\arcsech",
    "arccsch": "\\arccsch",
    "arg": "\\arg",
    "ch": "\\ch",
    "cosec": "\\cosec",
    "cosh": "\\cosh",
    "cot": "\\cot",
    "cotg": "\\cotg",
    "coth": "\\coth",
    "csc": "\\csc",
    "ctg": "\\ctg",
    "cth": "\\cth",
    "sec": "\\sec",
    "sinh": "\\sinh",
    "sh": "\\sh",
    "tanh": "\\tanh",
    "tg": "\\tg",
    "th": "\\th",
    "sin": "\\sin",
    "cos": "\\cos",
    "tan": "\\tan",
    "lg": "\\lg",
    "lb": "\\lb",
    "log": "\\log",
    "ln": "\\ln",
    "exp": "\\exp",
    "lim": "\\lim_{#?}",
    // Differentials
    // According to ISO31/XI (ISO 80000-2), differentials should be upright
    "dx": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\differentialD x"
    },
    "dy": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\differentialD y"
    },
    "dt": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\differentialD t"
    },
    // Logic
    "AA": "\\forall",
    "EE": "\\exists",
    "!EE": "\\nexists",
    "&&": "\\land",
    // The shortcut for the greek letter "xi" is interfering with "x in"
    "xin": {
      after: "nothing+text+relop+punct+openfence+space",
      value: "x \\in"
    },
    "in": {
      after: "nothing+letter+closefence",
      value: "\\in"
    },
    "!in": "\\notin",
    // Sets
    "NN": "\\mathbb{N}",
    // Natural numbers
    "ZZ": "\\Z",
    // Integers
    "QQ": "\\Q",
    // Rational numbers
    "RR": "\\R",
    // Real numbers
    "CC": "\\C",
    // Complex numbers
    // Operators
    "xx": "\\times",
    "+-": "\\pm",
    // Relational operators
    "\u2260": "\\ne",
    "!=": "\\ne",
    "\u2265": "\\ge",
    ">=": "\\ge",
    "\u2264": "\\le",
    "<=": "\\le",
    "<<": "\\ll",
    ">>": "\\gg",
    "~~": "\\approx",
    // More operators
    "\u2248": "\\approx",
    "?=": "\\questeq",
    "\xF7": "\\div",
    "\xAC": "\\neg",
    ":=": "\\coloneq",
    "::": "\\Colon",
    // Fences
    "(:": "\\langle",
    ":)": "\\rangle",
    // More Greek letters
    "beta": "\\beta",
    "chi": "\\chi",
    "epsilon": "\\epsilon",
    "varepsilon": "\\varepsilon",
    "eta": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\eta"
    },
    "gamma": "\\gamma",
    "Gamma": "\\Gamma",
    "iota": "\\iota",
    "kappa": "\\kappa",
    "lambda": "\\lambda",
    "Lambda": "\\Lambda",
    "mu": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\mu"
    },
    "nu": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\nu"
    },
    "\xB5": "\\mu",
    // @TODO: or micro?
    "phi": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\phi"
    },
    "Phi": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\Phi"
    },
    "varphi": "\\varphi",
    "psi": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\psi"
    },
    "Psi": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\Psi"
    },
    "rho": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\rho"
    },
    "sigma": "\\sigma",
    "Sigma": "\\Sigma",
    "tau": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\tau"
    },
    "vartheta": "\\vartheta",
    "upsilon": "\\upsilon",
    "xi": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space",
      value: "\\xi"
    },
    "Xi": {
      after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
      value: "\\Xi"
    },
    "zeta": "\\zeta",
    "omega": "\\omega",
    "Omega": "\\Omega",
    "\u03A9": "\\omega",
    // @TODO: or ohm?
    // More Logic
    "forall": "\\forall",
    "exists": "\\exists",
    "!exists": "\\nexists",
    ":.": "\\therefore",
    // MORE FUNCTIONS
    // 'arg': '\\arg',
    "liminf": "\\liminf_{#?}",
    "limsup": "\\limsup_{#?}",
    "argmin": "\\operatorname*{arg~min}_{#?}",
    "argmax": "\\operatorname*{arg~max}_{#?}",
    "det": "\\det",
    "mod": "\\mod",
    "max": "\\max",
    "min": "\\min",
    "erf": "\\operatorname{erf}",
    "erfc": "\\operatorname{erfc}",
    "bessel": "\\operatorname{bessel}",
    "mean": "\\operatorname{mean}",
    "median": "\\operatorname{median}",
    "fft": "\\operatorname{fft}",
    "lcm": "\\operatorname{lcm}",
    "gcd": "\\operatorname{gcd}",
    "randomReal": "\\operatorname{randomReal}",
    "randomInteger": "\\operatorname{randomInteger}",
    "Re": "\\operatorname{Re}",
    "Im": "\\operatorname{Im}",
    // UNITS
    "mm": {
      after: "nothing+digit+operator",
      value: "\\operatorname{mm}"
      // Millimeter
    },
    "cm": {
      after: "nothing+digit+operator",
      value: "\\operatorname{cm}"
      // Centimeter
    },
    "km": {
      after: "nothing+digit+operator",
      value: "\\operatorname{km}"
      // Kilometer
    },
    "kg": {
      after: "nothing+digit+operator",
      value: "\\operatorname{kg}"
      // Kilogram
    },
    // '||':                   '\\lor',
    "...": "\\ldots",
    // In general, use \ldots
    "+...": "+\\cdots",
    // ... but use \cdots after + ...
    "-...": "-\\cdots",
    // ... - and ...
    "->...": "\\to\\cdots",
    // ->
    "-->...": "\\longrightarrow\\cdots",
    "->": "\\to",
    "|->": "\\mapsto",
    "-->": "\\longrightarrow",
    //    '<-':                   '\\leftarrow',
    "<--": "\\longleftarrow",
    "=>": "\\Rightarrow",
    "==>": "\\Longrightarrow",
    // '<=': '\\Leftarrow',     // CONFLICTS WITH LESS THAN OR EQUAL
    "<=>": "\\Leftrightarrow",
    "<->": "\\leftrightarrow",
    "(.)": "\\odot",
    "(+)": "\\oplus",
    "(/)": "\\oslash",
    "(x)": "\\otimes",
    "(-)": "\\ominus",
    // '(-)':                  '\\circleddash',
    "||": "\\Vert",
    "{": "\\{",
    "}": "\\}",
    "*": "\\cdot",
    //
    // ASCIIIMath
    //
    // Binary operation symbols
    //
    "**": "\\star",
    "***": "\\ast",
    "//": "\\slash",
    "\\\\": "\\backslash",
    "setminus": "\\backslash",
    "|><": "\\ltimes",
    "><|": "\\rtimes",
    "|><|": "\\bowtie",
    "-:": "\\div",
    "divide": "\\div",
    "@": "\\circ",
    "o+": "\\oplus",
    "ox": "\\otimes",
    "o.": "\\odot",
    "^^": "\\wedge",
    "^^^": "\\bigwedge",
    "vv": "\\vee",
    "vvv": "\\bigvee",
    "nn": "\\cap",
    "nnn": "\\bigcap",
    "uu": "\\cup",
    "uuu": "\\bigcup",
    // Binary relation symbols
    "-=": "\\equiv",
    "~=": "\\cong",
    "lt": "<",
    "lt=": "\\leq",
    "gt": ">",
    "gt=": "\\geq",
    "-<": "\\prec",
    "-lt": "\\prec",
    "-<=": "\\preceq",
    // '>-':                   '\\succ',
    ">-=": "\\succeq",
    "prop": "\\propto",
    "diamond": "\\diamond",
    "square": "\\square",
    "iff": "\\iff",
    "sub": "\\subset",
    "sup": "\\supset",
    "sube": "\\subseteq",
    "supe": "\\supseteq",
    "uarr": "\\uparrow",
    "darr": "\\downarrow",
    "rarr": "\\rightarrow",
    "rArr": "\\Rightarrow",
    "larr": "\\leftarrow",
    "lArr": "\\Leftarrow",
    "harr": "\\leftrightarrow",
    "hArr": "\\Leftrightarrow",
    "aleph": "\\aleph",
    // Logic
    "and": "\\land",
    "or": "\\lor",
    "not": "\\neg",
    "_|_": "\\bot",
    "TT": "\\top",
    "|--": "\\vdash",
    "|==": "\\models",
    // Other functions
    "|__": "\\lfloor",
    "__|": "\\rfloor",
    "|~": "\\lceil",
    "~|": "\\rceil",
    // Arrows
    ">->": "\\rightarrowtail",
    "->>": "\\twoheadrightarrow",
    // \char"21A0
    ">->>": "\\twoheadrightarrowtail",
    // \char"2916
    //
    // Desmos Graphing Calculator
    //
    "frac": "\\frac{#?}{#?}",
    "cbrt": "\\sqrt[3]{#?}",
    "nthroot": "\\sqrt[#?]{#?}"
  };

  // src/editor/parse-math-string.ts
  function parseMathString(s, options) {
    var _a3;
    let format = (_a3 = options == null ? void 0 : options.format) != null ? _a3 : "auto";
    if (format === "auto")
      [format, s] = inferFormat(s);
    if (format === "ascii-math") {
      s = s.replace(/\u2061/gu, "");
      s = s.replace(/\u3016/gu, "{");
      s = s.replace(/\u3017/gu, "}");
      s = s.replace(/([^\\])sinx/g, "$1\\sin x");
      s = s.replace(/([^\\])cosx/g, "$1\\cos x ");
      s = s.replace(/\u2013/g, "-");
      return [
        "ascii-math",
        parseMathExpression(s, { inlineShortcuts: options == null ? void 0 : options.inlineShortcuts })
      ];
    }
    return ["latex", s];
  }
  function parseMathExpression(s, options) {
    var _a3, _b3, _c2;
    if (!s)
      return "";
    let done = false;
    let m;
    const inlineShortcuts = (_a3 = options.inlineShortcuts) != null ? _a3 : INLINE_SHORTCUTS;
    if (!done && (s.startsWith("^") || s.startsWith("_"))) {
      m = parseMathArgument(s.slice(1), { inlineShortcuts, noWrap: true });
      s = s[0] + "{" + m.match + "}";
      s += parseMathExpression(m.rest, options);
      done = true;
    }
    if (!done) {
      m = s.match(/^(sqrt|\u221A)(.*)/);
      if (m) {
        m = parseMathArgument(m[2], { inlineShortcuts, noWrap: true });
        const sqrtArgument = (_b3 = m.match) != null ? _b3 : "\\placeholder{}";
        s = "\\sqrt{" + sqrtArgument + "}";
        s += parseMathExpression(m.rest, options);
        done = true;
      }
    }
    if (!done) {
      m = s.match(/^(\\cbrt|\u221B)(.*)/);
      if (m) {
        m = parseMathArgument(m[2], { inlineShortcuts, noWrap: true });
        const sqrtArgument = (_c2 = m.match) != null ? _c2 : "\\placeholder{}";
        s = "\\sqrt[3]{" + sqrtArgument + "}";
        s += parseMathExpression(m.rest, options);
        done = true;
      }
    }
    if (!done) {
      m = s.match(/^abs(.*)/);
      if (m) {
        m = parseMathArgument(m[1], { inlineShortcuts, noWrap: true });
        s = "\\left|" + m.match + "\\right|";
        s += parseMathExpression(m.rest, options);
        done = true;
      }
    }
    if (!done) {
      m = s.match(/^["](.*?)["](.*)/);
      if (m) {
        s = "\\text{" + m[1] + "}";
        s += parseMathExpression(m[2], options);
        done = true;
      }
    }
    if (!done) {
      m = s.match(/^([^a-zA-Z\(\{\[\_\^\\\s"]+)(.*)/);
      if (m) {
        s = paddedShortcut(m[1], inlineShortcuts);
        s += parseMathExpression(m[2], options);
        done = true;
      }
    }
    if (!done && /^([fgh])[^a-zA-Z]/.test(s)) {
      m = parseMathArgument(s.slice(1), { inlineShortcuts, noWrap: true });
      s = s[1] === "(" ? s[0] + "\\left(" + m.match + "\\right)" : s[0] + m.match;
      s += parseMathExpression(m.rest, options);
      done = true;
    }
    if (!done) {
      m = s.match(/^([a-zA-Z]+)(.*)/);
      if (m) {
        s = paddedShortcut(m[1], inlineShortcuts);
        s += parseMathExpression(m[2], options);
        done = true;
      }
    }
    if (!done) {
      m = parseMathArgument(s, { inlineShortcuts, noWrap: true });
      if (m.match && m.rest[0] === "/") {
        const m2 = parseMathArgument(m.rest.slice(1), {
          inlineShortcuts,
          noWrap: true
        });
        if (m2.match) {
          s = "\\frac{" + m.match + "}{" + m2.match + "}" + parseMathExpression(m2.rest, options);
        }
        done = true;
      } else if (m.match) {
        s = s.startsWith("(") ? "\\left(" + m.match + "\\right)" + parseMathExpression(m.rest, options) : m.match + parseMathExpression(m.rest, options);
        done = true;
      }
    }
    if (!done) {
      m = s.match(/^(\s+)(.*)$/);
      if (m) {
        s = " " + parseMathExpression(m[2], options);
        done = true;
      }
    }
    return s;
  }
  function parseMathArgument(s, options) {
    let match = "";
    s = s.trim();
    let rest = s;
    let lFence = s.charAt(0);
    let rFence = { "(": ")", "{": "}", "[": "]" }[lFence];
    if (rFence) {
      let level = 1;
      let i = 1;
      while (i < s.length && level > 0) {
        if (s[i] === lFence)
          level++;
        if (s[i] === rFence)
          level--;
        i++;
      }
      if (level === 0) {
        if (options.noWrap && lFence === "(")
          match = parseMathExpression(s.substring(1, i - 1), options);
        else {
          if (lFence === "{" && rFence === "}") {
            lFence = "\\{";
            rFence = "\\}";
          }
          match = "\\left" + lFence + parseMathExpression(s.substring(1, i - 1), options) + "\\right" + rFence;
        }
        rest = s.slice(Math.max(0, i));
      } else {
        match = s.substring(1, i);
        rest = "";
      }
    } else {
      let m = s.match(/^([a-zA-Z]+)/);
      if (m) {
        let shortcut = getInlineShortcut(null, s, options.inlineShortcuts);
        if (shortcut) {
          shortcut = shortcut.replace("_{#?}", "");
          shortcut = shortcut.replace("^{#?}", "");
          return { match: shortcut, rest: s.slice(shortcut.length) };
        }
      }
      m = s.match(/^([a-zA-Z])/);
      if (m) {
        return { match: m[1], rest: s.slice(1) };
      }
      m = s.match(/^(-)?\d+(\.\d*)?/);
      if (m) {
        return { match: m[0], rest: s.slice(m[0].length) };
      }
      if (!/^\\(left|right)/.test(s)) {
        m = s.match(/^(\\[a-zA-Z]+)/);
        if (m) {
          rest = s.slice(m[1].length);
          match = m[1];
        }
      }
    }
    return { match, rest };
  }
  function paddedShortcut(s, shortcuts) {
    let result = getInlineShortcut(null, s, shortcuts);
    if (result) {
      result = result.replace("_{#?}", "");
      result = result.replace("^{#?}", "");
      result += " ";
    } else
      result = s;
    return result;
  }
  var MODE_SHIFT_COMMANDS = [
    ["\\[", "\\]"],
    ["\\(", "\\)"],
    ["$$", "$$"],
    ["$", "$"],
    // Must be *after* $$..$$
    ["\\begin{math}", "\\end{math}"],
    ["\\begin{displaymath}", "\\end{displaymath}"],
    ["\\begin{equation}", "\\end{equation}"],
    ["\\begin{equation*}", "\\end{equation*}"]
  ];
  function trimModeShiftCommand(s) {
    const trimedString = s.trim();
    for (const mode of MODE_SHIFT_COMMANDS) {
      if (trimedString.startsWith(mode[0]) && trimedString.endsWith(mode[1])) {
        return [
          true,
          trimedString.substring(
            mode[0].length,
            trimedString.length - mode[1].length
          )
        ];
      }
    }
    return [false, s];
  }
  function inferFormat(s) {
    s = s.trim();
    if (s.length <= 1)
      return ["latex", s];
    let hasLatexModeShiftCommand;
    [hasLatexModeShiftCommand, s] = trimModeShiftCommand(s);
    if (hasLatexModeShiftCommand)
      return ["latex", s];
    if (s.startsWith("`") && s.endsWith("`")) {
      s = s.substring(1, s.length - 1);
      return ["ascii-math", s];
    }
    if (s.includes("\\")) {
      return ["latex", s];
    }
    if (/\$.+\$/.test(s)) {
      return ["latex", `\\text{${s}}`];
    }
    return [void 0, s];
  }

  // src/editor-mathfield/mode-editor.ts
  var CLIPBOARD_LATEX_BEGIN = "$$";
  var CLIPBOARD_LATEX_END = "$$";
  var defaultExportHook = (_from, latex, _range) => {
    if (!MODE_SHIFT_COMMANDS.some(
      (x) => latex.startsWith(x[0]) && latex.endsWith(x[1])
    ))
      latex = `${CLIPBOARD_LATEX_BEGIN} ${latex} ${CLIPBOARD_LATEX_END}`;
    return latex;
  };
  var _ModeEditor = class {
    constructor(name) {
      _ModeEditor._registry[name] = this;
    }
    static onPaste(mode, mathfield, data) {
      var _a3;
      if (!mathfield.contentEditable && mathfield.userSelect === "none") {
        mathfield.model.announce("plonk");
        return false;
      }
      if (typeof data === "string") {
        const dataTransfer = new DataTransfer();
        dataTransfer.setData("text/plain", data);
        data = dataTransfer;
      }
      const redispatchedEvent = new ClipboardEvent("paste", {
        clipboardData: data,
        cancelable: true
      });
      if (!((_a3 = mathfield.host) == null ? void 0 : _a3.dispatchEvent(redispatchedEvent)))
        return false;
      return _ModeEditor._registry[mode].onPaste(mathfield, data);
    }
    static onCopy(mathfield, ev) {
      if (!ev.clipboardData)
        return;
      if (!mathfield.contentEditable && mathfield.userSelect === "none") {
        mathfield.model.announce("plonk");
        return;
      }
      const model = mathfield.model;
      const exportRange = model.selectionIsCollapsed ? [0, model.lastOffset] : range(model.selection);
      let atoms = model.getAtoms(exportRange);
      if (atoms.every((x) => x.mode === "text" || !x.mode)) {
        ev.clipboardData.setData(
          "text/plain",
          atoms.filter((x) => x instanceof TextAtom).map((x) => x.value).join("")
        );
      } else if (atoms.every((x) => x.mode === "latex")) {
        ev.clipboardData.setData(
          "text/plain",
          model.getAtoms(exportRange, { includeChildren: true }).map((x) => {
            var _a3;
            return (_a3 = x.value) != null ? _a3 : "";
          }).join("")
        );
      } else {
        let latex;
        if (atoms.length === 1 && atoms[0].verbatimLatex !== void 0)
          latex = atoms[0].verbatimLatex;
        else
          latex = model.getValue(exportRange, "latex-expanded");
        ev.clipboardData.setData("application/x-latex", latex);
        try {
          ev.clipboardData.setData(
            "text/plain",
            mathfield.options.onExport(mathfield, latex, exportRange)
          );
        } catch (e) {
        }
        if (atoms.length === 1 && (atoms[0].type === "root" || atoms[0].type === "group"))
          atoms = atoms[0].body.filter((x) => x.type !== "first");
        try {
          ev.clipboardData.setData(
            "application/json+mathlive",
            JSON.stringify(atoms.map((x) => x.toJson()))
          );
        } catch (e) {
        }
        const ce = window.MathfieldElement.computeEngine;
        if (ce) {
          try {
            ce.jsonSerializationOptions = { metadata: ["latex"] };
            const expr = ce.parse(latex);
            const mathJson = JSON.stringify(expr.json);
            if (mathJson)
              ev.clipboardData.setData("application/json", mathJson);
          } catch (e) {
          }
        }
      }
      ev.preventDefault();
    }
    static insert(mode, model, text, options = {}) {
      return _ModeEditor._registry[mode].insert(model, text, options);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onPaste(_mathfield, _data) {
      return false;
    }
    insert(_model, _text, _options) {
      return false;
    }
  };
  var ModeEditor = _ModeEditor;
  ModeEditor._registry = {};

  // src/editor/keybindings-definitions.ts
  var DEFAULT_KEYBINDINGS = [
    { key: "left", command: "moveToPreviousChar" },
    { key: "right", command: "moveToNextChar" },
    { key: "up", command: "moveUp" },
    { key: "down", command: "moveDown" },
    { key: "shift+[ArrowLeft]", command: "extendSelectionBackward" },
    { key: "shift+[ArrowRight]", command: "extendSelectionForward" },
    { key: "shift+[ArrowUp]", command: "extendSelectionUpward" },
    { key: "shift+[ArrowDown]", command: "extendSelectionDownward" },
    { key: "[Backspace]", command: "deleteBackward" },
    { key: "alt+[Delete]", command: "deleteBackward" },
    { key: "[Delete]", command: "deleteForward" },
    { key: "alt+[Backspace]", command: "deleteForward" },
    { key: "alt+[ArrowLeft]", command: "moveToPreviousWord" },
    { key: "alt+[ArrowRight]", command: "moveToNextWord" },
    { key: "shift+alt+[ArrowLeft]", command: "extendToPreviousWord" },
    { key: "shift+alt+[ArrowRight]", command: "extendToNextWord" },
    { key: "ctrl+[ArrowLeft]", command: "moveToGroupStart" },
    { key: "ctrl+[ArrowRight]", command: "moveToGroupEnd" },
    { key: "shift+ctrl+[ArrowLeft]", command: "extendToGroupStart" },
    { key: "shift+ctrl+[ArrowRight]", command: "extendToGroupEnd" },
    { key: "[Space]", ifMode: "math", command: "moveAfterParent" },
    { key: "shift+[Space]", ifMode: "math", command: "moveBeforeParent" },
    { key: "[Home]", command: "moveToMathfieldStart" },
    { key: "cmd+[ArrowLeft]", command: "moveToMathfieldStart" },
    { key: "shift+[Home]", command: "extendToMathFieldStart" },
    { key: "shift+cmd+[ArrowLeft]", command: "extendToMathFieldStart" },
    { key: "[End]", command: "moveToMathfieldEnd" },
    { key: "cmd+[ArrowRight]", command: "moveToMathfieldEnd" },
    { key: "shift+[End]", command: "extendToMathFieldEnd" },
    { key: "shift+cmd+[ArrowRight]", command: "extendToMathFieldEnd" },
    { key: "[Pageup]", command: "moveToGroupStart" },
    { key: "[Pagedown]", command: "moveToGroupEnd" },
    { key: "[Tab]", ifMode: "math", command: "moveToNextPlaceholder" },
    {
      key: "shift+[Tab]",
      ifMode: "math",
      command: "moveToPreviousPlaceholder"
    },
    { key: "[Tab]", ifMode: "text", command: "moveToNextPlaceholder" },
    {
      key: "shift+[Tab]",
      ifMode: "text",
      command: "moveToPreviousPlaceholder"
    },
    { key: "[Escape]", ifMode: "math", command: ["switchMode", "latex"] },
    { key: "[Escape]", ifMode: "text", command: ["switchMode", "latex"] },
    {
      key: "[Escape]",
      ifMode: "latex",
      command: ["complete", "complete", { selectItem: "true" }]
    },
    // Accept the entry (without the suggestion) and select
    {
      key: "\\",
      ifMode: "math",
      command: ["switchMode", "latex", "\\"]
    },
    // { key: '[Backslash]', ifMode: 'math', command: ['switchMode', 'latex'] },
    {
      key: "[IntlBackslash]",
      ifMode: "math",
      command: ["switchMode", "latex", "\\"]
    },
    // On UK QWERTY keyboards
    {
      key: "[Tab]",
      ifMode: "latex",
      command: ["complete", "accept-suggestion"]
    },
    // Complete the suggestion
    { key: "[Return]", ifMode: "latex", command: "complete" },
    { key: "[Enter]", ifMode: "latex", command: "complete" },
    {
      key: "shift+[Escape]",
      ifMode: "latex",
      command: ["complete", "reject"]
    },
    // Some keyboards can't generate
    // this combination, for example in 60% keyboards it is mapped to ~
    { key: "[ArrowDown]", ifMode: "latex", command: "nextSuggestion" },
    // { key: 'ios:command:[Tab]', ifMode: 'latex',command: 'nextSuggestion' },
    { key: "[ArrowUp]", ifMode: "latex", command: "previousSuggestion" },
    { key: "ctrl+a", ifPlatform: "!macos", command: "selectAll" },
    { key: "cmd+a", command: "selectAll" },
    // Rare keys on some extended keyboards
    { key: "[Cut]", command: "cutToClipboard" },
    { key: "[Copy]", command: "copyToClipboard" },
    { key: "[Paste]", command: "pasteFromClipboard" },
    { key: "[Clear]", command: "deleteBackward" },
    { key: "[Undo]", command: "undo" },
    { key: "[Redo]", command: "redo" },
    { key: "[EraseEof]", command: "deleteToGroupEnd" },
    { key: "ctrl+x", command: "cutToClipboard" },
    { key: "cmd+x", command: "cutToClipboard" },
    { key: "ctrl+c", command: "copyToClipboard" },
    { key: "cmd+c", command: "copyToClipboard" },
    { key: "ctrl+v", command: "pasteFromClipboard" },
    { key: "cmd+v", command: "pasteFromClipboard" },
    { key: "ctrl+z", ifPlatform: "!macos", command: "undo" },
    { key: "cmd+z", command: "undo" },
    { key: "ctrl+y", ifPlatform: "!macos", command: "redo" },
    // ARIA recommendation
    { key: "shift+cmd+y", command: "redo" },
    { key: "shift+ctrl+z", ifPlatform: "!macos", command: "redo" },
    { key: "shift+cmd+z", command: "redo" },
    // EMACS/MACOS BINDINGS
    { key: "ctrl+b", ifPlatform: "macos", command: "moveToPreviousChar" },
    { key: "ctrl+f", ifPlatform: "macos", command: "moveToNextChar" },
    { key: "ctrl+p", ifPlatform: "macos", command: "moveUp" },
    { key: "ctrl+n", ifPlatform: "macos", command: "moveDown" },
    { key: "ctrl+a", ifPlatform: "macos", command: "moveToMathfieldStart" },
    { key: "ctrl+e", ifPlatform: "macos", command: "moveToMathfieldEnd" },
    {
      key: "shift+ctrl+b",
      ifPlatform: "macos",
      command: "extendSelectionBackward"
    },
    {
      key: "shift+ctrl+f",
      ifPlatform: "macos",
      command: "extendSelectionForward"
    },
    {
      key: "shift+ctrl+p",
      ifPlatform: "macos",
      command: "extendSelectionUpward"
    },
    {
      key: "shift+ctrl+n",
      ifPlatform: "macos",
      command: "extendSelectionDownward"
    },
    {
      key: "shift+ctrl+a",
      ifPlatform: "macos",
      command: "extendToMathFieldStart"
    },
    {
      key: "shift+ctrl+e",
      ifPlatform: "macos",
      command: "extendToMathFieldEnd"
    },
    { key: "alt+ctrl+b", ifPlatform: "macos", command: "moveToPreviousWord" },
    { key: "alt+ctrl+f", ifPlatform: "macos", command: "moveToNextWord" },
    {
      key: "shift+alt+ctrl+b",
      ifPlatform: "macos",
      command: "extendToPreviousWord"
    },
    {
      key: "shift+alt+ctrl+f",
      ifPlatform: "macos",
      command: "extendToNextWord"
    },
    { key: "ctrl+h", ifPlatform: "macos", command: "deleteBackward" },
    { key: "ctrl+d", ifPlatform: "macos", command: "deleteForward" },
    { key: "ctrl+l", ifPlatform: "macos", command: "scrollIntoView" },
    // { key: 'ctrl+t', ifPlatform: 'macos', command: 'transpose' },
    // WOLFRAM MATHEMATICA BINDINGS
    {
      key: "ctrl+[Digit2]",
      ifMode: "math",
      command: ["insert", "\\sqrt{#0}"]
    },
    { key: "ctrl+[Digit5]", ifMode: "math", command: "moveToOpposite" },
    { key: "ctrl+[Digit6]", ifMode: "math", command: "moveToSuperscript" },
    { key: "ctrl+[Return]", ifMode: "math", command: "addRowAfter" },
    { key: "ctrl+[Enter]", ifMode: "math", command: "addRowAfter" },
    { key: "cmd+[Return]", ifMode: "math", command: "addRowAfter" },
    { key: "cmd+[Enter]", ifMode: "math", command: "addRowAfter" },
    // Excel keybindings:
    // shift+space: select entire row, ctrl+space: select an entire column
    // shift+ctrl++ or ctrl+numpad+
    // ctrl+- to delete a row or columns
    // MATHLIVE BINDINGS
    { key: "alt+p", ifMode: "math", command: ["insert", "\\pi"] },
    { key: "alt+v", ifMode: "math", command: ["insert", "\\sqrt{#0}"] },
    { key: "alt+o", ifMode: "math", command: ["insert", "\\emptyset"] },
    {
      key: "alt+d",
      ifMode: "math",
      command: ["insert", "\\differentialD"]
    },
    {
      key: "shift+alt+o",
      ifMode: "math",
      command: ["insert", "\\varnothing"]
    },
    {
      key: "shift+alt+d",
      ifMode: "math",
      command: ["insert", "\\partial"]
    },
    {
      key: "alt+[Backslash]",
      ifMode: "math",
      command: ["insert", "\\backslash"]
    },
    // "|" key} override command mode
    {
      key: "[NumpadDivide]",
      ifMode: "math",
      command: ["insert", "\\frac{#@}{#?}"]
    },
    // ??
    {
      key: "alt+[NumpadDivide]",
      ifMode: "math",
      command: ["insert", "\\frac{#?}{#@}"]
    },
    // ??
    // Accessibility
    { key: "shift+alt+k", command: "toggleKeystrokeCaption" },
    { key: "alt+[Space]", command: "toggleVirtualKeyboard" },
    // Note: On Mac OS (as of 10.12), there is a bug/behavior that causes
    // a beep to be generated with certain command+control key combinations.
    // The workaround is to create a default binding file to silence them.
    // In ~/Library/KeyBindings/DefaultKeyBinding.dict add these entries:
    //
    //   {
    //      "^@\UF701" = "noop:";
    //    "^@\UF702" = "noop:";
    //      "^@\UF703" = "noop:";
    //  }
    {
      key: "alt+ctrl+[ArrowUp]",
      command: ["speak", "all", { withHighlighting: false }]
    },
    {
      key: "alt+ctrl+[ArrowDown]",
      command: ["speak", "selection", { withHighlighting: false }]
    },
    //
    // Punctuations and some non-alpha key combinations
    // only work with specific keyboard layouts
    //
    {
      key: "shift+[Quote]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: ["switchMode", "text", "", ""]
    },
    {
      key: "shift+alt+[KeyT]",
      ifMode: "math",
      command: ["switchMode", "text", "", ""]
    },
    {
      key: "shift+[Quote]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "text",
      command: ["switchMode", "math", "", ""]
    },
    {
      key: "shift+alt+[KeyT]",
      ifMode: "text",
      command: ["switchMode", "math", "", ""]
    },
    {
      key: "/",
      ifMode: "math",
      command: ["insert", "\\frac{#@}{#?}"]
    },
    {
      key: "alt+/",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: ["insert", "\\/"]
    },
    {
      key: "alt+[BracketLeft]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: ["insert", "\\left\\lbrack #0 \\right\\rbrack"]
    },
    // ??
    {
      key: "ctrl+[Minus]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: "moveToSubscript"
    },
    // ??
    {
      key: "shift+alt+[BracketLeft]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: ["insert", "\\left\\lbrace #0 \\right\\rbrace"]
    },
    // ??
    {
      key: "ctrl+;",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: "addRowAfter"
    },
    {
      key: "cmd+;",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: "addRowAfter"
    },
    {
      key: "shift+ctrl+;",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: "addRowBefore"
    },
    {
      key: "shift+cmd+;",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: "addRowBefore"
    },
    {
      key: "ctrl+[Backspace]",
      ifMode: "math",
      command: "removeRow"
    },
    {
      key: "cmd+[Backspace]",
      ifMode: "math",
      command: "removeRow"
    },
    {
      key: "ctrl+[Comma]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: "addColumnAfter"
    },
    {
      key: "cmd+[Comma]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: "addColumnAfter"
    },
    {
      key: "shift+ctrl+[Comma]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: "addColumnBefore"
    },
    {
      key: "shift+cmd+[Comma]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: "addColumnBefore"
    },
    {
      key: "shift+[Backspace]",
      ifMode: "math",
      command: "removeColumn"
    },
    {
      key: "alt+[Digit5]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: ["insert", "$\\infty"]
    },
    // "%" key
    {
      key: "alt+[Digit9]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: ["insert", "("]
    },
    // "(" key} override smartFence
    {
      key: "alt+[Digit0]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: ["insert", ")"]
    },
    // ")" key} override smartFence
    {
      key: "alt+|",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: ["insert", "|"]
    },
    // "|" key} override smartFence
    {
      key: "shift+[Backquote]",
      ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
      ifMode: "math",
      command: ["insert", "\\~"]
    },
    // ??
    {
      key: "[Backquote]",
      ifLayout: ["windows.french", "linux.french"],
      ifMode: "math",
      command: ["insert", "^2"]
    }
  ];
  var REVERSE_KEYBINDINGS = {
    "\\sqrt": ["alt+v", "ctrl+[Digit2]"],
    "\\pi": "alt+p",
    "\\infty": "alt+[Digit5]",
    "\\differentialD": "alt+d",
    "\\partial": "shift+alt+d",
    "\\frac": "Slash",
    "\\emptyset": "alt+o",
    "\\varnothing": "shift+alt+o",
    "\\~": "~"
  };

  // src/editor-mathfield/utils.ts
  function on(element, inSelectors, listener, options) {
    const selectors = inSelectors.split(" ");
    for (const sel of selectors) {
      const m = sel.match(/(.*):(.*)/);
      if (m) {
        const options2 = options != null ? options : {};
        if (m[2] === "active")
          options2.passive = false;
        else
          options2[m[2]] = true;
        element.addEventListener(m[1], listener, options2);
      } else
        element.addEventListener(sel, listener, options);
    }
  }
  function off(element, inSelectors, listener, options) {
    const selectors = inSelectors.split(" ");
    for (const sel of selectors) {
      const m = sel.match(/(.*):(.*)/);
      if (m) {
        const options2 = options != null ? options : {};
        if (m[2] === "active")
          options2.passive = false;
        else
          options2[m[2]] = true;
        element.removeEventListener(m[1], listener, options2);
      } else
        element.removeEventListener(sel, listener, options);
    }
  }
  function getSharedElement(id) {
    var _a3;
    throwIfNotInBrowser();
    let result = document.getElementById(id);
    if (result) {
      result.dataset.refcount = Number(
        Number.parseInt((_a3 = result.getAttribute("data-refcount")) != null ? _a3 : "0") + 1
      ).toString();
    } else {
      result = document.createElement("div");
      result.setAttribute("aria-hidden", "true");
      result.dataset.refcount = "1";
      result.id = id;
      document.body.append(result);
    }
    return result;
  }
  function releaseSharedElement(element) {
    var _a3;
    if (!element)
      return;
    const refcount = Number.parseInt(
      (_a3 = element.getAttribute("data-refcount")) != null ? _a3 : "0"
    );
    if (refcount <= 1)
      element.remove();
    else
      element.dataset.refcount = Number(refcount - 1).toString();
  }
  function isValidMathfield(mf) {
    var _a3;
    return ((_a3 = mf.element) == null ? void 0 : _a3.mathfield) === mf;
  }
  function findElementWithCaret(element) {
    var _a3, _b3;
    return (_b3 = (_a3 = element.querySelector(".ML__caret")) != null ? _a3 : element.querySelector(".ML__text-caret")) != null ? _b3 : element.querySelector(".ML__latex-caret");
  }
  function getCaretPoint(element) {
    const caret = findElementWithCaret(element);
    if (!caret)
      return null;
    const bounds = caret.getBoundingClientRect();
    return {
      x: bounds.right,
      y: bounds.bottom,
      height: bounds.height
    };
  }
  function branchId(atom) {
    var _a3;
    if (!atom.parent)
      return "root";
    let result = (_a3 = atom.parent.id) != null ? _a3 : "";
    result += typeof atom.treeBranch === "string" ? "-" + atom.treeBranch : `-${atom.treeBranch[0]}/${atom.treeBranch[0]}`;
    return result;
  }
  function adjustForScrolling(mathfield, rect) {
    if (!rect)
      return null;
    const fieldRect = mathfield.field.getBoundingClientRect();
    const w = rect.right - rect.left;
    const h = rect.bottom - rect.top;
    const left = Math.ceil(
      rect.left - fieldRect.left + mathfield.field.scrollLeft
    );
    const top = Math.ceil(rect.top - fieldRect.top);
    return {
      left,
      right: left + w,
      top,
      bottom: top + h
    };
  }
  function getNodeBounds(node) {
    const bounds = node.getBoundingClientRect();
    const marginRight = parseInt(getComputedStyle(node).marginRight);
    const result = {
      top: bounds.top - 1,
      bottom: bounds.bottom,
      left: bounds.left,
      right: bounds.right - 1 + marginRight
    };
    if (node.children.length === 0 || node.tagName.toUpperCase() === "SVG")
      return result;
    for (const child of node.children) {
      if (child.nodeType === 1 && "atomId" in child.dataset && !child.classList.contains("pstrut")) {
        const r = getNodeBounds(child);
        result.left = Math.min(result.left, r.left);
        result.right = Math.max(result.right, r.right);
        result.top = Math.min(result.top, r.top);
        result.bottom = Math.max(result.bottom, r.bottom);
      }
    }
    return result;
  }
  function getAtomBounds(mathfield, atom) {
    var _a3, _b3;
    if (!atom.id)
      return null;
    let result = (_b3 = (_a3 = mathfield.atomBoundsCache) == null ? void 0 : _a3.get(atom.id)) != null ? _b3 : null;
    if (result !== null)
      return result;
    const node = mathfield.field.querySelector(`[data-atom-id="${atom.id}"]`);
    result = node ? getNodeBounds(node) : null;
    if (mathfield.atomBoundsCache) {
      if (result)
        mathfield.atomBoundsCache.set(atom.id, result);
      else
        mathfield.atomBoundsCache.delete(atom.id);
    }
    return result != null ? result : null;
  }
  function getRangeBounds(mathfield, range2, options) {
    const rects = /* @__PURE__ */ new Map();
    for (const atom of mathfield.model.getAtoms(range2, {
      includeChildren: true
    })) {
      if ((options == null ? void 0 : options.excludeAtomsWithBackground) && atom.style.backgroundColor)
        break;
      const bounds = adjustForScrolling(
        mathfield,
        getAtomBounds(mathfield, atom)
      );
      if (bounds) {
        const id = branchId(atom);
        if (rects.has(id)) {
          const r = rects.get(id);
          rects.set(id, {
            left: Math.min(r.left, bounds.left),
            right: Math.max(r.right, bounds.right),
            top: Math.min(r.top, bounds.top),
            bottom: Math.max(r.bottom, bounds.bottom)
          });
        } else
          rects.set(id, bounds);
      }
    }
    return [...rects.values()];
  }
  function getSelectionBounds(mathfield, options) {
    return mathfield.model.selection.ranges.reduce(
      (acc, x) => acc.concat(...getRangeBounds(mathfield, x, options)),
      []
    );
  }
  function validateOrigin(origin, originValidator) {
    if (origin === "*" || originValidator === "none")
      return true;
    if (originValidator === "same-origin")
      return !window.origin || origin === window.origin;
    if (typeof originValidator === "function")
      return originValidator(origin);
    return false;
  }
  function getLocalDOMRect(el) {
    let offsetTop = 0;
    let offsetLeft = 0;
    const width = el.offsetWidth;
    const height = el.offsetHeight;
    while (el instanceof HTMLElement) {
      offsetTop += el.offsetTop;
      offsetLeft += el.offsetLeft;
      el = el.offsetParent;
    }
    return new DOMRect(offsetLeft, offsetTop, width, height);
  }

  // src/core/modes-math.ts
  var VARIANTS = {
    // Handle some special characters which are only available in "main" font (not "math")
    "main": ["Main-Regular", "ML__cmr"],
    "main-italic": ["Main-Italic", "ML__cmr ML__it"],
    "main-bold": ["Main-Bold", "ML__cmr ML__bold"],
    "main-bolditalic": ["Main-BoldItalic", "ML__cmr ML__bold ML__it"],
    "normal": ["Main-Regular", "ML__cmr"],
    // 'main' font. There is no 'math' regular (upright)
    "normal-bold": ["Main-Bold", "ML__mathbf"],
    // 'main' font. There is no 'math' bold
    "normal-italic": ["Math-Italic", "ML__mathit"],
    // Special metrics for 'math'
    "normal-bolditalic": ["Math-BoldItalic", "ML__mathbfit"],
    // Special metrics for 'math'
    // Extended math symbols, arrows, etc.. at their standard Unicode codepoints
    "ams": ["AMS-Regular", "ML__ams"],
    "ams-bold": ["AMS-Regular", "ML__ams"],
    "ams-italic": ["AMS-Regular", "ML__ams"],
    "ams-bolditalic": ["AMS-Regular", "ML__ams"],
    "sans-serif": ["SansSerif-Regular", "ML__sans"],
    "sans-serif-bold": ["SansSerif-Regular", "ML__sans ML__bold"],
    "sans-serif-italic": ["SansSerif-Regular", "ML__sans"],
    "sans-serif-bolditalic": ["SansSerif-Regular", "ML__sans"],
    "calligraphic": ["Caligraphic-Regular", "ML__cal"],
    "calligraphic-bold": ["Caligraphic-Regular", "ML__cal ML__bold"],
    "calligraphic-italic": ["Caligraphic-Regular", "ML__cal ML__it"],
    "calligraphic-bolditalic": ["Caligraphic-Regular", "ML__cal ML__bold ML__it"],
    "script": ["Script-Regular", "ML__script"],
    "script-bold": ["Script-Regular", "ML__script ML__bold"],
    "script-italic": ["Script-Regular", "ML__script ML__it"],
    "script-bolditalic": ["Script-Regular", "ML__script ML__bold ML__it"],
    "fraktur": ["Fraktur-Regular", "ML__frak"],
    "fraktur-bold": ["Fraktur-Regular", "ML__frak"],
    "fraktur-italic": ["Fraktur-Regular", "ML__frak"],
    "fraktur-bolditalic": ["Fraktur-Regular", "ML__frak"],
    "monospace": ["Typewriter-Regular", "ML__tt"],
    "monospace-bold": ["Typewriter-Regular", "ML__tt ML__bold"],
    "monospace-italic": ["Typewriter-Regular", "ML__tt ML__it"],
    "monospace-bolditalic": ["Typewriter-Regular", "ML__tt ML__bold ML__it"],
    // Blackboard characters are 'A-Z' in the AMS font
    "double-struck": ["AMS-Regular", "ML__bb"],
    "double-struck-bold": ["AMS-Regular", "ML__bb"],
    "double-struck-italic": ["AMS-Regular", "ML__bb"],
    "double-struck-bolditalic": ["AMS-Regular", "ML__bb"]
  };
  var VARIANT_REPERTOIRE = {
    "double-struck": /^[A-Z ]$/,
    "script": /^[A-Z ]$/,
    "calligraphic": /^[\dA-Z ]$/,
    "fraktur": /^[\dA-Za-z ]$|^[!"#$%&'()*+,\-./:;=?[]^]$/,
    "monospace": /^[\dA-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A8\u03A9]$/,
    "sans-serif": /^[\dA-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A8\u03A9]$/
  };
  var GREEK_LOWERCASE = /^[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5]$/;
  var GREEK_UPPERCASE = /^[\u0393|\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A6\u03A8\u03A9]$/;
  var LETTER_SHAPE_RANGES = [
    /^[a-z]$/,
    // Lowercase latin
    /^[A-Z]$/,
    // Uppercase latin
    GREEK_LOWERCASE,
    GREEK_UPPERCASE
  ];
  var LETTER_SHAPE_MODIFIER = {
    iso: ["it", "it", "it", "it"],
    tex: ["it", "it", "it", "up"],
    french: ["it", "up", "up", "up"],
    upright: ["up", "up", "up", "up"]
  };
  var MathMode = class extends Mode {
    constructor() {
      super("math");
    }
    createAtom(command, context, style) {
      var _a3, _b3, _c2, _d2, _e;
      const info = context.getDefinition(command, "math");
      if (info === null) {
        return new Atom("mord", context, {
          mode: "math",
          command,
          value: command,
          style
        });
      }
      if (info.definitionType === "symbol") {
        const result2 = new Atom((_a3 = info.type) != null ? _a3 : "mord", context, {
          mode: "math",
          command: (_b3 = info.command) != null ? _b3 : command,
          value: String.fromCodePoint(info.codepoint),
          style
        });
        if ((_c2 = info.isFunction) != null ? _c2 : false)
          result2.isFunction = true;
        if (command.startsWith("\\"))
          result2.verbatimLatex = command;
        return result2;
      }
      const result = new Atom("mord", context, {
        mode: "math",
        command: (_d2 = info.command) != null ? _d2 : command,
        value: command,
        style
      });
      if ((_e = info.isFunction) != null ? _e : false)
        result.isFunction = true;
      if (command.startsWith("\\"))
        result.verbatimLatex = command;
      return result;
    }
    serialize(run, options) {
      const { parent } = run[0];
      const contextFontsize = parent == null ? void 0 : parent.computedStyle.fontSize;
      return joinLatex(
        getPropertyRuns(run, "fontSize").map((x) => {
          const result = emitBackgroundColorRun(x, options);
          const fontsize = x[0].computedStyle.fontSize;
          if (fontsize && (!parent || contextFontsize !== fontsize)) {
            return "\\" + [
              "",
              "tiny",
              "scriptsize",
              "footnotesize",
              "small",
              "normalsize",
              "large",
              "Large",
              "LARGE",
              "huge",
              "Huge"
            ][fontsize] + " " + result;
          }
          return result;
        })
      );
    }
    applyStyle(box, style) {
      if (style.variant === void 0)
        return "";
      const letterShapeStyle = style.letterShapeStyle === "auto" || !style.letterShapeStyle ? "tex" : style.letterShapeStyle;
      let { variant } = style;
      let { variantStyle } = style;
      if (variant === "normal" && !variantStyle && /[\u00A3\u0131\u0237]/.test(box.value)) {
        variant = "main";
        variantStyle = "italic";
      }
      if (variant === "normal" && !variantStyle && box.value.length === 1) {
        LETTER_SHAPE_RANGES.forEach((x, i) => {
          if (x.test(box.value) && LETTER_SHAPE_MODIFIER[letterShapeStyle][i] === "it")
            variantStyle = "italic";
        });
      }
      if (variantStyle === "up")
        variantStyle = void 0;
      const styledVariant = variantStyle ? variant + "-" + variantStyle : variant;
      console.assert(VARIANTS[styledVariant] !== void 0);
      const [fontName, classes] = VARIANTS[styledVariant];
      if (VARIANT_REPERTOIRE[variant] && !VARIANT_REPERTOIRE[variant].test(box.value)) {
        box.value = mathVariantToUnicode(box.value, variant, variantStyle);
        return null;
      }
      if (GREEK_LOWERCASE.test(box.value))
        box.classes += " lcGreek";
      if (classes)
        box.classes += " " + classes;
      return fontName;
    }
  };
  function emitVariantRun(run, options) {
    var _a3;
    const { parent } = run[0];
    const contextVariant = variantString(parent);
    const parentMode = (_a3 = parent == null ? void 0 : parent.mode) != null ? _a3 : "math";
    return joinLatex(
      getPropertyRuns(run, "variant").map((x) => {
        const variant = variantString(x[0]);
        if (x.every((x2) => {
          const info = x2.context.getDefinition(x2.command, parentMode);
          if (!info || info.definitionType === "function" || !info.variant)
            return false;
          return variantString(x2) === variant;
        }))
          return joinLatex(x.map((x2) => Atom.serialize(x2, options)));
        let command = "";
        if (variant && variant !== contextVariant) {
          command = {
            "calligraphic": "\\mathcal{",
            "fraktur": "\\mathfrak{",
            "double-struck": "\\mathbb{",
            "script": "\\mathscr{",
            "monospace": "\\mathtt{",
            "sans-serif": "\\mathsf{",
            "normal": "\\mathrm{",
            "normal-italic": "\\mathnormal{",
            "normal-bold": "\\mathbf{",
            "normal-bolditalic": "\\mathbfit{",
            "ams": "",
            "ams-italic": "\\mathit{",
            "ams-bold": "\\mathbf{",
            "ams-bolditalic": "\\mathbfit{",
            "main": "",
            "main-italic": "\\mathit{",
            "main-bold": "\\mathbf{",
            "main-bolditalic": "\\mathbfit{"
            // There are a few rare font families possible, which
            // are not supported:
            // mathbbm, mathbbmss, mathbbmtt, mathds, swab, goth
            // In addition, the 'main' and 'math' font technically
            // map to \mathnormal{}
          }[variant];
          console.assert(command !== void 0);
        }
        if (!command)
          return joinLatex(x.map((x2) => Atom.serialize(x2, options)));
        return command + joinLatex(x.map((x2) => Atom.serialize(x2, options))) + "}";
      })
    );
  }
  function emitColorRun(run, options) {
    const { parent } = run[0];
    const contextColor = parent == null ? void 0 : parent.computedStyle.color;
    return joinLatex(
      getPropertyRuns(run, "color").map((x) => {
        var _a3, _b3;
        const result = emitVariantRun(x, options);
        const style = x[0].computedStyle;
        if (!((_a3 = options.skipStyles) != null ? _a3 : false) && style.color && (!parent || contextColor !== style.color)) {
          return "\\textcolor{" + ((_b3 = style.verbatimColor) != null ? _b3 : style.color) + "}{" + result + "}";
        }
        return result;
      })
    );
  }
  function emitBackgroundColorRun(run, options) {
    const { parent } = run[0];
    const parentColor = parent == null ? void 0 : parent.computedStyle.backgroundColor;
    return joinLatex(
      getPropertyRuns(run, "backgroundColor").map((x) => {
        var _a3, _b3;
        let result = emitColorRun(x, options);
        const style = x[0].computedStyle;
        if (!((_a3 = options.skipStyles) != null ? _a3 : false) && result.trim() && style.backgroundColor && (!parent || parentColor !== style.backgroundColor) && (x.length > 0 || !(x[0] instanceof BoxAtom))) {
          result = `\\ensuremath{${result}}`;
          result = `\\colorbox{${(_b3 = style.verbatimBackgroundColor) != null ? _b3 : style.backgroundColor}}{${result}}`;
        }
        return result;
      })
    );
  }
  function variantString(atom) {
    if (!atom)
      return "";
    const { style } = atom;
    if (style.variant === void 0)
      return "";
    let result = style.variant;
    if (style.variantStyle && style.variantStyle !== "up")
      result += "-" + style.variantStyle;
    return result;
  }
  new MathMode();

  // src/core/modes-text.ts
  function join(segments) {
    return [
      joinLatex(segments.map((x) => x[0])),
      segments.map((x) => x[1]).some((x) => x === true)
    ];
  }
  function emitStringTextRun(run, options) {
    return [joinLatex(run.map((x) => Atom.serialize(x, options))), true];
  }
  function emitFontShapeTextRun(run, options) {
    return join(
      getPropertyRuns(run, "fontShape").map((x) => {
        const [s, needsWrap] = emitStringTextRun(x, options);
        const { fontShape } = x[0].style;
        if (fontShape === "it")
          return ["\\textit{" + s + "}", false];
        if (fontShape === "sl")
          return ["\\textsl{" + s + "}", false];
        if (fontShape === "sc")
          return ["\\textsc{" + s + "}", false];
        if (fontShape === "n")
          return ["\\textup{" + s + "}", false];
        if (fontShape)
          return [`{\\fontshape{${x[0].style.fontShape}}${s}`, false];
        return [s, needsWrap];
      })
    );
  }
  function emitFontSeriesTextRun(run, options) {
    return join(
      getPropertyRuns(run, "fontSeries").map((x) => {
        const [s, needsWrap] = emitFontShapeTextRun(x, options);
        const { fontSeries } = x[0].style;
        if (fontSeries === "b")
          return [`\\textbf{${s}}`, false];
        if (fontSeries === "l")
          return [`\\textlf{${s}}`, false];
        if (fontSeries === "m")
          return [`\\textmd{${s}}`, false];
        if (fontSeries)
          return [`\\fontseries{${fontSeries}}${s}`, false];
        return [s, needsWrap];
      })
    );
  }
  function emitSizeTextRun(run, options) {
    return join(
      getPropertyRuns(run, "fontSize").map((x) => {
        var _a3, _b3;
        const [s, needsWrap] = emitFontSeriesTextRun(x, options);
        const command = (_b3 = [
          "",
          "tiny",
          "scriptsize",
          "footnotesize",
          "small",
          "normalsize",
          "large",
          "Large",
          "LARGE",
          "huge",
          "Huge"
        ][(_a3 = x[0].style.fontSize) != null ? _a3 : ""]) != null ? _b3 : "";
        if (command)
          return [`{\\${command} ${s}}`, needsWrap];
        return [s, needsWrap];
      })
    );
  }
  function emitFontFamilyTextRun(run, options) {
    return join(
      getPropertyRuns(run, "fontFamily").map((x) => {
        var _a3, _b3;
        const [s, needsWrap] = emitSizeTextRun(x, options);
        const command = (_b3 = {
          "roman": "textrm",
          "monospace": "texttt",
          "sans-serif": "textsf"
        }[(_a3 = x[0].style.fontFamily) != null ? _a3 : ""]) != null ? _b3 : "";
        if (command)
          return [`\\${command}{${s}}`, false];
        if (x[0].style.fontFamily)
          return [`\\fontfamily{${x[0].style.fontFamily}}${s}`, needsWrap];
        return [s, needsWrap];
      })
    );
  }
  function emitStyledTextRun(run, options) {
    return emitFontFamilyTextRun(run, options);
  }
  function emitBackgroundColorRun2(run, options) {
    return join(
      getPropertyRuns(run, "backgroundColor").map((x) => {
        var _a3, _b3;
        const [s, needsWrap] = emitColorRun2(x, options);
        const style = x[0].computedStyle;
        if (!((_a3 = options.skipStyles) != null ? _a3 : false) && style.backgroundColor && style.backgroundColor !== "none") {
          return [
            `\\colorbox{${(_b3 = style.verbatimBackgroundColor) != null ? _b3 : style.backgroundColor}}{${s}}`,
            false
          ];
        }
        return [s, needsWrap];
      })
    );
  }
  function emitColorRun2(run, options) {
    var _a3;
    if (!run || run.length === 0)
      return ["", false];
    const parentColor = (_a3 = run[0].parent) == null ? void 0 : _a3.style.color;
    return join(
      getPropertyRuns(run, "color").map((x) => {
        var _a4, _b3;
        const [s, needsWrap] = emitStyledTextRun(x, options);
        if (!((_a4 = options.skipStyles) != null ? _a4 : false) && x[0].style.color && x[0].style.color !== "none" && parentColor !== x[0].style.color) {
          return [
            `\\textcolor{${(_b3 = x[0].style.verbatimColor) != null ? _b3 : x[0].style.color}}{${s}}`,
            false
          ];
        }
        return [s, needsWrap];
      })
    );
  }
  var TEXT_FONT_CLASS = {
    "roman": "",
    "sans-serif": "ML__sans",
    "monospace": "ML__tt"
  };
  var TextMode = class extends Mode {
    constructor() {
      super("text");
    }
    createAtom(command, context, style) {
      const info = context.getDefinition(command, "text");
      if (!info)
        return null;
      if (info.definitionType === "symbol") {
        return new TextAtom(
          command,
          String.fromCodePoint(info.codepoint),
          style != null ? style : {},
          context
        );
      }
      return null;
    }
    serialize(run, options) {
      var _a3;
      let [result, needWrapper] = emitBackgroundColorRun2(run, options);
      if (((_a3 = options.skipModeCommand) != null ? _a3 : false) === true)
        needWrapper = false;
      if (needWrapper)
        result = `\\text{${result}}`;
      return result;
    }
    /**
     * Return the font-family name
     */
    applyStyle(box, style) {
      var _a3, _b3, _c2, _d2, _e;
      const { fontFamily } = style;
      if (TEXT_FONT_CLASS[fontFamily])
        box.classes += " " + TEXT_FONT_CLASS[fontFamily];
      else if (fontFamily) {
        box.setStyle("font-family", fontFamily);
      }
      if (style.fontShape) {
        box.classes += " ";
        box.classes += (_a3 = {
          it: "ML__it",
          sl: "ML__shape_sl",
          // Slanted
          sc: "ML__shape_sc",
          // Small caps
          ol: "ML__shape_ol"
          // Outline
        }[style.fontShape]) != null ? _a3 : "";
      }
      if (style.fontSeries) {
        const m = style.fontSeries.match(/(.?[lbm])?(.?[cx])?/);
        if (m) {
          box.classes += " ";
          box.classes += (_c2 = {
            ul: "ML__series_ul",
            el: "ML__series_el",
            l: "ML__series_l",
            sl: "ML__series_sl",
            m: "",
            // Medium (default)
            sb: "ML__series_sb",
            b: "ML__bold",
            eb: "ML__series_eb",
            ub: "ML__series_ub"
          }[(_b3 = m[1]) != null ? _b3 : ""]) != null ? _c2 : "";
          box.classes += " ";
          box.classes += (_e = {
            uc: "ML__series_uc",
            ec: "ML__series_ec",
            c: "ML__series_c",
            sc: "ML__series_sc",
            n: "",
            // Normal (default)
            sx: "ML__series_sx",
            x: "ML__series_x",
            ex: "ML__series_ex",
            ux: "ML__series_ux"
          }[(_d2 = m[2]) != null ? _d2 : ""]) != null ? _e : "";
        }
      }
      return "Main-Regular";
    }
  };
  new TextMode();

  // src/core/modes-latex.ts
  var LatexMode = class extends Mode {
    constructor() {
      super("latex");
    }
    createAtom(command, context, _style) {
      return new LatexAtom(command, context);
    }
    serialize(run, _options) {
      return run.filter((x) => x instanceof LatexAtom && !x.isSuggestion).map((x) => x.value).join("");
    }
    applyStyle() {
      return null;
    }
  };
  new LatexMode();

  // src/common/hash-code.ts
  function hashCode(s) {
    let hash2 = 0;
    for (let i = 0; i < s.length; i++)
      hash2 = Math.imul(31, hash2) + s.charCodeAt(i) | 0;
    return Math.abs(hash2);
  }

  // src/common/stylesheet.ts
  function inject(element, css, id) {
    var _a3, _b3;
    if (!css)
      return null;
    let root = (_a3 = element == null ? void 0 : element.getRootNode()) != null ? _a3 : document == null ? void 0 : document.head;
    if (!root)
      return null;
    if (root === document)
      root = document.head;
    const element_ = root.querySelector(
      `style[data-id="${id}"]`
    );
    if (element_) {
      const refCount = Number.parseFloat(
        (_b3 = element_.getAttribute("data-refcount")) != null ? _b3 : "0"
      );
      element_.dataset.refcount = Number(refCount + 1).toString();
    } else {
      const styleNode = document.createElement("style");
      styleNode.dataset.id = id;
      styleNode.dataset.refcount = "1";
      styleNode.append(document.createTextNode(css));
      root.appendChild(styleNode);
    }
    return {
      release: () => {
        var _a4;
        const element_2 = root.querySelector(
          `style[data-id="${id}"]`
        );
        if (element_2) {
          const refCount = Number.parseFloat(
            (_a4 = element_2.getAttribute("data-refcount")) != null ? _a4 : "0"
          );
          if (refCount === 1)
            element_2.remove();
          else
            element_2.dataset.refcount = Number(refCount - 1).toString();
        }
      }
    };
  }

  // src/editor/keyboard-layout.ts
  function keystrokeModifiersFromString(key) {
    const segments = key.split("+");
    const result = {
      shift: false,
      alt: false,
      cmd: false,
      win: false,
      meta: false,
      ctrl: false,
      key: segments.pop()
    };
    if (segments.includes("shift"))
      result.shift = true;
    if (segments.includes("alt"))
      result.alt = true;
    if (segments.includes("ctrl"))
      result.ctrl = true;
    if (segments.includes("cmd"))
      result.cmd = true;
    if (segments.includes("win"))
      result.win = true;
    if (segments.includes("meta"))
      result.meta = true;
    return result;
  }
  function keystrokeModifiersToString(key) {
    let result = "";
    if (key.shift)
      result += "shift+";
    if (key.alt)
      result += "alt+";
    if (key.ctrl)
      result += "ctrl+";
    if (key.cmd)
      result += "cmd+";
    if (key.win)
      result += "win+";
    if (key.meta)
      result += "meta+";
    return result + key.key;
  }
  var DEFAULT_KEYBOARD_LAYOUT = platform() === "apple" ? {
    id: "apple.en-intl",
    displayName: "English (international)",
    virtualLayout: "qwerty",
    platform: "apple",
    locale: "en",
    score: 0,
    mapping: {
      KeyA: ["a", "A", "\xE5", "\xC5"],
      KeyB: ["b", "B", "\u222B", "\u0131"],
      KeyC: ["c", "C", "\xE7", "\xC7"],
      KeyD: ["d", "D", "\u2202", "\xCE"],
      KeyE: ["e", "E", "\xB4", "\xB4"],
      KeyF: ["f", "F", "\u0192", "\xCF"],
      KeyG: ["g", "G", "\xA9", "\u02DD"],
      KeyH: ["h", "H", "\u02D9", "\xD3"],
      KeyI: ["i", "I", "\u02C6", "\u02C6"],
      KeyJ: ["j", "J", "\u2206", "\xD4"],
      KeyK: ["k", "K", "\u02DA", "\uF8FF"],
      KeyL: ["l", "L", "\xAC", "\xD2"],
      KeyM: ["m", "M", "\xB5", "\xC2"],
      KeyN: ["n", "N", "\u02DC", "\u02DC"],
      KeyO: ["o", "O", "\xF8", "\xD8"],
      KeyP: ["p", "P", "\u03C0", "\u220F"],
      KeyQ: ["q", "Q", "\u0153", "\u0152"],
      KeyR: ["r", "R", "\xAE", "\u2030"],
      KeyS: ["s", "S", "\xDF", "\xCD"],
      KeyT: ["t", "T", "\u2020", "\u02C7"],
      KeyU: ["u", "U", "\xA8", "\xA8"],
      KeyV: ["v", "V", "\u221A", "\u25CA"],
      KeyW: ["w", "W", "\u2211", "\u201E"],
      KeyX: ["x", "X", "\u2248", "\u02DB"],
      KeyY: ["y", "Y", "\xA5", "\xC1"],
      KeyZ: ["z", "Z", "\u03A9", "\xB8"],
      Digit1: ["1", "!", "\xA1", "\u2044"],
      Digit2: ["2", "@", "\u2122", "\u20AC"],
      Digit3: ["3", "#", "\xA3", "\u2039"],
      Digit4: ["4", "$", "\xA2", "\u203A"],
      Digit5: ["5", "%", "\u221E", "\uFB01"],
      Digit6: ["6", "^", "\xA7", "\uFB02"],
      Digit7: ["7", "&", "\xB6", "\u2021"],
      Digit8: ["8", "*", "\u2022", "\xB0"],
      Digit9: ["9", "(", "\xAA", "\xB7"],
      Digit0: ["0", ")", "\xBA", "\u201A"],
      Space: [" ", " ", " ", " "],
      Minus: ["-", "_", "\u2013", "\u2014"],
      Equal: ["=", "+", "\u2260", "\xB1"],
      BracketLeft: ["[", "{", "\u201C", "\u201D"],
      BracketRight: ["]", "}", "\u2018", "\u2019"],
      Backslash: ["\\", "|", "\xAB", "\xBB"],
      Semicolon: [";", ":", "\u2026", "\xDA"],
      Quote: ["'", '"', "\xE6", "\xC6"],
      Backquote: ["`", "\u02DC", "`", "`"],
      Comma: [",", "<", "\u2264", "\xAF"],
      Period: [".", ">", "\u2265", "\u02D8"],
      Slash: ["/", "?", "\xF7", "\xBF"],
      NumpadDivide: ["/", "/", "/", "/"],
      NumpadMultiply: ["*", "*", "*", "*"],
      NumpadSubtract: ["-", "-", "-", "-"],
      NumpadAdd: ["+", "+", "+", "+"],
      Numpad1: ["1", "1", "1", "1"],
      Numpad2: ["2", "2", "2", "2"],
      Numpad3: ["3", "3", "3", "3"],
      Numpad4: ["4", "4", "4", "4"],
      Numpad5: ["5", "5", "5", "5"],
      Numpad6: ["6", "6", "6", "6"],
      Numpad7: ["7", "7", "7", "7"],
      Numpad8: ["8", "8", "8", "8"],
      Numpad9: ["9", "9", "9", "9"],
      Numpad0: ["0", "0", "0", "0"],
      NumpadDecimal: [".", ".", ".", "."],
      IntlBackslash: ["\xA7", "\xB1", "\xA7", "\xB1"],
      NumpadEqual: ["=", "=", "=", "="],
      AudioVolumeUp: ["", "=", "", "="]
    }
  } : platform() === "windows" ? {
    id: "windows.en-intl",
    displayName: "English (international)",
    platform: "windows",
    virtualLayout: "qwerty",
    locale: "en",
    score: 0,
    mapping: {
      KeyA: ["a", "A", "\xE1", "\xC1"],
      KeyB: ["b", "B", "", ""],
      KeyC: ["c", "C", "\xA9", "\xA2"],
      KeyD: ["d", "D", "\xF0", "\xD0"],
      KeyE: ["e", "E", "\xE9", "\xC9"],
      KeyF: ["f", "F", "", ""],
      KeyG: ["g", "G", "", ""],
      KeyH: ["h", "H", "", ""],
      KeyI: ["i", "I", "\xED", "\xCD"],
      KeyJ: ["j", "J", "", ""],
      KeyK: ["k", "K", "", ""],
      KeyL: ["l", "L", "\xF8", "\xD8"],
      KeyM: ["m", "M", "\xB5", ""],
      KeyN: ["n", "N", "\xF1", "\xD1"],
      KeyO: ["o", "O", "\xF3", "\xD3"],
      KeyP: ["p", "P", "\xF6", "\xD6"],
      KeyQ: ["q", "Q", "\xE4", "\xC4"],
      KeyR: ["r", "R", "\xAE", ""],
      KeyS: ["s", "S", "\xDF", "\xA7"],
      KeyT: ["t", "T", "\xFE", "\xDE"],
      KeyU: ["u", "U", "\xFA", "\xDA"],
      KeyV: ["v", "V", "", ""],
      KeyW: ["w", "W", "\xE5", "\xC5"],
      KeyX: ["x", "X", "", ""],
      KeyY: ["y", "Y", "\xFC", "\xDC"],
      KeyZ: ["z", "Z", "\xE6", "\xC6"],
      Digit1: ["1", "!", "\xA1", "\xB9"],
      Digit2: ["2", "@", "\xB2", ""],
      Digit3: ["3", "#", "\xB3", ""],
      Digit4: ["4", "$", "\xA4", "\xA3"],
      Digit5: ["5", "%", "\u20AC", ""],
      Digit6: ["6", "^", "\xBC", ""],
      Digit7: ["7", "&", "\xBD", ""],
      Digit8: ["8", "*", "\xBE", ""],
      Digit9: ["9", "(", "\u2018", ""],
      Digit0: ["0", ")", "\u2019", ""],
      Space: [" ", " ", "", ""],
      Minus: ["-", "_", "\xA5", ""],
      Equal: ["=", "+", "\xD7", "\xF7"],
      BracketLeft: ["[", "{", "\xAB", ""],
      BracketRight: ["]", "}", "\xBB", ""],
      Backslash: ["\\", "|", "\xAC", "\xA6"],
      Semicolon: [";", ":", "\xB6", "\xB0"],
      Quote: ["'", '"', "\xB4", "\xA8"],
      Backquote: ["`", "~", "", ""],
      Comma: [",", "<", "\xE7", "\xC7"],
      Period: [".", ">", "", ""],
      Slash: ["/", "?", "\xBF", ""],
      NumpadDivide: ["/", "/", "", ""],
      NumpadMultiply: ["*", "*", "", ""],
      NumpadSubtract: ["-", "-", "", ""],
      NumpadAdd: ["+", "+", "", ""],
      IntlBackslash: ["\\", "|", "", ""]
    }
  } : {
    id: "linux.en",
    displayName: "English",
    platform: "linux",
    virtualLayout: "qwerty",
    locale: "en",
    score: 0,
    mapping: {
      KeyA: ["a", "A", "a", "A"],
      KeyB: ["b", "B", "b", "B"],
      KeyC: ["c", "C", "c", "C"],
      KeyD: ["d", "D", "d", "D"],
      KeyE: ["e", "E", "e", "E"],
      KeyF: ["f", "F", "f", "F"],
      KeyG: ["g", "G", "g", "G"],
      KeyH: ["h", "H", "h", "H"],
      KeyI: ["i", "I", "i", "I"],
      KeyJ: ["j", "J", "j", "J"],
      KeyK: ["k", "K", "k", "K"],
      KeyL: ["l", "L", "l", "L"],
      KeyM: ["m", "M", "m", "M"],
      KeyN: ["n", "N", "n", "N"],
      KeyO: ["o", "O", "o", "O"],
      KeyP: ["p", "P", "p", "P"],
      KeyQ: ["q", "Q", "q", "Q"],
      KeyR: ["r", "R", "r", "R"],
      KeyS: ["s", "S", "s", "S"],
      KeyT: ["t", "T", "t", "T"],
      KeyU: ["u", "U", "u", "U"],
      KeyV: ["v", "V", "v", "V"],
      KeyW: ["w", "W", "w", "W"],
      KeyX: ["x", "X", "x", "X"],
      KeyY: ["y", "Y", "y", "Y"],
      KeyZ: ["z", "Z", "z", "Z"],
      Digit1: ["1", "!", "1", "!"],
      Digit2: ["2", "@", "2", "@"],
      Digit3: ["3", "#", "3", "#"],
      Digit4: ["4", "$", "4", "$"],
      Digit5: ["5", "%", "5", "%"],
      Digit6: ["6", "^", "6", "^"],
      Digit7: ["7", "&", "7", "&"],
      Digit8: ["8", "*", "8", "*"],
      Digit9: ["9", "(", "9", "("],
      Digit0: ["0", ")", "0", ")"],
      Space: [" ", " ", " ", " "],
      Minus: ["-", "_", "-", "_"],
      Equal: ["=", "+", "=", "+"],
      BracketLeft: ["[", "{", "[", "{"],
      BracketRight: ["]", "}", "]", "}"],
      Backslash: ["\\", "|", "\\", "|"],
      Semicolon: [";", ":", ";", ":"],
      Quote: ["'", '"', "'", '"'],
      Backquote: ["`", "~", "`", "~"],
      Comma: [",", "<", ",", "<"],
      Period: [".", ">", ".", ">"],
      Slash: ["/", "?", "/", "?"],
      NumpadDivide: ["/", "/", "/", "/"],
      NumpadMultiply: ["*", "*", "*", "*"],
      NumpadSubtract: ["-", "-", "-", "-"],
      NumpadAdd: ["+", "+", "+", "+"],
      Numpad1: ["1", "1", "1", "1"],
      Numpad2: ["2", "2", "2", "2"],
      Numpad3: ["3", "3", "3", "3"],
      Numpad4: ["4", "4", "4", "4"],
      Numpad5: ["5", "5", "5", "5"],
      Numpad6: ["6", "6", "6", "6"],
      Numpad7: ["7", "7", "7", "7"],
      Numpad8: ["8", "8", "8", "8"],
      Numpad9: ["9", "9", "9", "9"],
      Numpad0: ["0", "0", "0", "0"],
      NumpadDecimal: ["", ".", "", "."],
      IntlBackslash: ["<", ">", "|", "\xA6"],
      NumpadEqual: ["=", "=", "=", "="],
      NumpadComma: [".", ".", ".", "."],
      NumpadParenLeft: ["(", "(", "(", "("],
      NumpadParenRight: [")", ")", ")", ")"]
    }
  };
  var BASE_LAYOUT_MAPPING = {
    enter: "[Enter]",
    escape: "[Escape]",
    backspace: "[Backspace]",
    tab: "[Tab]",
    space: "[Space]",
    pausebreak: "[Pause]",
    insert: "[Insert]",
    home: "[Home]",
    pageup: "[PageUp]",
    delete: "[Delete]",
    end: "[End]",
    pagedown: "[PageDown]",
    right: "[ArrowRight]",
    left: "[ArrowLeft]",
    down: "[ArrowDown]",
    up: "[ArrowUp]",
    numpad0: "[Numpad0]",
    numpad1: "[Numpad1]",
    numpad2: "[Numpad2]",
    numpad3: "[Numpad3]",
    numpad4: "[Numpad4]",
    numpad5: "[Numpad5]",
    numpad6: "[Numpad6]",
    numpad7: "[Numpad7]",
    numpad8: "[Numpad8]",
    numpad9: "[Numpad9]",
    "numpad_divide": "[NumpadDivide]",
    "numpad_multiply": "[NumpadMultiply]",
    "numpad_subtract": "[NumpadSubtract]",
    "numpad_add": "[NumpadAdd]",
    "numpad_decimal": "[NumpadDecimal]",
    "numpad_separator": "[NumpadComma]",
    capslock: "[Capslock]",
    f1: "[F1]",
    f2: "[F2]",
    f3: "[F3]",
    f4: "[F4]",
    f5: "[F5]",
    f6: "[F6]",
    f7: "[F7]",
    f8: "[F8]",
    f9: "[F9]",
    f10: "[F10]",
    f11: "[F11]",
    f12: "[F12]",
    f13: "[F13]",
    f14: "[F14]",
    f15: "[F15]",
    f16: "[F16]",
    f17: "[F17]",
    f18: "[F18]",
    f19: "[F19]"
  };
  var gKeyboardLayouts = [];
  var gKeyboardLayout;
  function platform() {
    switch (osPlatform()) {
      case "macos":
      case "ios":
        return "apple";
      case "windows":
        return "windows";
    }
    return "linux";
  }
  function register(layout) {
    if (!layout.platform || layout.platform === platform())
      gKeyboardLayouts.push(layout);
  }
  function getCodeForKey(k, layout) {
    var _a3;
    const result = {
      shift: false,
      alt: false,
      cmd: false,
      win: false,
      meta: false,
      ctrl: false,
      key: ""
    };
    if (!k)
      return result;
    for (const [key, value] of Object.entries(layout.mapping)) {
      if (value[0] === k) {
        result.key = `[${key}]`;
        return result;
      }
      if (value[1] === k) {
        result.shift = true;
        result.key = `[${key}]`;
        return result;
      }
      if (value[2] === k) {
        result.alt = true;
        result.key = `[${key}]`;
        return result;
      }
      if (value[3] === k) {
        result.shift = true;
        result.alt = true;
        result.key = `[${key}]`;
        return result;
      }
    }
    result.key = (_a3 = BASE_LAYOUT_MAPPING[k]) != null ? _a3 : "";
    return result;
  }
  function normalizeKeyboardEvent(evt) {
    if (evt.code)
      return evt;
    const mapping = Object.entries(getActiveKeyboardLayout().mapping);
    let altKey = false;
    let shiftKey = false;
    let code = "";
    for (let index = 0; index < 4; index++) {
      for (const [key, value] of mapping) {
        if (value[index] === evt.key) {
          code = key;
          if (index === 3) {
            altKey = true;
            shiftKey = true;
          } else if (index === 2)
            altKey = true;
          else if (index === 1)
            shiftKey = true;
          break;
        }
      }
      if (code)
        break;
    }
    return new KeyboardEvent(evt.type, __spreadProps(__spreadValues({}, evt), { altKey, shiftKey, code }));
  }
  function validateKeyboardLayout(evt) {
    var _a3, _b3;
    if (!evt)
      return;
    if (evt.key === "Unidentified")
      return;
    if (evt.key === "Dead")
      return;
    const index = evt.shiftKey && evt.altKey ? 3 : evt.altKey ? 2 : evt.shiftKey ? 1 : 0;
    for (const layout of gKeyboardLayouts) {
      if (((_a3 = layout.mapping[evt.code]) == null ? void 0 : _a3[index]) === evt.key) {
        layout.score += 1;
      } else if ((_b3 = layout.mapping[evt.code]) == null ? void 0 : _b3[index]) {
        layout.score = 0;
      }
    }
    gKeyboardLayouts.sort((a, b) => b.score - a.score);
  }
  function setKeyboardLayoutLocale(locale) {
    gKeyboardLayout = gKeyboardLayouts.find((x) => locale.startsWith(x.locale));
  }
  function getActiveKeyboardLayout() {
    return gKeyboardLayout != null ? gKeyboardLayout : gKeyboardLayouts[0];
  }
  register(DEFAULT_KEYBOARD_LAYOUT);
  register({
    id: "apple.french",
    locale: "fr",
    displayName: "French",
    platform: "apple",
    virtualLayout: "azerty",
    score: 0,
    mapping: {
      KeyA: ["q", "Q", "\u2021", "\u03A9"],
      KeyB: ["b", "B", "\xDF", "\u222B"],
      KeyC: ["c", "C", "\xA9", "\xA2"],
      KeyD: ["d", "D", "\u2202", "\u2206"],
      KeyE: ["e", "E", "\xEA", "\xCA"],
      KeyF: ["f", "F", "\u0192", "\xB7"],
      KeyG: ["g", "G", "\uFB01", "\uFB02"],
      KeyH: ["h", "H", "\xCC", "\xCE"],
      KeyI: ["i", "I", "\xEE", "\xEF"],
      KeyJ: ["j", "J", "\xCF", "\xCD"],
      KeyK: ["k", "K", "\xC8", "\xCB"],
      KeyL: ["l", "L", "\xAC", "|"],
      KeyM: [",", "?", "\u221E", "\xBF"],
      KeyN: ["n", "N", "~", "\u0131"],
      KeyO: ["o", "O", "\u0153", "\u0152"],
      KeyP: ["p", "P", "\u03C0", "\u220F"],
      KeyQ: ["a", "A", "\xE6", "\xC6"],
      KeyR: ["r", "R", "\xAE", "\u201A"],
      KeyS: ["s", "S", "\xD2", "\u2211"],
      KeyT: ["t", "T", "\u2020", "\u2122"],
      KeyU: ["u", "U", "\xBA", "\xAA"],
      KeyV: ["v", "V", "\u25CA", "\u221A"],
      KeyW: ["z", "Z", "\xC2", "\xC5"],
      KeyX: ["x", "X", "\u2248", "\u2044"],
      KeyY: ["y", "Y", "\xDA", "\u0178"],
      KeyZ: ["w", "W", "\u2039", "\u203A"],
      Digit1: ["&", "1", "\uF8FF", "\xB4"],
      Digit2: ["\xE9", "2", "\xEB", "\u201E"],
      Digit3: ['"', "3", "\u201C", "\u201D"],
      Digit4: ["'", "4", "\u2018", "\u2019"],
      Digit5: ["(", "5", "{", "["],
      Digit6: ["\xA7", "6", "\xB6", "\xE5"],
      Digit7: ["\xE8", "7", "\xAB", "\xBB"],
      Digit8: ["!", "8", "\xA1", "\xDB"],
      Digit9: ["\xE7", "9", "\xC7", "\xC1"],
      Digit0: ["\xE0", "0", "\xF8", "\xD8"],
      Space: [" ", " ", " ", " "],
      Minus: [")", "\xB0", "}", "]"],
      Equal: ["-", "_", "\u2014", "\u2013"],
      BracketLeft: ["^", "\xA8", "\xF4", "\xD4"],
      BracketRight: ["$", "*", "\u20AC", "\xA5"],
      Backslash: ["`", "\xA3", "@", "#"],
      Semicolon: ["m", "M", "\xB5", "\xD3"],
      Quote: ["\xF9", "%", "\xD9", "\u2030"],
      Backquote: ["<", ">", "\u2264", "\u2265"],
      Comma: [";", ".", "\u2026", "\u2022"],
      Period: [":", "/", "\xF7", "\\"],
      Slash: ["=", "+", "\u2260", "\xB1"],
      NumpadDivide: ["/", "/", "/", "/"],
      NumpadMultiply: ["*", "*", "*", "*"],
      NumpadSubtract: ["-", "-", "-", "-"],
      NumpadAdd: ["+", "+", "+", "+"],
      NumpadDecimal: [",", ".", ",", "."],
      IntlBackslash: ["@", "#", "\u2022", "\u0178"],
      NumpadEqual: ["=", "=", "=", "="]
    }
  });
  register({
    id: "apple.spanish",
    locale: "es",
    displayName: "Spanish ISO",
    platform: "apple",
    virtualLayout: "qwerty",
    score: 0,
    mapping: {
      KeyA: ["a", "A", "\xE5", "\xC5"],
      KeyB: ["b", "B", "\xDF", ""],
      KeyC: ["c", "C", "\xA9", " "],
      KeyD: ["d", "D", "\u2202", "\u2206"],
      KeyE: ["e", "E", "\u20AC", "\u20AC"],
      KeyF: ["f", "F", "\u0192", "\uFB01"],
      KeyG: ["g", "G", "\uF8FF", "\uFB02"],
      KeyH: ["h", "H", "\u2122", " "],
      KeyI: ["i", "I", " ", " "],
      KeyJ: ["j", "J", "\xB6", "\xAF"],
      KeyK: ["k", "K", "\xA7", "\u02C7"],
      KeyL: ["l", "L", " ", "\u02D8"],
      KeyM: ["m", "M", "\xB5", "\u02DA"],
      KeyN: ["n", "N", " ", "\u02D9"],
      KeyO: ["o", "O", "\xF8", "\xD8"],
      KeyP: ["p", "P", "\u03C0", "\u220F"],
      KeyQ: ["q", "Q", "\u0153", "\u0152"],
      KeyR: ["r", "R", "\xAE", " "],
      KeyS: ["s", "S", "\u222B", " "],
      KeyT: ["t", "T", "\u2020", "\u2021"],
      KeyU: ["u", "U", " ", " "],
      KeyV: ["v", "V", "\u221A", "\u25CA"],
      KeyW: ["w", "W", "\xE6", "\xC6"],
      KeyX: ["x", "X", "\u2211", "\u203A"],
      KeyY: ["y", "Y", "\xA5", " "],
      KeyZ: ["z", "Z", "\u03A9", "\u2039"],
      Digit1: ["1", "!", "|", "\u0131"],
      Digit2: ["2", '"', "@", "\u02DD"],
      Digit3: ["3", "\xB7", "#", "\u2022"],
      Digit4: ["4", "$", "\xA2", "\xA3"],
      Digit5: ["5", "%", "\u221E", "\u2030"],
      Digit6: ["6", "&", "\xAC", " "],
      Digit7: ["7", "/", "\xF7", "\u2044"],
      Digit8: ["8", "(", "\u201C", "\u2018"],
      Digit9: ["9", ")", "\u201D", "\u2019"],
      Digit0: ["0", "=", "\u2260", "\u2248"],
      Space: [" ", " ", " ", " "],
      Minus: ["'", "?", "\xB4", "\xB8"],
      Equal: ["\xA1", "\xBF", "\u201A", "\u02DB"],
      BracketLeft: ["`", "^", "[", "\u02C6"],
      BracketRight: ["+", "*", "]", "\xB1"],
      Backslash: ["\xE7", "\xC7", "}", "\xBB"],
      Semicolon: ["\xF1", "\xD1", "~", "\u02DC"],
      Quote: ["\xB4", "\xA8", "{", "\xAB"],
      Backquote: ["<", ">", "\u2264", "\u2265"],
      Comma: [",", ";", "\u201E", ""],
      Period: [".", ":", "\u2026", "\u2026"],
      Slash: ["-", "_", "\u2013", "\u2014"],
      NumpadDivide: ["/", "/", "/", "/"],
      NumpadMultiply: ["*", "*", "*", "*"],
      NumpadSubtract: ["-", "-", "-", "-"],
      NumpadAdd: ["+", "+", "+", "+"],
      Numpad1: ["1", "1", "1", "1"],
      Numpad2: ["2", "2", "2", "2"],
      Numpad3: ["3", "3", "3", "3"],
      Numpad4: ["4", "4", "4", "4"],
      Numpad5: ["5", "5", "5", "5"],
      Numpad6: ["6", "6", "6", "6"],
      Numpad7: ["7", "7", "7", "7"],
      Numpad8: ["8", "8", "8", "8"],
      Numpad9: ["9", "9", "9", "9"],
      Numpad0: ["0", "0", "0", "0"],
      NumpadDecimal: [",", ",", ",", ","],
      IntlBackslash: ["\xBA", "\xAA", "\\", "\xB0"]
    }
  });
  register({
    id: "windows.spanish",
    locale: "es",
    displayName: "Spanish",
    platform: "windows",
    virtualLayout: "qwerty",
    score: 0,
    mapping: {
      KeyA: ["a", "A", "", ""],
      KeyB: ["b", "B", "", ""],
      KeyC: ["c", "C", "", ""],
      KeyD: ["d", "D", "", ""],
      KeyE: ["e", "E", "\u20AC", ""],
      KeyF: ["f", "F", "", ""],
      KeyG: ["g", "G", "", ""],
      KeyH: ["h", "H", "", ""],
      KeyI: ["i", "I", "", ""],
      KeyJ: ["j", "J", "", ""],
      KeyK: ["k", "K", "", ""],
      KeyL: ["l", "L", "", ""],
      KeyM: ["m", "M", "", ""],
      KeyN: ["n", "N", "", ""],
      KeyO: ["o", "O", "", ""],
      KeyP: ["p", "P", "", ""],
      KeyQ: ["q", "Q", "", ""],
      KeyR: ["r", "R", "", ""],
      KeyS: ["s", "S", "", ""],
      KeyT: ["t", "T", "", ""],
      KeyU: ["u", "U", "", ""],
      KeyV: ["v", "V", "", ""],
      KeyW: ["w", "W", "", ""],
      KeyX: ["x", "X", "", ""],
      KeyY: ["y", "Y", "", ""],
      KeyZ: ["z", "Z", "", ""],
      Digit1: ["1", "!", "|", ""],
      Digit2: ["2", '"', "@", ""],
      Digit3: ["3", "\xB7", "#", ""],
      Digit4: ["4", "$", "~", ""],
      Digit5: ["5", "%", "\u20AC", ""],
      Digit6: ["6", "&", "\xAC", ""],
      Digit7: ["7", "/", "", ""],
      Digit8: ["8", "(", "", ""],
      Digit9: ["9", ")", "", ""],
      Digit0: ["0", "=", "", ""],
      Space: [" ", " ", "", ""],
      Minus: ["'", "?", "", ""],
      Equal: ["\xA1", "\xBF", "", ""],
      BracketLeft: ["`", "^", "[", ""],
      BracketRight: ["+", "*", "]", ""],
      Backslash: ["\xE7", "\xC7", "}", ""],
      Semicolon: ["\xF1", "\xD1", "", ""],
      Quote: ["\xB4", "\xA8", "{", ""],
      Backquote: ["\xBA", "\xAA", "\\", ""],
      Comma: [",", ";", "", ""],
      Period: [".", ":", "", ""],
      Slash: ["-", "_", "", ""],
      NumpadDivide: ["/", "/", "", ""],
      NumpadMultiply: ["*", "*", "", ""],
      NumpadSubtract: ["-", "-", "", ""],
      NumpadAdd: ["+", "+", "", ""],
      IntlBackslash: ["<", ">", "", ""]
    }
  });
  register({
    id: "linux.spanish",
    locale: "es",
    displayName: "Spanish",
    platform: "linux",
    virtualLayout: "qwerty",
    score: 0,
    mapping: {
      KeyA: ["a", "A", "\xE6", "\xC6"],
      KeyB: ["b", "B", "\u201D", "\u2019"],
      KeyC: ["c", "C", "\xA2", "\xA9"],
      KeyD: ["d", "D", "\xF0", "\xD0"],
      KeyE: ["e", "E", "\u20AC", "\xA2"],
      KeyF: ["f", "F", "\u0111", "\xAA"],
      KeyG: ["g", "G", "\u014B", "\u014A"],
      KeyH: ["h", "H", "\u0127", "\u0126"],
      KeyI: ["i", "I", "\u2192", "\u0131"],
      KeyJ: ["j", "J", "\u0309", "\u031B"],
      KeyK: ["k", "K", "\u0138", "&"],
      KeyL: ["l", "L", "\u0142", "\u0141"],
      KeyM: ["m", "M", "\xB5", "\xBA"],
      KeyN: ["n", "N", "n", "N"],
      KeyO: ["o", "O", "\xF8", "\xD8"],
      KeyP: ["p", "P", "\xFE", "\xDE"],
      KeyQ: ["q", "Q", "@", "\u03A9"],
      KeyR: ["r", "R", "\xB6", "\xAE"],
      KeyS: ["s", "S", "\xDF", "\xA7"],
      KeyT: ["t", "T", "\u0167", "\u0166"],
      KeyU: ["u", "U", "\u2193", "\u2191"],
      KeyV: ["v", "V", "\u201C", "\u2018"],
      KeyW: ["w", "W", "\u0142", "\u0141"],
      KeyX: ["x", "X", "\xBB", ">"],
      KeyY: ["y", "Y", "\u2190", "\xA5"],
      KeyZ: ["z", "Z", "\xAB", "<"],
      Digit1: ["1", "!", "|", "\xA1"],
      Digit2: ["2", '"', "@", "\u215B"],
      Digit3: ["3", "\xB7", "#", "\xA3"],
      Digit4: ["4", "$", "~", "$"],
      Digit5: ["5", "%", "\xBD", "\u215C"],
      Digit6: ["6", "&", "\xAC", "\u215D"],
      Digit7: ["7", "/", "{", "\u215E"],
      Digit8: ["8", "(", "[", "\u2122"],
      Digit9: ["9", ")", "]", "\xB1"],
      Digit0: ["0", "=", "}", "\xB0"],
      Enter: ["\r", "\r", "\r", "\r"],
      Escape: ["\x1B", "\x1B", "\x1B", "\x1B"],
      Backspace: ["\b", "\b", "\b", "\b"],
      Tab: ["	", "", "	", ""],
      Space: [" ", " ", " ", " "],
      Minus: ["'", "?", "\\", "\xBF"],
      Equal: ["\xA1", "\xBF", "\u0303", "~"],
      BracketLeft: ["\u0300", "\u0302", "[", "\u030A"],
      BracketRight: ["+", "*", "]", "\u0304"],
      Backslash: ["\xE7", "\xC7", "}", "\u0306"],
      Semicolon: ["\xF1", "\xD1", "~", "\u030B"],
      Quote: ["\u0301", "\u0308", "{", "{"],
      Backquote: ["\xBA", "\xAA", "\\", "\\"],
      Comma: [",", ";", "\u2500", "\xD7"],
      Period: [".", ":", "\xB7", "\xF7"],
      Slash: ["-", "_", "\u0323", "\u0307"],
      NumpadDivide: ["/", "/", "/", "/"],
      NumpadMultiply: ["*", "*", "*", "*"],
      NumpadSubtract: ["-", "-", "-", "-"],
      NumpadAdd: ["+", "+", "+", "+"],
      NumpadEnter: ["\r", "\r", "\r", "\r"],
      Numpad1: ["", "1", "", "1"],
      Numpad2: ["", "2", "", "2"],
      Numpad3: ["", "3", "", "3"],
      Numpad4: ["", "4", "", "4"],
      Numpad5: ["", "5", "", "5"],
      Numpad6: ["", "6", "", "6"],
      Numpad7: ["", "7", "", "7"],
      Numpad8: ["", "8", "", "8"],
      Numpad9: ["", "9", "", "9"],
      Numpad0: ["", "0", "", "0"],
      NumpadDecimal: ["", ".", "", "."],
      IntlBackslash: ["<", ">", "|", "\xA6"],
      NumpadEqual: ["=", "=", "=", "="],
      NumpadComma: [".", ".", ".", "."],
      NumpadParenLeft: ["(", "(", "(", "("],
      NumpadParenRight: [")", ")", ")", ")"]
    }
  });
  register({
    id: "linux.french",
    locale: "fr",
    displayName: "French",
    virtualLayout: "azerty",
    platform: "linux",
    score: 0,
    mapping: {
      KeyA: ["q", "Q", "@", "\u03A9"],
      KeyB: ["b", "B", "\u201D", "\u2019"],
      KeyC: ["c", "C", "\xA2", "\xA9"],
      KeyD: ["d", "D", "\xF0", "\xD0"],
      KeyE: ["e", "E", "\u20AC", "\xA2"],
      KeyF: ["f", "F", "\u0111", "\xAA"],
      KeyG: ["g", "G", "\u014B", "\u014A"],
      KeyH: ["h", "H", "\u0127", "\u0126"],
      KeyI: ["i", "I", "\u2192", "\u0131"],
      KeyJ: ["j", "J", "\u0309", "\u031B"],
      KeyK: ["k", "K", "\u0138", "&"],
      KeyL: ["l", "L", "\u0142", "\u0141"],
      KeyM: [",", "?", "\u0301", "\u030B"],
      KeyN: ["n", "N", "n", "N"],
      KeyO: ["o", "O", "\xF8", "\xD8"],
      KeyP: ["p", "P", "\xFE", "\xDE"],
      KeyQ: ["a", "A", "\xE6", "\xC6"],
      KeyR: ["r", "R", "\xB6", "\xAE"],
      KeyS: ["s", "S", "\xDF", "\xA7"],
      KeyT: ["t", "T", "\u0167", "\u0166"],
      KeyU: ["u", "U", "\u2193", "\u2191"],
      KeyV: ["v", "V", "\u201C", "\u2018"],
      KeyW: ["z", "Z", "\xAB", "<"],
      KeyX: ["x", "X", "\xBB", ">"],
      KeyY: ["y", "Y", "\u2190", "\xA5"],
      KeyZ: ["w", "W", "\u0142", "\u0141"],
      Digit1: ["&", "1", "\xB9", "\xA1"],
      Digit2: ["\xE9", "2", "~", "\u215B"],
      Digit3: ['"', "3", "#", "\xA3"],
      Digit4: ["'", "4", "{", "$"],
      Digit5: ["(", "5", "[", "\u215C"],
      Digit6: ["-", "6", "|", "\u215D"],
      Digit7: ["\xE8", "7", "`", "\u215E"],
      Digit8: ["_", "8", "\\", "\u2122"],
      Digit9: ["\xE7", "9", "^", "\xB1"],
      Digit0: ["\xE0", "0", "@", "\xB0"],
      Enter: ["\r", "\r", "\r", "\r"],
      Escape: ["\x1B", "\x1B", "\x1B", "\x1B"],
      Backspace: ["\b", "\b", "\b", "\b"],
      Tab: ["	", "", "	", ""],
      Space: [" ", " ", " ", " "],
      Minus: [")", "\xB0", "]", "\xBF"],
      Equal: ["=", "+", "}", "\u0328"],
      BracketLeft: ["\u0302", "\u0308", "\u0308", "\u030A"],
      BracketRight: ["$", "\xA3", "\xA4", "\u0304"],
      Backslash: ["*", "\xB5", "\u0300", "\u0306"],
      Semicolon: ["m", "M", "\xB5", "\xBA"],
      Quote: ["\xF9", "%", "\u0302", "\u030C"],
      Backquote: ["\xB2", "~", "\xAC", "\xAC"],
      Comma: [";", ".", "\u2500", "\xD7"],
      Period: [":", "/", "\xB7", "\xF7"],
      Slash: ["!", "\xA7", "\u0323", "\u0307"],
      NumpadMultiply: ["*", "*", "*", "*"],
      NumpadSubtract: ["-", "-", "-", "-"],
      NumpadAdd: ["+", "+", "+", "+"],
      NumpadDecimal: ["", ".", "", "."],
      IntlBackslash: ["<", ">", "|", "\xA6"]
    }
  });
  register({
    id: "windows.french",
    locale: "fr",
    displayName: "French",
    virtualLayout: "azerty",
    platform: "windows",
    score: 0,
    mapping: {
      KeyA: ["q", "Q", "", ""],
      KeyB: ["b", "B", "", ""],
      KeyC: ["c", "C", "", ""],
      KeyD: ["d", "D", "", ""],
      KeyE: ["e", "E", "\u20AC", ""],
      KeyF: ["f", "F", "", ""],
      KeyG: ["g", "G", "", ""],
      KeyH: ["h", "H", "", ""],
      KeyI: ["i", "I", "", ""],
      KeyJ: ["j", "J", "", ""],
      KeyK: ["k", "K", "", ""],
      KeyL: ["l", "L", "", ""],
      KeyM: [",", "?", "", ""],
      KeyN: ["n", "N", "", ""],
      KeyO: ["o", "O", "", ""],
      KeyP: ["p", "P", "", ""],
      KeyQ: ["a", "A", "", ""],
      KeyR: ["r", "R", "", ""],
      KeyS: ["s", "S", "", ""],
      KeyT: ["t", "T", "", ""],
      KeyU: ["u", "U", "", ""],
      KeyV: ["v", "V", "", ""],
      KeyW: ["z", "Z", "", ""],
      KeyX: ["x", "X", "", ""],
      KeyY: ["y", "Y", "", ""],
      KeyZ: ["w", "W", "", ""],
      Digit1: ["&", "1", "", ""],
      Digit2: ["\xE9", "2", "~", ""],
      Digit3: ['"', "3", "#", ""],
      Digit4: ["'", "4", "{", ""],
      Digit5: ["(", "5", "[", ""],
      Digit6: ["-", "6", "|", ""],
      Digit7: ["\xE8", "7", "`", ""],
      Digit8: ["_", "8", "\\", ""],
      Digit9: ["\xE7", "9", "^", ""],
      Digit0: ["\xE0", "0", "@", ""],
      Space: [" ", " ", "", ""],
      Minus: [")", "\xB0", "]", ""],
      Equal: ["=", "+", "}", ""],
      BracketLeft: ["^", "\xA8", "", ""],
      BracketRight: ["$", "\xA3", "\xA4", ""],
      Backslash: ["*", "\xB5", "", ""],
      Semicolon: ["m", "M", "", ""],
      Quote: ["\xF9", "%", "", ""],
      Backquote: ["\xB2", "", "", ""],
      Comma: [";", ".", "", ""],
      Period: [":", "/", "", ""],
      Slash: ["!", "\xA7", "", ""],
      NumpadDivide: ["/", "/", "", ""],
      NumpadMultiply: ["*", "*", "", ""],
      NumpadSubtract: ["-", "-", "", ""],
      NumpadAdd: ["+", "+", "", ""],
      IntlBackslash: ["<", ">", "", ""]
    }
  });
  register({
    id: "windows.german",
    locale: "de",
    displayName: "German",
    platform: "windows",
    virtualLayout: "qwertz",
    score: 0,
    mapping: {
      KeyA: ["a", "A", "", ""],
      KeyB: ["b", "B", "", ""],
      KeyC: ["c", "C", "", ""],
      KeyD: ["d", "D", "", ""],
      KeyE: ["e", "E", "\u20AC", ""],
      KeyF: ["f", "F", "", ""],
      KeyG: ["g", "G", "", ""],
      KeyH: ["h", "H", "", ""],
      KeyI: ["i", "I", "", ""],
      KeyJ: ["j", "J", "", ""],
      KeyK: ["k", "K", "", ""],
      KeyL: ["l", "L", "", ""],
      KeyM: ["m", "M", "\xB5", ""],
      KeyN: ["n", "N", "", ""],
      KeyO: ["o", "O", "", ""],
      KeyP: ["p", "P", "", ""],
      KeyQ: ["q", "Q", "@", ""],
      KeyR: ["r", "R", "", ""],
      KeyS: ["s", "S", "", ""],
      KeyT: ["t", "T", "", ""],
      KeyU: ["u", "U", "", ""],
      KeyV: ["v", "V", "", ""],
      KeyW: ["w", "W", "", ""],
      KeyX: ["x", "X", "", ""],
      KeyY: ["z", "Z", "", ""],
      KeyZ: ["y", "Y", "", ""],
      Digit1: ["1", "!", "", ""],
      Digit2: ["2", '"', "\xB2", ""],
      Digit3: ["3", "\xA7", "\xB3", ""],
      Digit4: ["4", "$", "", ""],
      Digit5: ["5", "%", "", ""],
      Digit6: ["6", "&", "", ""],
      Digit7: ["7", "/", "{", ""],
      Digit8: ["8", "(", "[", ""],
      Digit9: ["9", ")", "]", ""],
      Digit0: ["0", "=", "}", ""],
      Space: [" ", " ", "", ""],
      Minus: ["\xDF", "?", "\\", "\u1E9E"],
      Equal: ["\xB4", "`", "", ""],
      BracketLeft: ["\xFC", "\xDC", "", ""],
      BracketRight: ["+", "*", "~", ""],
      Backslash: ["#", "'", "", ""],
      Semicolon: ["\xF6", "\xD6", "", ""],
      Quote: ["\xE4", "\xC4", "", ""],
      Backquote: ["^", "\xB0", "", ""],
      Comma: [",", ";", "", ""],
      Period: [".", ":", "", ""],
      Slash: ["-", "_", "", ""],
      NumpadDivide: ["/", "/", "", ""],
      NumpadMultiply: ["*", "*", "", ""],
      NumpadSubtract: ["-", "-", "", ""],
      NumpadAdd: ["+", "+", "", ""],
      IntlBackslash: ["<", ">", "|", ""]
    }
  });
  register({
    id: "apple.german",
    locale: "de",
    displayName: "German",
    virtualLayout: "qwertz",
    platform: "apple",
    score: 0,
    mapping: {
      KeyA: ["a", "A", "\xE5", "\xC5"],
      KeyB: ["b", "B", "\u222B", "\u2039"],
      KeyC: ["c", "C", "\xE7", "\xC7"],
      KeyD: ["d", "D", "\u2202", "\u2122"],
      KeyE: ["e", "E", "\u20AC", "\u2030"],
      KeyF: ["f", "F", "\u0192", "\xCF"],
      KeyG: ["g", "G", "\xA9", "\xCC"],
      KeyH: ["h", "H", "\xAA", "\xD3"],
      KeyI: ["i", "I", "\u2044", "\xDB"],
      KeyJ: ["j", "J", "\xBA", "\u0131"],
      KeyK: ["k", "K", "\u2206", "\u02C6"],
      KeyL: ["l", "L", "@", "\uFB02"],
      KeyM: ["m", "M", "\xB5", "\u02D8"],
      KeyN: ["n", "N", "~", "\u203A"],
      KeyO: ["o", "O", "\xF8", "\xD8"],
      KeyP: ["p", "P", "\u03C0", "\u220F"],
      KeyQ: ["q", "Q", "\xAB", "\xBB"],
      KeyR: ["r", "R", "\xAE", "\xB8"],
      KeyS: ["s", "S", "\u201A", "\xCD"],
      KeyT: ["t", "T", "\u2020", "\u02DD"],
      KeyU: ["u", "U", "\xA8", "\xC1"],
      KeyV: ["v", "V", "\u221A", "\u25CA"],
      KeyW: ["w", "W", "\u2211", "\u201E"],
      KeyX: ["x", "X", "\u2248", "\xD9"],
      KeyY: ["z", "Z", "\u03A9", "\u02C7"],
      KeyZ: ["y", "Y", "\xA5", "\u2021"],
      Digit1: ["1", "!", "\xA1", "\xAC"],
      Digit2: ["2", '"', "\u201C", "\u201D"],
      Digit3: ["3", "\xA7", "\xB6", "#"],
      Digit4: ["4", "$", "\xA2", "\xA3"],
      Digit5: ["5", "%", "[", "\uFB01"],
      Digit6: ["6", "&", "]", "^"],
      Digit7: ["7", "/", "|", "\\"],
      Digit8: ["8", "(", "{", "\u02DC"],
      Digit9: ["9", ")", "}", "\xB7"],
      Digit0: ["0", "=", "\u2260", "\xAF"],
      Space: [" ", " ", " ", " "],
      Minus: ["\xDF", "?", "\xBF", "\u02D9"],
      Equal: ["\xB4", "`", "'", "\u02DA"],
      BracketLeft: ["\xFC", "\xDC", "\u2022", "\xB0"],
      BracketRight: ["+", "*", "\xB1", "\uF8FF"],
      Backslash: ["#", "'", "\u2018", "\u2019"],
      Semicolon: ["\xF6", "\xD6", "\u0153", "\u0152"],
      Quote: ["\xE4", "\xC4", "\xE6", "\xC6"],
      Backquote: ["<", ">", "\u2264", "\u2265"],
      Comma: [",", ";", "\u221E", "\u02DB"],
      Period: [".", ":", "\u2026", "\xF7"],
      Slash: ["-", "_", "\u2013", "\u2014"],
      NumpadDivide: ["/", "/", "/", "/"],
      NumpadMultiply: ["*", "*", "*", "*"],
      NumpadSubtract: ["-", "-", "-", "-"],
      NumpadAdd: ["+", "+", "+", "+"],
      NumpadDecimal: [",", ",", ".", "."],
      IntlBackslash: ["^", "\xB0", "\u201E", "\u201C"],
      NumpadEqual: ["=", "=", "=", "="]
    }
  });
  register({
    id: "dvorak",
    locale: "en",
    displayName: "Dvorak",
    virtualLayout: "dvorak",
    platform: "",
    score: 0,
    mapping: {
      KeyA: ["a", "A", "\xE5", "\xC5"],
      KeyB: ["x", "X", "\u2248", "\u02DB"],
      KeyC: ["j", "J", "\u2206", "\xD4"],
      KeyD: ["e", "E", "\xB4", "\xB4"],
      KeyE: [".", ">", "\u2265", "\u02D8"],
      KeyF: ["u", "U", "\xA8", "\xA8"],
      KeyG: ["i", "I", "\u02C6", "\u02C6"],
      KeyH: ["d", "D", "\u2202", "\xCE"],
      KeyI: ["c", "C", "\xE7", "\xC7"],
      KeyJ: ["h", "H", "\u02D9", "\xD3"],
      KeyK: ["t", "T", "\u2020", "\u02C7"],
      KeyL: ["n", "N", "\u02DC", "\u02DC"],
      KeyM: ["m", "M", "\xB5", "\xC2"],
      KeyN: ["b", "B", "\u222B", "\u0131"],
      KeyO: ["r", "R", "\xAE", "\u2030"],
      KeyP: ["l", "L", "\xAC", "\xD2"],
      KeyQ: ["'", '"', "\xE6", "\xC6"],
      KeyR: ["p", "P", "\u03C0", "\u220F"],
      KeyS: ["o", "O", "\xF8", "\xD8"],
      KeyT: ["y", "Y", "\xA5", "\xC1"],
      KeyU: ["g", "G", "\xA9", "\u02DD"],
      KeyV: ["k", "K", "\u02DA", "\uF8FF"],
      KeyW: [",", "<", "\u2264", "\xAF"],
      KeyX: ["q", "Q", "\u0153", "\u0152"],
      KeyY: ["f", "F", "\u0192", "\xCF"],
      KeyZ: [";", ":", "\u2026", "\xDA"],
      Digit1: ["1", "!", "\xA1", "\u2044"],
      Digit2: ["2", "@", "\u2122", "\u20AC"],
      Digit3: ["3", "#", "\xA3", "\u2039"],
      Digit4: ["4", "$", "\xA2", "\u203A"],
      Digit5: ["5", "%", "\u221E", "\uFB01"],
      Digit6: ["6", "^", "\xA7", "\uFB02"],
      Digit7: ["7", "&", "\xB6", "\u2021"],
      Digit8: ["8", "*", "\u2022", "\xB0"],
      Digit9: ["9", "(", "\xAA", "\xB7"],
      Digit0: ["0", ")", "\xBA", "\u201A"],
      Space: [" ", " ", " ", " "],
      Minus: ["[", "{", "\u201C", "\u201D"],
      Equal: ["]", "}", "\u2018", "\u2019"],
      BracketLeft: ["/", "?", "\xF7", "\xBF"],
      BracketRight: ["=", "+", "\u2260", "\xB1"],
      Backslash: ["\\", "|", "\xAB", "\xBB"],
      Semicolon: ["s", "S", "\xDF", "\xCD"],
      Quote: ["-", "_", "\u2013", "\u2014"],
      Backquote: ["`", "~", "`", "`"],
      Comma: ["w", "W", "\u2211", "\u201E"],
      Period: ["v", "V", "\u221A", "\u25CA"],
      Slash: ["z", "Z", "\u03A9", "\xB8"],
      NumpadDivide: ["/", "/", "/", "/"],
      NumpadMultiply: ["*", "*", "*", "*"],
      NumpadSubtract: ["-", "-", "-", "-"],
      NumpadAdd: ["+", "+", "+", "+"],
      Numpad1: ["1", "1", "1", "1"],
      Numpad2: ["2", "2", "2", "2"],
      Numpad3: ["3", "3", "3", "3"],
      Numpad4: ["4", "4", "4", "4"],
      Numpad5: ["5", "5", "5", "5"],
      Numpad6: ["6", "6", "6", "6"],
      Numpad7: ["7", "7", "7", "7"],
      Numpad8: ["8", "8", "8", "8"],
      Numpad9: ["9", "9", "9", "9"],
      Numpad0: ["0", "0", "0", "0"],
      NumpadDecimal: [".", ".", ".", "."],
      IntlBackslash: ["\xA7", "\xB1", "\xA7", "\xB1"],
      NumpadEqual: ["=", "=", "=", "="],
      AudioVolumeUp: ["", "=", "", "="]
    }
  });

  // src/editor/keybindings.ts
  function matchPlatform(p) {
    if (isBrowser()) {
      const plat = osPlatform();
      const isNeg = p.startsWith("!");
      const isMatch = p.endsWith(plat);
      if (isNeg && !isMatch)
        return true;
      if (!isNeg && isMatch)
        return true;
    }
    if (p === "!other")
      return false;
    return p === "other";
  }
  function getCommandForKeybinding(keybindings, mode, inKeystroke) {
    if (keybindings.length === 0)
      return "";
    const keystroke = keystrokeModifiersToString(
      keystrokeModifiersFromString(inKeystroke)
    );
    for (let i = keybindings.length - 1; i >= 0; i--) {
      if (keybindings[i].key === keystroke) {
        if (!keybindings[i].ifMode || keybindings[i].ifMode === mode)
          return keybindings[i].command;
      }
    }
    return "";
  }
  function commandToString(command) {
    let result = command;
    if (isArray(result)) {
      result = result.length > 0 ? result[0] + "(" + result.slice(1).join("") + ")" : "";
    }
    return result;
  }
  function getKeybindingsForCommand(keybindings, command) {
    let result = [];
    if (typeof command === "string") {
      const candidate = REVERSE_KEYBINDINGS[command];
      if (isArray(candidate))
        result = candidate.slice();
      else if (candidate)
        result.push(candidate);
    }
    const normalizedCommand = commandToString(command);
    const regex = new RegExp(
      "^" + normalizedCommand.replace("\\", "\\\\").replace("|", "\\|").replace("*", "\\*").replace("$", "\\$").replace("^", "\\^") + "([^*a-zA-Z]|$)"
    );
    for (const keybinding of keybindings) {
      if (regex.test(commandToString(keybinding.command)))
        result.push(keybinding.key);
    }
    return result.map(getKeybindingMarkup);
  }
  function getKeybindingMarkup(keystroke) {
    var _a3;
    const useSymbol = /macos|ios|/.test(osPlatform());
    const segments = keystroke.split("+");
    let result = "";
    for (const segment of segments) {
      if (!useSymbol && result)
        result += '<span class="ML__shortcut-join">+</span>';
      if (segment.startsWith("[Key"))
        result += segment.slice(4, 5);
      else if (segment.startsWith("Key"))
        result += segment.slice(3, 4);
      else if (segment.startsWith("[Digit"))
        result += segment.slice(6, 7);
      else if (segment.startsWith("Digit"))
        result += segment.slice(5, 6);
      else {
        result += (_a3 = {
          "cmd": "\u2318",
          "meta": useSymbol ? "\u2318" : "command",
          "shift": useSymbol ? "\u21E7" : "shift",
          "alt": useSymbol ? "\u2325" : "alt",
          "ctrl": useSymbol ? "\u2303" : "control",
          "\n": useSymbol ? "\u23CE" : "return",
          "[return]": useSymbol ? "\u23CE" : "return",
          "[enter]": useSymbol ? "\u2324" : "enter",
          "[tab]": useSymbol ? "\u21E5" : "tab",
          // 'Esc':          useSymbol ? '\u238b' : 'esc',
          "[escape]": "esc",
          "[backspace]": useSymbol ? "\u232B" : "backspace",
          "[delete]": useSymbol ? "\u2326" : "del",
          "[pageup]": useSymbol ? "\u21DE" : "page up",
          "[pagedown]": useSymbol ? "\u21DF" : "page down",
          "[home]": useSymbol ? "\u2912" : "home",
          "[end]": useSymbol ? "\u2913" : "end",
          "[space]": "space",
          "[equal]": "=",
          "[minus]": "-",
          "[comma]": ",",
          "[slash]": "/",
          "[backslash]": "\\",
          "[bracketleft]": "[",
          "[bracketright]": "]",
          "semicolon": ";",
          "period": ".",
          "comma": ",",
          "minus": "-",
          "equal": "=",
          "quote": "'",
          "bracketLeft": "[",
          "bracketRight": "]",
          "backslash": "\\",
          "intlbackslash": "\\",
          "backquote": "`",
          "slash": "/",
          "numpadmultiply": "* &#128290;",
          "numpaddivide": "/ &#128290;",
          // Numeric keypad
          "numpadsubtract": "- &#128290;",
          "numpadadd": "+ &#128290;",
          "numpaddecimal": ". &#128290;",
          "numpadcomma": ", &#128290;",
          "help": "help",
          "left": "\u21E0",
          "up": "\u21E1",
          "right": "\u21E2",
          "down": "\u21E3",
          "[arrowleft]": "\u21E0",
          "[arrowup]": "\u21E1",
          "[arrowright]": "\u21E2",
          "[arrowdown]": "\u21E3",
          "[digit0]": "0",
          "[digit1]": "1",
          "[digit2]": "2",
          "[digit3]": "3",
          "[digit4]": "4",
          "[digit5]": "5",
          "[digit6]": "6",
          "[digit7]": "7",
          "[digit8]": "8",
          "[digit9]": "9"
        }[segment.toLowerCase()]) != null ? _a3 : segment.toUpperCase();
      }
    }
    return result;
  }
  function normalizeKeybinding(keybinding, layout) {
    if (keybinding.ifPlatform && !/^!?(macos|windows|android|ios|chromeos|other)$/.test(
      keybinding.ifPlatform
    )) {
      throw new Error(
        `Unexpected platform "${keybinding.ifPlatform}" for keybinding ${keybinding.key}`
      );
    }
    if (keybinding.ifLayout !== void 0 && (layout.score === 0 || !keybinding.ifLayout.includes(layout.id)))
      return void 0;
    const modifiers = keystrokeModifiersFromString(keybinding.key);
    let platform2 = keybinding.ifPlatform;
    if (modifiers.cmd) {
      if (platform2 && platform2 !== "macos" && platform2 !== "ios") {
        throw new Error(
          'Unexpected "cmd" modifier with platform "' + platform2 + '"\n"cmd" modifier can only be used with macOS or iOS platform.'
        );
      }
      if (!platform2)
        platform2 = osPlatform() === "ios" ? "ios" : "macos";
      modifiers.win = false;
      modifiers.cmd = false;
      modifiers.meta = true;
    }
    if (modifiers.win) {
      if (platform2 && platform2 !== "windows") {
        throw new Error(
          'Unexpected "win" modifier with platform "' + platform2 + '"\n"win" modifier can only be used with Windows platform.'
        );
      }
      platform2 = "windows";
      modifiers.win = false;
      modifiers.cmd = false;
      modifiers.meta = true;
    }
    if (platform2 && !matchPlatform(platform2))
      return void 0;
    if (/^\[.+\]$/.test(modifiers.key)) {
      return __spreadProps(__spreadValues({}, keybinding), {
        ifPlatform: platform2,
        key: keystrokeModifiersToString(modifiers)
      });
    }
    const code = getCodeForKey(modifiers.key, layout);
    if (!code)
      throw new Error('Invalid keybinding key "' + keybinding.key + '"');
    if (code.shift && modifiers.shift || code.alt && modifiers.alt) {
      throw new Error(
        `The keybinding ${keybinding.key} (${selectorToString(
          keybinding.command
        )}) is conflicting with the key combination ${keystrokeModifiersToString(
          code
        )} using the ${layout.displayName} keyboard layout`
      );
    }
    code.shift = code.shift || modifiers.shift;
    code.alt = code.alt || modifiers.alt;
    code.meta = modifiers.meta;
    code.ctrl = modifiers.ctrl;
    return __spreadProps(__spreadValues({}, keybinding), {
      ifPlatform: platform2,
      key: keystrokeModifiersToString(code)
    });
  }
  function selectorToString(selector) {
    if (Array.isArray(selector)) {
      const sel = [...selector];
      return sel.shift() + "(" + sel.map((x) => typeof x === "string" ? `"${x}"` : x.toString()).join(", ") + ")";
    }
    return selector;
  }
  function normalizeKeybindings(keybindings, layout) {
    const result = [];
    const errors = [];
    for (const x of keybindings) {
      try {
        const keybinding = normalizeKeybinding(x, layout);
        if (keybinding) {
          const matches = result.filter(
            (x2) => x2.key === keybinding.key && x2.ifMode === keybinding.ifMode
          );
          if (matches.length > 0) {
            throw new Error(
              `Ambiguous key binding ${x.key} (${selectorToString(
                x.command
              )}) matches ${matches[0].key} (${selectorToString(
                matches[0].command
              )}) with the ${layout.displayName} keyboard layout`
            );
          }
          result.push(keybinding);
        }
      } catch (error) {
        if (error instanceof Error)
          errors.push(error.message);
      }
    }
    return [result, errors];
  }

  // css/popover.less
  var popover_default = `/* The element that display info while in latex mode */
#mathlive-popover-panel {
  background-color: rgba(97, 97, 97);
  color: #fff;
  text-align: center;
  border-radius: 8px;
  position: fixed;
  z-index: 1;
  display: none;
  flex-direction: column;
  justify-content: center;
  box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
}
#mathlive-popover-panel.top-tip::after {
  content: '';
  position: absolute;
  top: -15px;
  left: calc(50% - 15px);
  width: 0;
  height: 0;
  border-left: 15px solid transparent;
  border-right: 15px solid transparent;
  border-bottom: 15px solid rgba(97, 97, 97);
  font-size: 1rem;
}
#mathlive-popover-panel.bottom-tip::after {
  content: '';
  position: absolute;
  bottom: -15px;
  left: calc(50% - 15px);
  width: 0;
  height: 0;
  border-left: 15px solid transparent;
  border-right: 15px solid transparent;
  border-top: 15px solid rgba(97, 97, 97);
  font-size: 1rem;
}
#mathlive-popover-panel.is-animated {
  transition: all 0.2s cubic-bezier(0.64, 0.09, 0.08, 1);
  animation: ML__fade-in cubic-bezier(0, 0, 0.2, 1) 0.15s;
}
#mathlive-popover-panel.is-visible {
  display: flex;
}
@keyframes ML__fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
/* The wrapper class for the entire content of the popover panel */
#mathlive-popover-panel ul {
  display: flex;
  flex-flow: column;
  list-style: none;
  margin: 0;
  padding: 0;
  align-items: flex-start;
  max-height: 400px;
  overflow-y: auto;
}
#mathlive-popover-panel li {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  margin: 8px;
  padding: 8px;
  width: calc(100% - 16px - 16px);
  column-gap: 1em;
  border-radius: 8px;
  cursor: pointer;
  /* Since the content can be clicked on, provide feedback on hover */
}
#mathlive-popover-panel li a {
  color: #5ea6fd;
  padding-top: 0.3em;
  margin-top: 0.4em;
  display: block;
}
#mathlive-popover-panel li a:hover {
  color: #5ea6fd;
  text-decoration: underline;
}
#mathlive-popover-panel li:hover,
#mathlive-popover-panel li.is-pressed,
#mathlive-popover-panel li.is-active {
  background: rgba(255, 255, 255, 0.1);
}
/* The command inside a popover (inside a #mathlive-popover-panel) */
.ML__popover__command {
  font-size: 1.6rem;
  font-family: KaTeX_Main;
}
.ML__popover__current {
  background: #5ea6fd;
  color: #fff;
}
.ML__popover__latex {
  font-family: 'IBM Plex Mono', 'Source Code Pro', Consolas, 'Roboto Mono', Menlo, 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Monaco, Courier, monospace;
  align-self: center;
}
/* The keyboard shortcuts for a symbol as displayed in the popover */
.ML__popover__keybinding {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-size: 0.8em;
  opacity: 0.7;
}
/* Style for the character that joins the modifiers of a keyboard shortcut 
(usually a "+" sign)*/
.ML__shortcut-join {
  opacity: 0.5;
}
`;

  // css/core.less
  var core_default = `.ML__sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  margin: -1px;
  padding: 0;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  clip-path: inset(50%);
  white-space: nowrap;
  border: 0;
}
.ML__is-inline {
  display: inline-block;
}
.ML__base {
  visibility: inherit;
  display: inline-block;
  position: relative;
  cursor: text;
  padding: 0;
  margin: 0;
  box-sizing: content-box;
  border: 0;
  outline: 0;
  vertical-align: baseline;
  font-weight: inherit;
  font-family: inherit;
  font-style: inherit;
  text-decoration: none;
  width: min-content;
}
.ML__strut,
.ML__strut--bottom {
  display: inline-block;
  min-height: 0.5em;
}
.ML__small-delim {
  font-family: KaTeX_Main;
}
/* Text mode */
.ML__text {
  font-family: var(--text-font-family, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif);
  white-space: pre;
}
/* Use cmr for 'math upright' */
.ML__cmr {
  font-family: KaTeX_Main;
  font-style: normal;
}
.ML__mathit {
  font-family: KaTeX_Math;
  /* The KaTeX_Math font is italic by default, so the font-style below is only 
     useful when a fallback font is used
  */
  font-style: italic;
}
.ML__mathbf {
  font-family: KaTeX_Main;
  font-weight: bold;
}
/* Lowercase greek symbols should stick to math font when \\mathbf is applied 
   to match TeX idiosyncratic behavior */
.lcGreek.ML__mathbf {
  font-family: KaTeX_Math;
  font-weight: normal;
}
.ML__mathbfit {
  font-family: KaTeX_Math;
  font-weight: bold;
  font-style: italic;
}
.ML__ams {
  font-family: KaTeX_AMS;
}
/* Blackboard */
.ML__bb {
  font-family: KaTeX_AMS;
}
.ML__cal {
  font-family: KaTeX_Caligraphic;
}
.ML__frak {
  font-family: KaTeX_Fraktur;
}
.ML__tt {
  font-family: KaTeX_Typewriter;
}
.ML__script {
  font-family: KaTeX_Script;
}
.ML__sans {
  font-family: KaTeX_SansSerif;
}
.ML__series_ul {
  font-weight: 100;
}
.ML__series_el {
  font-weight: 100;
}
.ML__series_l {
  font-weight: 200;
}
.ML__series_sl {
  font-weight: 300;
}
.ML__series_sb {
  font-weight: 500;
}
.ML__bold,
.ML__boldsymbol {
  font-weight: 700;
}
.ML__series_eb {
  font-weight: 800;
}
.ML__series_ub {
  font-weight: 900;
}
.ML__series_uc {
  font-stretch: ultra-condensed;
}
.ML__series_ec {
  font-stretch: extra-condensed;
}
.ML__series_c {
  font-stretch: condensed;
}
.ML__series_sc {
  font-stretch: semi-condensed;
}
.ML__series_sx {
  font-stretch: semi-expanded;
}
.ML__series_x {
  font-stretch: expanded;
}
.ML__series_ex {
  font-stretch: extra-expanded;
}
.ML__series_ux {
  font-stretch: ultra-expanded;
}
.ML__it {
  font-style: italic;
}
.ML__shape_ol {
  -webkit-text-stroke: 1px black;
  text-stroke: 1px black;
  color: transparent;
}
.ML__shape_sc {
  font-variant: small-caps;
}
.ML__shape_sl {
  font-style: oblique;
}
/* First level emphasis */
.ML__emph {
  color: #bc2612;
}
/* Second level emphasis */
.ML__emph .ML__emph {
  color: #0c7f99;
}
.ML__highlight {
  color: #007cb2;
  background: #edd1b0;
}
.ML__center {
  text-align: center;
}
.ML__label_padding {
  padding: 0 0.5em;
}
.ML__frac-line {
  width: 100%;
  min-height: 1px;
}
.ML__frac-line:after {
  content: '';
  display: block;
  margin-top: -0.04em;
  min-height: 0.04em;
  /* Ensure the line is visible when printing even if "turn off background images" is on*/
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
  /* There's a bug since Chrome 62 where 
      sub-pixel border lines don't draw at some zoom 
      levels (110%, 90%). 
      Setting the min-height used to work around it, but that workaround
      broke in Chrome 84 or so.
      Setting the background (and the min-height) seems to work for now.
      */
  background: currentColor;
  box-sizing: content-box;
  /* Vuetify sets the box-sizing to inherit 
            causes the fraction line to not draw at all sizes (see #26) */
  /* On some versions of Firefox on Windows, the line fails to 
            draw at some zoom levels, but setting the transform triggers
            the hardware accelerated path, which works */
  transform: translate(0, 0);
}
.ML__sqrt {
  display: inline-block;
}
.ML__sqrt-sign {
  display: inline-block;
  font-family: KaTeX_Main;
  position: relative;
}
.ML__sqrt-line {
  display: inline-block;
  height: 0.04em;
  width: 100%;
}
.ML__sqrt-line:before {
  content: '';
  display: block;
  margin-top: -0.04em;
  min-height: 0.04em;
  /* Ensure the line is visible when printing even if "turn off background images" is on*/
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
  background: currentColor;
  /* On some versions of Firefox on Windows, the line fails to 
            draw at some zoom levels, but setting the transform triggers
            the hardware accelerated path, which works */
  transform: translate(0, 0);
}
.ML__sqrt-line:after {
  border-bottom-width: 1px;
  content: ' ';
  display: block;
  margin-top: -0.1em;
}
.ML__sqrt-index {
  margin-left: 0.27777778em;
  margin-right: -0.55555556em;
}
.ML__delim-size1 {
  font-family: KaTeX_Size1;
}
.ML__delim-size2 {
  font-family: KaTeX_Size2;
}
.ML__delim-size3 {
  font-family: KaTeX_Size3;
}
.ML__delim-size4 {
  font-family: KaTeX_Size4;
}
.ML__delim-mult .delim-size1 > span {
  font-family: KaTeX_Size1;
}
.ML__delim-mult .delim-size4 > span {
  font-family: KaTeX_Size4;
}
.ML__accent-body > span {
  font-family: KaTeX_Main;
  width: 0;
}
.ML__accent-vec > span {
  position: relative;
  left: 0.24em;
}
.ML__mathlive {
  display: inline-block;
  direction: ltr;
  text-align: left;
  text-indent: 0;
  text-rendering: auto;
  font-family: KaTeX_Main, 'Times New Roman', serif;
  font-style: normal;
  font-size-adjust: none;
  font-stretch: normal;
  font-variant-caps: normal;
  letter-spacing: normal;
  line-height: 1.2;
  word-wrap: normal;
  word-spacing: normal;
  white-space: nowrap;
  text-shadow: none;
  -webkit-user-select: none;
  user-select: none;
  width: min-content;
}
.ML__mathlive .style-wrap {
  position: relative;
}
.ML__mathlive .mfrac,
.ML__mathlive .left-right {
  display: inline-block;
}
.ML__mathlive .vlist-t {
  display: inline-table;
  table-layout: fixed;
  border-collapse: collapse;
}
.ML__mathlive .vlist-r {
  display: table-row;
}
.ML__mathlive .vlist {
  display: table-cell;
  vertical-align: bottom;
  position: relative;
}
.ML__mathlive .vlist > span {
  display: block;
  height: 0;
  position: relative;
}
.ML__mathlive .vlist > span > span {
  display: inline-block;
}
.ML__mathlive .vlist > span > .pstrut {
  overflow: hidden;
  width: 0;
}
.ML__mathlive .vlist-t2 {
  margin-right: -2px;
}
.ML__mathlive .vlist-s {
  display: table-cell;
  vertical-align: bottom;
  font-size: 1px;
  width: 2px;
  min-width: 2px;
}
.ML__mathlive .msubsup {
  text-align: left;
}
.ML__mathlive .negativethinspace {
  display: inline-block;
  margin-left: -0.16667em;
  height: 0.71em;
}
.ML__mathlive .thinspace {
  display: inline-block;
  width: 0.16667em;
  height: 0.71em;
}
.ML__mathlive .mediumspace {
  display: inline-block;
  width: 0.22222em;
  height: 0.71em;
}
.ML__mathlive .thickspace {
  display: inline-block;
  width: 0.27778em;
  height: 0.71em;
}
.ML__mathlive .enspace {
  display: inline-block;
  width: 0.5em;
  height: 0.71em;
}
.ML__mathlive .quad {
  display: inline-block;
  width: 1em;
  height: 0.71em;
}
.ML__mathlive .qquad {
  display: inline-block;
  width: 2em;
  height: 0.71em;
}
.ML__mathlive .llap,
.ML__mathlive .rlap {
  width: 0;
  position: relative;
  display: inline-block;
}
.ML__mathlive .llap > .inner,
.ML__mathlive .rlap > .inner {
  position: absolute;
}
.ML__mathlive .llap > .fix,
.ML__mathlive .rlap > .fix {
  display: inline-block;
}
.ML__mathlive .llap > .inner {
  right: 0;
}
.ML__mathlive .rlap > .inner {
  left: 0;
}
.ML__mathlive .rule {
  display: inline-block;
  border: solid 0;
  position: relative;
  box-sizing: border-box;
}
.ML__mathlive .overline .overline-line,
.ML__mathlive .underline .underline-line {
  width: 100%;
}
.ML__mathlive .overline .overline-line:before,
.ML__mathlive .underline .underline-line:before {
  border-bottom-style: solid;
  border-bottom-width: 0.04em;
  content: '';
  display: block;
}
.ML__mathlive .overline .overline-line:after,
.ML__mathlive .underline .underline-line:after {
  border-bottom-style: solid;
  border-bottom-width: 0.04em;
  min-height: thin;
  /* There's a bug since Chrome 62 where 
            sub-pixel border lines don't draw at some zoom 
            levels (110%, 90%). Setting the min-height seems to work around it.
            */
  content: '';
  display: block;
  margin-top: -1px;
}
.ML__mathlive .stretchy {
  display: block;
  position: absolute;
  width: 100%;
  left: 0;
  overflow: hidden;
}
.ML__mathlive .stretchy:before,
.ML__mathlive .stretchy:after {
  content: '';
}
.ML__mathlive .stretchy svg {
  display: block;
  position: absolute;
  width: 100%;
  height: inherit;
  fill: currentColor;
  stroke: currentColor;
  fill-rule: nonzero;
  fill-opacity: 1;
  stroke-width: 1;
  stroke-linecap: butt;
  stroke-linejoin: miter;
  stroke-miterlimit: 4;
  stroke-dasharray: none;
  stroke-dashoffset: 0;
  stroke-opacity: 1;
}
.ML__mathlive .slice-1-of-2 {
  display: inline-flex;
  position: absolute;
  left: 0;
  width: 50.2%;
  overflow: hidden;
}
.ML__mathlive .slice-2-of-2 {
  display: inline-flex;
  position: absolute;
  right: 0;
  width: 50.2%;
  overflow: hidden;
}
.ML__mathlive .slice-1-of-3 {
  display: inline-flex;
  position: absolute;
  left: 0;
  width: 25.1%;
  overflow: hidden;
}
.ML__mathlive .slice-2-of-3 {
  display: inline-flex;
  position: absolute;
  left: 25%;
  width: 50%;
  overflow: hidden;
}
.ML__mathlive .slice-3-of-3 {
  display: inline-flex;
  position: absolute;
  right: 0;
  width: 25.1%;
  overflow: hidden;
}
.ML__mathlive .slice-1-of-1 {
  display: inline-flex;
  position: absolute;
  width: 100%;
  left: 0;
  overflow: hidden;
}
.ML__mathlive .nulldelimiter {
  width: 0.12em;
  display: inline-block;
}
.ML__mathlive .op-group {
  display: inline-block;
}
.ML__mathlive .op-symbol {
  position: relative;
}
.ML__mathlive .op-symbol.small-op {
  font-family: KaTeX_Size1;
}
.ML__mathlive .op-symbol.large-op {
  font-family: KaTeX_Size2;
}
.ML__mathlive .accent > .vlist > span {
  text-align: center;
}
.ML__mathlive .mtable .vertical-separator {
  display: inline-block;
  min-width: 1px;
  box-sizing: border-box;
}
.ML__mathlive .mtable .arraycolsep {
  display: inline-block;
}
.ML__mathlive .mtable .col-align-m > .vlist-t {
  text-align: center;
}
.ML__mathlive .mtable .col-align-c > .vlist-t {
  text-align: center;
}
.ML__mathlive .mtable .col-align-l > .vlist-t {
  text-align: left;
}
.ML__mathlive .mtable .col-align-r > .vlist-t {
  text-align: right;
}
.ML__error {
  display: inline-block;
  background-image: radial-gradient(ellipse at center, hsl(341, 100%, 40%), rgba(0, 0, 0, 0) 70%);
  background-color: hsla(341, 100%, 40%, 0.1);
  background-repeat: repeat-x;
  background-size: 3px 3px;
  padding-bottom: 3px;
  background-position: 0 100%;
}
.ML__error > .ML__error {
  background: transparent;
  padding: 0;
}
.ML__composition {
  background: #fff1c2;
  color: black;
  text-decoration: underline var(--caret-color-computed, var(--ML__caret-color));
}
.ML__placeholder {
  color: var(--placeholder-color, var(--ML__placeholder-color));
  opacity: var(--placeholder-opacity, 0.4);
  padding-left: 0.4ex;
  padding-right: 0.4ex;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
}
.ML__notation {
  position: absolute;
  box-sizing: border-box;
}
.ML__container {
  min-height: auto !important;
}
.ML__prompt {
  border-radius: 2px;
}
.ML__editablePromptBox {
  outline: 1px solid #acacac;
  border-radius: 2px;
  z-index: -1;
}
.ML__focusedPromptBox {
  outline: highlight auto 1px;
}
.ML__lockedPromptBox {
  background-color: rgba(142, 142, 141, 0.4);
  z-index: -1;
}
.ML__correctPromptBox {
  outline: 1px solid var(--correct-color, var(--ML__correct-color));
  box-shadow: 0 0 5px var(--correct-color, var(--ML__correct-color));
}
.ML__incorrectPromptBox {
  outline: 1px solid var(--incorrect-color, var(--ML__incorrect-color));
  box-shadow: 0 0 5px var(--incorrect-color, var(--ML__incorrect-color));
}
`;

  // src/virtual-keyboard/mathfield-proxy.ts
  function makeProxy(mf) {
    return {
      value: mf.model.getValue(),
      selectionIsCollapsed: mf.model.selectionIsCollapsed,
      canUndo: mf.canUndo(),
      canRedo: mf.canRedo()
    };
  }

  // src/editor-model/listeners.ts
  function selectionDidChange(model) {
    var _a3;
    if (typeof ((_a3 = model.listeners) == null ? void 0 : _a3.onSelectionDidChange) === "function" && !model.suppressChangeNotifications) {
      model.suppressChangeNotifications = true;
      model.listeners.onSelectionDidChange(model);
      model.suppressChangeNotifications = false;
    }
    window.mathVirtualKeyboard.updateToolbar(makeProxy(model.mathfield));
  }
  function contentWillChange(model, options = {}) {
    var _a3;
    if (model.suppressChangeNotifications || !model.mathfield.host)
      return true;
    model.suppressChangeNotifications = true;
    const result = model.mathfield.host.dispatchEvent(
      new InputEvent("beforeinput", __spreadProps(__spreadValues({}, options), {
        // To work around a bug in WebKit/Safari (the inputType property gets stripped), include the inputType as the 'data' property. (see #1843)
        data: options.data ? options.data : (_a3 = options.inputType) != null ? _a3 : "",
        cancelable: true,
        bubbles: true,
        composed: true
      }))
    );
    model.suppressChangeNotifications = false;
    return result;
  }
  function contentDidChange(model, options) {
    var _a3;
    if (model.suppressChangeNotifications || !model.mathfield.host)
      return;
    model.suppressChangeNotifications = true;
    model.mathfield.host.dispatchEvent(
      new InputEvent("input", __spreadProps(__spreadValues({}, options), {
        // To work around a bug in WebKit/Safari (the inputType property gets stripped), include the inputType as the 'data' property. (see #1843)
        data: options.data ? options.data : (_a3 = options.inputType) != null ? _a3 : "",
        bubbles: true,
        composed: true
      }))
    );
    model.suppressChangeNotifications = false;
  }

  // src/editor-mathfield/mode-editor-latex.ts
  var LatexModeEditor = class extends ModeEditor {
    constructor() {
      super("latex");
    }
    createAtom(command, context, _style) {
      return new LatexAtom(command, context);
    }
    onPaste(mathfield, data) {
      var _a3;
      if (!data)
        return false;
      const text = typeof data === "string" ? data : (_a3 = data.getData("text/x-latex")) != null ? _a3 : data.getData("text/plain");
      if (text && contentWillChange(mathfield.model, {
        inputType: "insertFromPaste",
        data: text
      })) {
        mathfield.snapshot();
        if (this.insert(mathfield.model, text)) {
          contentDidChange(mathfield.model, { inputType: "insertFromPaste" });
          requestUpdate(mathfield);
        }
        return true;
      }
      return false;
    }
    insert(model, text, options) {
      if (!contentWillChange(model, { data: text, inputType: "insertText" }))
        return false;
      if (!options)
        options = {};
      if (!options.insertionMode)
        options.insertionMode = "replaceSelection";
      if (!options.selectionMode)
        options.selectionMode = "placeholder";
      const { suppressChangeNotifications } = model;
      if (options.suppressChangeNotifications)
        model.suppressChangeNotifications = true;
      const savedSuppressChangeNotifications = model.suppressChangeNotifications;
      model.suppressChangeNotifications = true;
      if (options.insertionMode === "replaceSelection" && !model.selectionIsCollapsed)
        model.deleteAtoms(range(model.selection));
      else if (options.insertionMode === "replaceAll") {
        model.root.setChildren([], "body");
        model.position = 0;
      } else if (options.insertionMode === "insertBefore")
        model.collapseSelection("backward");
      else if (options.insertionMode === "insertAfter")
        model.collapseSelection("forward");
      const newAtoms = [];
      for (const c of text) {
        if (COMMAND_MODE_CHARACTERS.test(c))
          newAtoms.push(new LatexAtom(c, model.mathfield));
      }
      let cursor = model.at(model.position);
      if (cursor instanceof LatexGroupAtom)
        cursor = cursor.lastChild;
      if (!(cursor.parent instanceof LatexGroupAtom)) {
        const group = new LatexGroupAtom("", model.mathfield);
        cursor.parent.addChildAfter(group, cursor);
        cursor = group.firstChild;
      }
      const lastNewAtom = cursor.parent.addChildrenAfter(newAtoms, cursor);
      model.suppressChangeNotifications = savedSuppressChangeNotifications;
      if (options.selectionMode === "before") {
      } else if (options.selectionMode === "item")
        model.setSelection(model.anchor, model.offsetOf(lastNewAtom));
      else if (lastNewAtom)
        model.position = model.offsetOf(lastNewAtom);
      contentDidChange(model, { data: text, inputType: "insertText" });
      model.suppressChangeNotifications = suppressChangeNotifications;
      return true;
    }
  };
  function getLatexGroup(model) {
    return model.atoms.find((x) => x instanceof LatexGroupAtom);
  }
  function getLatexGroupBody(model) {
    var _a3, _b3;
    const atom = model.atoms.find((x) => x instanceof LatexGroupAtom);
    if (!atom)
      return [];
    return (_b3 = (_a3 = atom.body) == null ? void 0 : _a3.filter((x) => x instanceof LatexAtom)) != null ? _b3 : [];
  }
  function getCommandSuggestionRange(model, options) {
    var _a3;
    let start = 0;
    let found = false;
    const last = Number.isFinite(options == null ? void 0 : options.before) ? (_a3 = options == null ? void 0 : options.before) != null ? _a3 : 0 : model.lastOffset;
    while (start <= last && !found) {
      const atom = model.at(start);
      found = atom instanceof LatexAtom && atom.isSuggestion;
      if (!found)
        start++;
    }
    if (!found)
      return [void 0, void 0];
    let end = start;
    let done = false;
    while (end <= last && !done) {
      const atom = model.at(end);
      done = !(atom instanceof LatexAtom && atom.isSuggestion);
      if (!done)
        end++;
    }
    return [start - 1, end - 1];
  }
  new LatexModeEditor();

  // src/editor-mathfield/autocomplete.ts
  function removeSuggestion(mathfield) {
    const group = getLatexGroupBody(mathfield.model).filter(
      (x) => x.isSuggestion
    );
    if (group.length === 0)
      return;
    mathfield.model.position = mathfield.model.offsetOf(group[0].leftSibling);
    for (const atom of group)
      atom.parent.removeChild(atom);
  }
  function updateAutocomplete(mathfield, options) {
    var _a3;
    const { model } = mathfield;
    removeSuggestion(mathfield);
    for (const atom2 of getLatexGroupBody(model))
      atom2.isError = false;
    if (!model.selectionIsCollapsed || mathfield.options.popoverPolicy === "off") {
      hidePopover(mathfield);
      return;
    }
    const commandAtoms = [];
    let atom = model.at(model.position);
    while (atom && atom instanceof LatexAtom && /^[a-zA-Z\*]$/.test(atom.value))
      atom = atom.leftSibling;
    if (atom && atom instanceof LatexAtom && atom.value === "\\") {
      commandAtoms.push(atom);
      atom = atom.rightSibling;
      while (atom && atom instanceof LatexAtom && /^[a-zA-Z\*]$/.test(atom.value)) {
        commandAtoms.push(atom);
        atom = atom.rightSibling;
      }
    }
    const command = commandAtoms.map((x) => x.value).join("");
    const suggestions = suggest(mathfield, command);
    if (suggestions.length === 0) {
      if (/^\\[a-zA-Z\*]+$/.test(command))
        for (const atom2 of commandAtoms)
          atom2.isError = true;
      hidePopover(mathfield);
      return;
    }
    const index = (_a3 = options == null ? void 0 : options.atIndex) != null ? _a3 : 0;
    mathfield.suggestionIndex = index < 0 ? suggestions.length - 1 : index % suggestions.length;
    const suggestion = suggestions[mathfield.suggestionIndex];
    if (suggestion !== command) {
      const lastAtom = commandAtoms[commandAtoms.length - 1];
      lastAtom.parent.addChildrenAfter(
        [...suggestion.slice(command.length - suggestion.length)].map(
          (x) => new LatexAtom(x, mathfield, { isSuggestion: true })
        ),
        lastAtom
      );
      render(mathfield, { interactive: true });
    }
    showPopover(mathfield, suggestions);
  }
  function acceptCommandSuggestion(model) {
    const [from, to] = getCommandSuggestionRange(model, {
      before: model.position
    });
    if (from === void 0 || to === void 0)
      return false;
    let result = false;
    model.getAtoms([from, to]).forEach((x) => {
      if (x.isSuggestion) {
        x.isSuggestion = false;
        result = true;
      }
    });
    return result;
  }
  function complete(mathfield, completion = "accept", options) {
    var _a3, _b3;
    hidePopover(mathfield);
    const latexGroup = getLatexGroup(mathfield.model);
    if (!latexGroup)
      return false;
    if (completion === "accept-suggestion") {
      const suggestions = getLatexGroupBody(mathfield.model).filter(
        (x) => x.isSuggestion
      );
      if (suggestions.length === 0)
        return false;
      for (const suggestion of suggestions)
        suggestion.isSuggestion = false;
      mathfield.model.position = mathfield.model.offsetOf(
        suggestions[suggestions.length - 1]
      );
      return true;
    }
    const body = getLatexGroupBody(mathfield.model).filter(
      (x) => !x.isSuggestion
    );
    const latex = body.map((x) => x.value).join("");
    const newPos = latexGroup.leftSibling;
    latexGroup.parent.removeChild(latexGroup);
    mathfield.model.position = mathfield.model.offsetOf(newPos);
    mathfield.mode = (_a3 = options == null ? void 0 : options.mode) != null ? _a3 : "math";
    if (completion === "reject")
      return true;
    ModeEditor.insert("math", mathfield.model, latex, {
      selectionMode: ((_b3 = options == null ? void 0 : options.selectItem) != null ? _b3 : false) ? "item" : "placeholder",
      format: "latex"
    });
    mathfield.snapshot();
    mathfield.model.announce("replacement");
    return true;
  }

  // src/editor/popover.ts
  var POPOVER_STYLESHEET_HASH = void 0;
  var gPopoverStylesheet = null;
  var gCoreStylesheet = null;
  function latexToMarkup(mf, latex) {
    const root = new Atom("root", mf);
    root.body = parseLatex(latex, mf, { parseMode: "math" });
    const context = new Context(
      { registers: mf.registers },
      { fontSize: DEFAULT_FONT_SIZE },
      "displaystyle"
    );
    const box = coalesce(
      adjustInterAtomSpacing(
        new Box(root.render(context), { classes: "ML__base" }),
        context
      )
    );
    return makeStruts(box, { classes: "ML__mathlive" }).toMarkup();
  }
  function showPopover(mf, suggestions) {
    var _a3;
    if (suggestions.length === 0) {
      hidePopover(mf);
      return;
    }
    let template = "";
    for (const [i, suggestion] of suggestions.entries()) {
      const command = suggestion;
      const commandMarkup = latexToMarkup(mf, suggestion);
      const keybinding = getKeybindingsForCommand(mf.keybindings, command).join(
        "<br>"
      );
      template += `<li role="button" data-command="${command}" ${i === mf.suggestionIndex ? "class=ML__popover__current" : ""}><span class="ML__popover__latex">${command}</span><span class="ML__popover__command">${commandMarkup}</span>`;
      if (keybinding)
        template += `<span class="ML__popover__keybinding">${keybinding}</span>`;
      template += "</li>";
    }
    mf.popover = createPopover(mf, `<ul>${template}</ul>`);
    if (mf.popoverVisible) {
      (_a3 = mf.popover.querySelector(".ML__popover__current")) == null ? void 0 : _a3.scrollIntoView({ block: "nearest", inline: "nearest" });
    }
    setTimeout(() => {
      var _a4;
      if (mf.popover && !mf.popoverVisible) {
        mf.popover.classList.add("is-visible");
        mf.popoverVisible = true;
        updatePopoverPosition(mf);
        (_a4 = mf.popover.querySelector(".ML__popover__current")) == null ? void 0 : _a4.scrollIntoView({ block: "nearest", inline: "nearest" });
      }
    }, 32);
  }
  function updatePopoverPosition(mf, options) {
    var _a3;
    if (!mf.element || mf.element.mathfield !== mf)
      return;
    if (!mf.popover || !mf.popoverVisible)
      return;
    if (((_a3 = mf.model.at(mf.model.position)) == null ? void 0 : _a3.type) !== "latex") {
      hidePopover(mf);
      return;
    }
    if (options == null ? void 0 : options.deferred) {
      setTimeout(() => updatePopoverPosition(mf), 32);
      return;
    }
    const position = getCaretPoint(mf.field);
    if (!position)
      return;
    const viewportHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    const scrollbarHeight = window.innerHeight - document.documentElement.clientHeight;
    const virtualkeyboardHeight = window.mathVirtualKeyboard.boundingRect.height;
    if (position.x + mf.popover.offsetWidth / 2 > viewportWidth - scrollbarWidth) {
      mf.popover.style.left = `${viewportWidth - mf.popover.offsetWidth - scrollbarWidth}px`;
    } else if (position.x - mf.popover.offsetWidth / 2 < 0)
      mf.popover.style.left = "0";
    else
      mf.popover.style.left = `${position.x - mf.popover.offsetWidth / 2}px`;
    const spaceAbove = position.y - position.height;
    const spaceBelow = viewportHeight - scrollbarHeight - virtualkeyboardHeight - position.y;
    if (spaceBelow < spaceAbove) {
      mf.popover.classList.add("ML__popover--reverse-direction");
      mf.popover.classList.remove("top-tip");
      mf.popover.classList.add("bottom-tip");
      mf.popover.style.top = `${position.y - position.height - mf.popover.offsetHeight - 15}px`;
    } else {
      mf.popover.classList.remove("ML__popover--reverse-direction");
      mf.popover.classList.add("top-tip");
      mf.popover.classList.remove("bottom-tip");
      mf.popover.style.top = `${position.y + 15}px`;
    }
  }
  function hidePopover(mf) {
    mf.suggestionIndex = 0;
    mf.popoverVisible = false;
    if (mf.popover) {
      mf.popover.classList.remove("is-visible");
      mf.popover.innerHTML = "";
    }
  }
  function createPopover(mf, html) {
    if (!mf.popover) {
      mf.popover = getSharedElement("mathlive-popover-panel");
      if (POPOVER_STYLESHEET_HASH === void 0)
        POPOVER_STYLESHEET_HASH = hashCode(popover_default).toString(36);
      gPopoverStylesheet = inject(
        null,
        popover_default,
        POPOVER_STYLESHEET_HASH
      );
      gCoreStylesheet = inject(
        null,
        core_default,
        hashCode(core_default).toString(36)
      );
      mf.popover.addEventListener("pointerdown", (ev) => ev.preventDefault());
      mf.popover.addEventListener("click", (ev) => {
        let el = ev.target;
        while (el && !el.dataset.command)
          el = el.parentElement;
        if (!el)
          return;
        complete(mf, "reject");
        ModeEditor.insert("math", mf.model, el.dataset.command, {
          selectionMode: "placeholder",
          format: "latex"
        });
        mf.dirty = true;
        mf.focus();
      });
    }
    mf.popover.innerHTML = window.MathfieldElement.createHTML(html);
    return mf.popover;
  }
  function disposePopover(mf) {
    releaseSharedElement(mf.popover);
    if (gPopoverStylesheet)
      gPopoverStylesheet.release();
    if (gCoreStylesheet)
      gCoreStylesheet.release();
    delete mf.popover;
  }

  // src/common/script-url.ts
  function getFileUrl() {
    const stackTraceFrames = String(new Error().stack).replace(/^Error.*\n/, "").split("\n");
    if (stackTraceFrames.length === 0) {
      console.error(
        `Can't use relative paths to specify assets location because the sourcefile location could not be determined (unexpected stack trace format "${new Error().stack}").`
      );
      return "";
    }
    let callerFrame = stackTraceFrames[1];
    let m = callerFrame.match(/http.*\.ts[\?:]/);
    if (m) {
      callerFrame = stackTraceFrames[2];
    }
    m = callerFrame.match(/(https?:.*):[0-9]+:[0-9]+/);
    if (!m) {
      m = callerFrame.match(/at (.*(\.ts))[\?:]/);
      if (!m)
        m = callerFrame.match(/at (.*(\.mjs|\.js))[\?:]/);
    }
    if (!m) {
      console.error(stackTraceFrames);
      console.error(
        `Can't use relative paths to specify assets location because the source file location could not be determined (unexpected location "${callerFrame}").`
      );
      return "";
    }
    return m[1];
  }
  var gResolvedScriptUrl = null;
  var _a, _b;
  var gScriptUrl = ((_b = (_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.currentScript) == null ? void 0 : _b.src) || getFileUrl();
  async function resolveUrl(url) {
    if (/^(?:[a-z+]+:)?\/\//i.test(url))
      return new URL(url).href;
    if (gResolvedScriptUrl === null) {
      try {
        const response = await fetch(gScriptUrl, { method: "HEAD" });
        if (response.status === 200)
          gResolvedScriptUrl = response.url;
      } catch (e) {
        console.error(`Invalid URL "${url}" (relative to "${gScriptUrl}")`);
      }
    }
    return new URL(url, gResolvedScriptUrl != null ? gResolvedScriptUrl : gScriptUrl).href;
  }

  // src/core/fonts.ts
  function makeFontFace(name, source, descriptors = {}) {
    return new FontFace(
      name,
      `url(${source}.woff2) format('woff2')`,
      descriptors
    );
  }
  var gFontsState = "not-loaded";
  async function reloadFonts() {
    gFontsState = "not-loaded";
    return loadFonts();
  }
  async function loadFonts() {
    var _a3;
    if (gFontsState !== "not-loaded")
      return;
    gFontsState = "loading";
    const useStaticFonts = (_a3 = getComputedStyle(document.documentElement).getPropertyValue(
      "--ML__static-fonts"
    )) != null ? _a3 : false;
    if (useStaticFonts) {
      gFontsState = "ready";
      return;
    }
    document.body.classList.remove("ML__fonts-did-not-load");
    if ("fonts" in document) {
      const fontFamilies = [
        "KaTeX_Main",
        "KaTeX_Math",
        "KaTeX_AMS",
        "KaTeX_Caligraphic",
        "KaTeX_Fraktur",
        "KaTeX_SansSerif",
        "KaTeX_Script",
        "KaTeX_Typewriter",
        "KaTeX_Size1",
        "KaTeX_Size2",
        "KaTeX_Size3",
        "KaTeX_Size4"
      ];
      const fontsInDocument = Array.from(document.fonts).map((f) => f.family);
      if (fontFamilies.every((x) => fontsInDocument.includes(x))) {
        gFontsState = "ready";
        return;
      }
      if (!window.MathfieldElement.fontsDirectory) {
        gFontsState = "not-loaded";
        return;
      }
      const fontsFolder = await resolveUrl(
        window.MathfieldElement.fontsDirectory
      );
      if (!fontsFolder) {
        document.body.classList.add("ML__fonts-did-not-load");
        gFontsState = "error";
        return;
      }
      const fonts = [
        ["KaTeX_Main-Regular"],
        ["KaTeX_Main-BoldItalic", { style: "italic", weight: "bold" }],
        ["KaTeX_Main-Bold", { weight: "bold" }],
        ["KaTeX_Main-Italic", { style: "italic" }],
        ["KaTeX_Math-Italic", { style: "italic" }],
        ["KaTeX_Math-BoldItalic", { style: "italic", weight: "bold" }],
        ["KaTeX_AMS-Regular"],
        ["KaTeX_Caligraphic-Regular"],
        ["KaTeX_Caligraphic-Bold", { weight: "bold" }],
        ["KaTeX_Fraktur-Regular"],
        ["KaTeX_Fraktur-Bold", { weight: "bold" }],
        ["KaTeX_SansSerif-Regular", { style: "italic" }],
        ["KaTeX_SansSerif-Bold", { weight: "bold" }],
        ["KaTeX_SansSerif-Italic", { style: "italic" }],
        ["KaTeX_Script-Regular"],
        ["KaTeX_Typewriter-Regular"],
        ["KaTeX_Size1-Regular"],
        ["KaTeX_Size2-Regular"],
        ["KaTeX_Size3-Regular"],
        ["KaTeX_Size4-Regular"]
      ].map(
        (x) => makeFontFace(
          x[0].replace(/-[a-zA-Z]+$/, ""),
          fontsFolder + "/" + x[0],
          x[1]
        )
      );
      try {
        const loadedFonts = await Promise.all(
          fonts.map((x) => {
            try {
              return x.load();
            } catch (e) {
            }
            return void 0;
          })
        );
        loadedFonts.forEach((font) => document.fonts.add(font));
        gFontsState = "ready";
        return;
      } catch (error) {
        console.error(
          `MathLive 0.91.2: The math fonts could not be loaded from "${fontsFolder}"`,
          { cause: error }
        );
        document.body.classList.add("ML__fonts-did-not-load");
      }
      gFontsState = "error";
    }
  }

  // src/editor-mathfield/render.ts
  function hash(latex) {
    let result = 0;
    for (let i = 0; i < latex.length; i++) {
      result = result * 31 + latex.charCodeAt(i);
      result = result | 0;
    }
    return Math.abs(result);
  }
  function requestUpdate(mathfield, options) {
    if (mathfield.dirty)
      return;
    mathfield.dirty = true;
    requestAnimationFrame(() => {
      if (isValidMathfield(mathfield) && mathfield.dirty) {
        mathfield.atomBoundsCache = /* @__PURE__ */ new Map();
        render(mathfield, options);
        mathfield.atomBoundsCache = void 0;
      }
    });
  }
  function makeBox(mathfield, renderOptions) {
    var _a3;
    renderOptions = renderOptions != null ? renderOptions : {};
    const context = new Context(
      {
        registers: mathfield.registers,
        atomIdsSettings: {
          // Using the hash as a seed for the ID
          // keeps the IDs the same until the content of the field changes.
          seed: renderOptions.forHighlighting ? hash(
            Atom.serialize(mathfield.model.root, {
              expandMacro: false,
              defaultMode: mathfield.options.defaultMode
            })
          ) : "random",
          // The `groupNumbers` flag indicates that extra boxes should be generated
          // to represent group of atoms, for example, a box to group
          // consecutive digits to represent a number.
          groupNumbers: (_a3 = renderOptions.forHighlighting) != null ? _a3 : false
        }
      },
      {
        fontSize: DEFAULT_FONT_SIZE,
        letterShapeStyle: mathfield.options.letterShapeStyle
      },
      mathfield.options.defaultMode === "inline-math" ? "textstyle" : "displaystyle"
    );
    const base = mathfield.model.root.render(context);
    const wrapper = makeStruts(adjustInterAtomSpacing(base, context), {
      classes: mathfield.hasEditablePrompts ? "ML__mathlive ML__prompting" : "ML__mathlive",
      attributes: {
        // Sometimes Google Translate kicks in an attempts to 'translate' math
        // This doesn't work very well, so turn off translate
        "translate": "no",
        // Hint to screen readers to not attempt to read this <span>.
        // They should use instead the 'aria-label' attribute.
        "aria-hidden": "true"
      }
    });
    return wrapper;
  }
  function contentMarkup(mathfield, renderOptions) {
    const { model } = mathfield;
    model.root.caret = "";
    model.root.isSelected = false;
    model.root.containsCaret = true;
    for (const atom of model.atoms) {
      atom.caret = "";
      atom.isSelected = false;
      atom.containsCaret = false;
    }
    const hasFocus = mathfield.isSelectionEditable && mathfield.hasFocus();
    if (model.selectionIsCollapsed)
      model.at(model.position).caret = hasFocus ? mathfield.mode : "";
    else {
      const atoms = model.getAtoms(model.selection, { includeChildren: true });
      for (const atom of atoms)
        atom.isSelected = true;
    }
    if (hasFocus) {
      let ancestor = model.at(model.position).parent;
      while (ancestor) {
        ancestor.containsCaret = true;
        ancestor = ancestor.parent;
      }
    }
    const box = makeBox(mathfield, renderOptions);
    return window.MathfieldElement.createHTML(box.toMarkup());
  }
  function render(mathfield, renderOptions) {
    var _a3;
    if (!isValidMathfield(mathfield))
      return;
    renderOptions != null ? renderOptions : renderOptions = {};
    const toggle = (_a3 = mathfield.element) == null ? void 0 : _a3.querySelector(
      "[part=virtual-keyboard-toggle]"
    );
    if (toggle)
      toggle.style.display = mathfield.hasEditableContent ? "flex" : "none";
    const field = mathfield.field;
    const hasFocus = mathfield.isSelectionEditable && mathfield.hasFocus();
    const isFocused = field.classList.contains("ML__focused");
    if (isFocused && !hasFocus)
      field.classList.remove("ML__focused");
    else if (!isFocused && hasFocus)
      field.classList.add("ML__focused");
    field.innerHTML = contentMarkup(mathfield, renderOptions);
    mathfield.fieldContent = field.getElementsByClassName(
      "ML__mathlive"
    )[0];
    renderSelection(mathfield, renderOptions.interactive);
    mathfield.dirty = false;
  }
  function renderSelection(mathfield, interactive) {
    const field = mathfield.field;
    if (!field)
      return;
    for (const element of field.querySelectorAll(
      ".ML__selection, .ML__contains-highlight"
    ))
      element.remove();
    if (!mathfield.hasFocus())
      return;
    if (!(interactive != null ? interactive : false) && gFontsState !== "error" && gFontsState !== "ready") {
      setTimeout(() => {
        if (gFontsState === "ready")
          renderSelection(mathfield);
        else
          setTimeout(() => renderSelection(mathfield), 128);
      }, 32);
    }
    const model = mathfield.model;
    const supposedWidth = parseFloat(getComputedStyle(field).width);
    const actualWidth = field.getBoundingClientRect().width;
    let scaleFactor = actualWidth / supposedWidth;
    scaleFactor = isNaN(scaleFactor) ? 1 : scaleFactor;
    if (model.selectionIsCollapsed) {
      updatePopoverPosition(mathfield, { deferred: true });
      let atom = model.at(model.position);
      while (atom && !(atom.containsCaret && atom.displayContainsHighlight))
        atom = atom.parent;
      if ((atom == null ? void 0 : atom.containsCaret) && atom.displayContainsHighlight) {
        const bounds = adjustForScrolling(
          mathfield,
          getAtomBounds(mathfield, atom)
        );
        if (bounds) {
          bounds.left /= scaleFactor;
          bounds.right /= scaleFactor;
          bounds.top /= scaleFactor;
          bounds.bottom /= scaleFactor;
          const element = document.createElement("div");
          element.classList.add("ML__contains-highlight");
          element.style.position = "absolute";
          element.style.left = `${bounds.left}px`;
          element.style.top = `${bounds.top}px`;
          element.style.width = `${Math.ceil(bounds.right - bounds.left)}px`;
          element.style.height = `${Math.ceil(bounds.bottom - bounds.top - 1)}px`;
          field.insertBefore(element, field.childNodes[0]);
        }
      }
      return;
    }
    for (const x of unionRects(
      getSelectionBounds(mathfield, { excludeAtomsWithBackground: true })
    )) {
      x.left /= scaleFactor;
      x.right /= scaleFactor;
      x.top /= scaleFactor;
      x.bottom /= scaleFactor;
      const selectionElement = document.createElement("div");
      selectionElement.classList.add("ML__selection");
      selectionElement.style.position = "absolute";
      selectionElement.style.left = `${x.left}px`;
      selectionElement.style.top = `${x.top}px`;
      selectionElement.style.width = `${Math.ceil(x.right - x.left)}px`;
      selectionElement.style.height = `${Math.ceil(x.bottom - x.top - 1)}px`;
      field.insertBefore(selectionElement, field.childNodes[0]);
    }
  }
  function unionRects(rects) {
    let result = [];
    for (const rect of rects) {
      let found = false;
      for (const rect2 of result) {
        if (rect.left === rect2.left && rect.right === rect2.right && rect.top === rect2.top && rect.bottom === rect2.bottom) {
          found = true;
          break;
        }
      }
      if (!found)
        result.push(rect);
    }
    rects = result;
    result = [];
    for (const rect of rects) {
      let count = 0;
      for (const rect2 of rects) {
        if (rect.left >= rect2.left && rect.right <= rect2.right && rect.top >= rect2.top && rect.bottom <= rect2.bottom) {
          count += 1;
          if (count > 1)
            break;
        }
      }
      if (count === 1)
        result.push(rect);
    }
    return result;
  }

  // src/editor/commands.ts
  var HAPTIC_FEEDBACK_DURATION = 3;
  var COMMANDS;
  function register2(commands, options) {
    options = options != null ? options : { target: "mathfield", canUndo: false };
    if (!COMMANDS)
      COMMANDS = {};
    for (const selector of Object.keys(commands)) {
      console.assert(!COMMANDS[selector], "Selector already defined: ", selector);
      COMMANDS[selector] = __spreadProps(__spreadValues({}, options), { fn: commands[selector] });
    }
  }
  function getCommandTarget(command) {
    var _a3;
    let selector;
    selector = isArray(command) ? command[0] : command;
    selector = selector.replace(
      /-\w/g,
      (m) => m[1].toUpperCase()
    );
    return (_a3 = COMMANDS[selector]) == null ? void 0 : _a3.target;
  }
  function perform(mathfield, command) {
    var _a3, _b3;
    if (!command)
      return false;
    let selector;
    let args = [];
    let handled = false;
    let dirty = false;
    if (isArray(command)) {
      selector = command[0];
      args = command.slice(1);
    } else
      selector = command;
    selector = selector.replace(
      /-\w/g,
      (m) => m[1].toUpperCase()
    );
    const commandTarget = (_a3 = COMMANDS[selector]) == null ? void 0 : _a3.target;
    if (commandTarget === "model") {
      if (!mathfield.isSelectionEditable && /^(paste|cut|insert|delete|transpose|add)/.test(selector)) {
        mathfield.model.announce("plonk");
        return false;
      }
      if (/^(delete|transpose|add)/.test(selector) && selector !== "deleteBackward")
        mathfield.flushInlineShortcutBuffer();
      if (/^(delete|transpose|add)/.test(selector) && mathfield.mode !== "latex") {
        mathfield.popUndoStack();
        mathfield.snapshot();
      }
      if (mathfield.mode === "latex" && !/^(complete)/.test(selector))
        removeSuggestion(mathfield);
      COMMANDS[selector].fn(mathfield.model, ...args);
      if (mathfield.mode !== "latex" && /^(delete|transpose|add)/.test(selector))
        mathfield.snapshot();
      if (mathfield.mode === "latex")
        updateAutocomplete(mathfield);
      dirty = true;
      handled = true;
    } else if (commandTarget === "virtual-keyboard") {
      dirty = (_b3 = window.mathVirtualKeyboard.executeCommand(command)) != null ? _b3 : false;
      handled = true;
    } else if (COMMANDS[selector]) {
      if (/^(undo|redo)/.test(selector))
        mathfield.flushInlineShortcutBuffer();
      dirty = COMMANDS[selector].fn(mathfield, ...args);
      handled = true;
    } else
      throw new Error(`Unknown command "${selector}"`);
    if (commandTarget !== "virtual-keyboard") {
      if (!mathfield.model.selectionIsCollapsed || /^(transpose|paste|complete|((moveToNextChar|moveToPreviousChar|extend).*))_$/.test(
        selector
      )) {
        mathfield.flushInlineShortcutBuffer();
        mathfield.style = {};
      }
    }
    if (dirty)
      requestUpdate(mathfield);
    return handled;
  }
  function performWithFeedback(mathfield, selector) {
    mathfield.focus();
    if (mathfield_element_default.keypressVibration && canVibrate())
      navigator.vibrate(HAPTIC_FEEDBACK_DURATION);
    if (typeof selector === "string") {
      selector = selector.replace(
        /-\w/g,
        (m) => m[1].toUpperCase()
      );
      if (selector === "moveToNextPlaceholder" || selector === "moveToPreviousPlaceholder" || selector === "complete")
        window.MathfieldElement.playSound("return");
      else if (selector === "deleteBackward" || selector === "deleteForward" || selector === "deletePreviousWord" || selector === "deleteNextWord" || selector === "deleteToGroupStart" || selector === "deleteToGroupEnd" || selector === "deleteToMathFieldStart" || selector === "deleteToMathFieldEnd")
        window.MathfieldElement.playSound("delete");
      else
        window.MathfieldElement.playSound("keypress");
    } else
      window.MathfieldElement.playSound("keypress");
    const result = mathfield.executeCommand(selector);
    mathfield.scrollIntoView();
    return result;
  }
  register2({
    performWithFeedback: (mathfield, command) => performWithFeedback(mathfield, command)
  });
  function nextSuggestion(mathfield) {
    updateAutocomplete(mathfield, { atIndex: mathfield.suggestionIndex + 1 });
    return false;
  }
  function previousSuggestion(mathfield) {
    updateAutocomplete(mathfield, { atIndex: mathfield.suggestionIndex - 1 });
    return false;
  }
  register2(
    {
      complete,
      nextSuggestion,
      previousSuggestion
    },
    { target: "mathfield", category: "autocomplete" }
  );

  // src/virtual-keyboard/proxy.ts
  var VIRTUAL_KEYBOARD_MESSAGE = "mathlive#virtual-keyboard-message";
  function isVirtualKeyboardMessage(evt) {
    var _a3;
    if (evt.type !== "message")
      return false;
    const msg = evt;
    return ((_a3 = msg.data) == null ? void 0 : _a3.type) === VIRTUAL_KEYBOARD_MESSAGE;
  }
  var VirtualKeyboardProxy = class {
    constructor() {
      this.targetOrigin = window.origin;
      this.originValidator = "none";
      window.addEventListener("message", this);
      this.sendMessage("proxy-created");
      this.listeners = {};
    }
    static get singleton() {
      if (!this._singleton)
        this._singleton = new VirtualKeyboardProxy();
      return this._singleton;
    }
    set alphabeticLayout(value) {
      this.sendMessage("update-setting", { alphabeticLayout: value });
    }
    set layouts(value) {
      this.sendMessage("update-setting", { layouts: value });
    }
    set editToolbar(value) {
      this.sendMessage("update-setting", { editToolbar: value });
    }
    set actionKeycap(value) {
      this.sendMessage("update-setting", { actionKeycap: value });
    }
    set shiftKeycap(value) {
      this.sendMessage("update-setting", { shiftKeycap: value });
    }
    set backspaceKeycap(value) {
      this.sendMessage("update-setting", { backspaceKeycap: value });
    }
    set tabKeycap(value) {
      this.sendMessage("update-setting", { tabKeycap: value });
    }
    set container(value) {
      throw new Error("Container inside an iframe cannot be changed");
    }
    show(options) {
      this.sendMessage("show", options);
    }
    hide(options) {
      this.sendMessage("hide", options);
    }
    get visible() {
      return this._boundingRect.height > 0;
    }
    set visible(value) {
      if (value)
        this.show();
      else
        this.hide();
    }
    get boundingRect() {
      return this._boundingRect;
    }
    executeCommand(command) {
      this.sendMessage("execute-command", { command });
      return true;
    }
    updateToolbar(mf) {
      this.sendMessage("update-toolbar", mf);
    }
    connect() {
      this.sendMessage("connect");
    }
    disconnect() {
      this.sendMessage("disconnect");
    }
    addEventListener(type, callback, _options) {
      if (!this.listeners[type])
        this.listeners[type] = /* @__PURE__ */ new Set();
      if (!this.listeners[type].has(callback))
        this.listeners[type].add(callback);
    }
    dispatchEvent(event) {
      if (!this.listeners[event.type] || this.listeners[event.type].size === 0)
        return true;
      this.listeners[event.type].forEach((x) => {
        if (typeof x === "function")
          x(event);
        else
          x == null ? void 0 : x.handleEvent(event);
      });
      return !event.defaultPrevented;
    }
    removeEventListener(type, callback, _options) {
      if (this.listeners[type])
        this.listeners[type].delete(callback);
    }
    handleEvent(evt) {
      if (isVirtualKeyboardMessage(evt)) {
        if (!validateOrigin(evt.origin, this.originValidator)) {
          throw new DOMException(
            `Message from unknown origin (${evt.origin}) cannot be handled`,
            "SecurityError"
          );
        }
        this.handleMessage(evt.data);
      }
    }
    handleMessage(msg) {
      const { action } = msg;
      if (action === "execute-command") {
        const { command } = msg;
        const commandTarget = getCommandTarget(command);
        if (commandTarget === "virtual-keyboard")
          this.executeCommand(command);
        return;
      }
      if (action === "synchronize-proxy") {
        console.log("synchronize-proxy", window, msg.boundingRect);
        this._boundingRect = msg.boundingRect;
        return;
      }
      if (action === "geometry-changed") {
        console.log("geometry-change", window, msg.boundingRect);
        this._boundingRect = msg.boundingRect;
        this.dispatchEvent(new Event("geometrychange"));
        return;
      }
    }
    sendMessage(action, payload = {}) {
      if (!window.top) {
        throw new DOMException(
          `A frame does not have access to the top window and can\u2018t communicate with the keyboard. Review virtualKeyboardTargetOrigin and originValidator on mathfields embedded in an iframe`,
          "SecurityError"
        );
      }
      window.top.postMessage(
        __spreadValues({
          type: VIRTUAL_KEYBOARD_MESSAGE,
          action
        }, payload),
        this.targetOrigin
      );
    }
  };

  // css/virtual-keyboard.less
  var virtual_keyboard_default = `:where(:root) {
  --keyboard-height: 0;
  --keyboard-accent-color: #0c75d8;
  --keyboard-background: #cacfd7;
  --keyboard-border: #ddd;
  --keyboard-padding-horizontal: 0px;
  --keyboard-padding-top: 5px;
  --keyboard-padding-bottom: 0px;
  --keyboard-toolbar-text: #2c2e2f;
  --keyboard-toolbar-text-active: var(--keyboard-accent-color);
  --keyboard-toolbar-background: transparent;
  --keyboard-toolbar-background-hover: #eee;
  --keyboard-toolbar-background-selected: transparent;
  --keyboard-horizontal-rule: 1px solid #fff;
  --keycap-background: white;
  --keycap-background-hover: #f5f5f7;
  --keycap-background-active: white;
  --keycap-border: #e5e6e9;
  --keycap-border-bottom: #8d8f92;
  --keycap-text: #000;
  --keycap-text-active: #fff;
  --keycap-text-hover: #fff;
  --keycap-secondary-text: #333;
  --keycap-shift-text: var(--keyboard-accent-color);
  --keycap-secondary-background: #a0a9b8;
  --keycap-secondary-background-hover: #7d8795;
  --keycap-secondary-text: #060707;
  --keycap-secondary-border: #c5c9d0;
  --keycap-secondary-border-bottom: #989da6;
  --keycap-height: 60px;
  /* Keycap width (incl. margin) */
  --keycap-max-width: 100px;
  --keycap-gap: 8px;
  --keycap-font-size: clamp(16px, 4cqw, 24px);
  --keycap-small-font-size: calc(var(--keycap-font-size) * 0.8);
  --keycap-extra-small-font-size: calc(var(--keycap-font-size) / 1.42);
  --variant-panel-background: #fff;
  --variant-keycap-text: var(--keycap-text, #000);
  --variant-keycap-text-active: var(--keycap-text-active, #fff);
  --variant-keycap-background-active: var(--keyboard-accent-color);
  --variant-keycap-length: 70px;
  --variant-keycap-font-size: 30px;
  --variant-keycap-aside-font-size: 12px;
  --keycap-shift-font-size: 16px;
  --keycap-shift-color: var(--keyboard-accent-color);
}
.if-can-undo,
.if-can-redo,
.if-can-copy,
.if-can-cut,
.if-can-paste {
  opacity: 0.4;
  pointer-events: none;
}
.can-undo .if-can-undo,
.can-redo .if-can-redo,
.can-copy .if-can-copy,
.can-cut .if-can-cut,
.can-paste .if-can-paste {
  opacity: 1;
  pointer-events: all;
}
body > .ML__keyboard {
  position: fixed;
  --keyboard-padding-bottom: calc(var(--keyboard-padding-bottom) + env(safe-area-inset-bottom, 0));
}
body > .ML__keyboard.is-visible > .MLK__backdrop {
  box-shadow: 0 -5px 6px rgba(0, 0, 0, 0.08);
  border-top: 1px solid var(--keyboard-border);
}
body > .ML__keyboard.backdrop-is-transparent.is-visible > .MLK__backdrop {
  box-shadow: none;
  border: none;
}
body > .ML__keyboard.is-visible.animate > .MLK__backdrop {
  transition: 0.28s cubic-bezier(0, 0, 0.2, 1);
  transition-property: transform, opacity;
  transition-timing-function: cubic-bezier(0.4, 0, 1, 1);
}
.ML__keyboard {
  position: relative;
  overflow: hidden;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  z-index: var(--keyboard-zindex, 105);
  box-sizing: border-box;
  outline: none;
  border: none;
  margin: 0;
  padding: 0;
  line-height: 1;
  overflow-wrap: unset;
  text-align: left;
  vertical-align: baseline;
  cursor: auto;
  white-space: pre;
  box-shadow: none;
  opacity: 1;
  transform: none;
  pointer-events: none;
}
.ML__keyboard :where(div) {
  box-sizing: border-box;
  outline: none;
  border: none;
  margin: 0;
  padding: 0;
  line-height: 1;
  overflow-wrap: unset;
  text-align: left;
  vertical-align: baseline;
  cursor: auto;
  white-space: pre;
  box-shadow: none;
  opacity: 1;
  transform: none;
}
.MLK__backdrop {
  position: absolute;
  bottom: calc(-1 * var(--keyboard-height));
  width: 100%;
  height: var(--keyboard-height);
  box-sizing: border-box;
  padding-top: var(--keyboard-padding-top);
  padding-bottom: var(--keyboard-padding-bottom);
  padding-left: var(--keyboard-padding-horizontal);
  padding-right: var(--keyboard-padding-horizontal);
  opacity: 0;
  visibility: hidden;
  transform: translate(0, 0);
  background: var(--keyboard-background);
  overflow: hidden;
}
.backdrop-is-transparent .MLK__backdrop {
  background: transparent;
}
.ML__keyboard.is-visible > .MLK__backdrop {
  transform: translate(0, calc(-1 * var(--keyboard-height)));
  opacity: 1;
  visibility: visible;
}
.caps-lock-indicator {
  display: none;
  width: 8px;
  height: 8px;
  background: #0cbc0c;
  box-shadow: inset 0 0 4px 0 #13ca13, 0 0 4px 0 #a9ef48;
  border-radius: 8px;
  right: 8px;
  top: 8px;
  position: absolute;
}
.ML__keyboard.is-caps-lock .caps-lock-indicator {
  display: block;
}
.ML__keyboard.is-caps-lock .shift {
  background: var(--keyboard-accent-color);
  color: #fff;
}
.MLK__plate {
  position: absolute;
  top: 0;
  left: var(--keyboard-padding-horizontal);
  width: calc(100% - 2 * var(--keyboard-padding-horizontal));
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  container-type: inline-size;
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  pointer-events: all;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-size: 16px;
  /* Size of toolbar labels */
  font-weight: 400;
  text-shadow: none;
}
.ML__box-placeholder {
  color: var(--box-placeholder-color, var(--keyboard-accent-color));
}
.MLK__tex {
  font-family: KaTeX_Main, KaTeX_Math, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
}
.MLK__tex-math {
  font-family: KaTeX_Math, KaTeX_Main, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
  font-style: italic;
}
.MLK__layer {
  display: none;
  outline: none;
}
.MLK__layer.is-visible {
  display: flex;
  flex-flow: column;
}
/* Keyboard layouts are made or rows of keys... */
.MLK__rows {
  display: flex;
  flex-flow: column;
  align-items: center;
  border-collapse: separate;
  clear: both;
  border: 0;
  margin: 0;
  margin-bottom: var(--keycap-gap);
  gap: var(--keycap-gap);
  overflow-x: auto;
  touch-action: none;
}
.MLK__rows > .row {
  display: flex;
  flex-flow: row;
  justify-content: center;
  width: 100%;
  gap: var(--keycap-gap);
  margin: 0;
  padding: 0;
  /* For the alignment of the text on some modifiers (e.g. shift) */
  /* Extra spacing between two adjacent keys */
  /** A regular keycap */
}
.MLK__rows > .row .tex {
  font-family: KaTeX_Math, KaTeX_Main, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
}
.MLK__rows > .row .tex-math {
  font-family: KaTeX_Math, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
}
.MLK__rows > .row .big-op {
  font-size: calc(1.25 * var(--keycap-font-size, 20px));
}
.MLK__rows > .row .small {
  font-size: var(--keycap-small-font-size, 16px);
}
.MLK__rows > .row .bottom {
  justify-content: flex-end;
}
.MLK__rows > .row .left {
  align-items: flex-start;
  padding-left: 12px;
}
.MLK__rows > .row .right {
  align-items: flex-end;
  padding-right: 12px;
}
.MLK__rows > .row .w0 {
  width: 0;
}
.MLK__rows > .row .w5 {
  width: calc(min(var(--keycap-max-width), 10cqw) / 2 - var(--keycap-gap));
}
.MLK__rows > .row .w15 {
  width: calc(15 * min(var(--keycap-max-width), 10cqw) / 10 - var(--keycap-gap));
}
.MLK__rows > .row .w20 {
  width: calc(20 * min(var(--keycap-max-width), 10cqw) / 10 - var(--keycap-gap));
}
.MLK__rows > .row .w50 {
  width: calc(50 * min(var(--keycap-max-width), 10cqw) / 10 - var(--keycap-gap));
}
.MLK__rows > .row .MLK__keycap.w50 {
  font-size: 80%;
  padding-top: 10px;
  font-weight: 100;
}
.MLK__rows > .row .separator {
  background: transparent;
  border: none;
  pointer-events: none;
}
.MLK__rows > .row .horizontal-rule {
  height: 6px;
  margin-top: 3px;
  margin-bottom: 0;
  width: 100%;
  border-radius: 0;
  border-top: var(--keyboard-horizontal-rule);
}
.MLK__rows > .row .ghost {
  background: var(--keyboard-toolbar-background);
  border: none;
  color: var(--keyboard-toolbar-text);
}
.MLK__rows > .row .ghost:hover {
  background: var(--keyboard-toolbar-background-hover);
}
.MLK__rows > .row .bigfnbutton {
  font-size: var(--keycap-extra-small-font-size, 14px);
}
.MLK__rows > .row .shift,
.MLK__rows > .row .action {
  color: var(--keycap-secondary-text);
  background: var(--keycap-secondary-background);
  border-color: var(--keycap-secondary-border);
  border-bottom-color: var(--keycap-secondary-border-bottom);
  line-height: 0.8;
  font-size: calc(1rem);
  font-weight: 600;
  padding: 8px 12px 8px 12px;
}
.MLK__rows > .row .shift:hover,
.MLK__rows > .row .action:hover {
  background: var(--keycap-secondary-background-hover);
}
.MLK__rows > .row .action.primary {
  background: var(--keyboard-accent-color);
  color: #ddd;
}
.MLK__rows > .row .action.primary:hover {
  background: #0d80f2;
  color: #fff;
}
.MLK__rows > .row .shift.selected,
.MLK__rows > .row .action.selected {
  color: var(--keyboard-toolbar-text-active);
}
.MLK__rows > .row .shift.selected.is-pressed,
.MLK__rows > .row .action.selected.is-pressed,
.MLK__rows > .row .shift.selected.is-active,
.MLK__rows > .row .action.selected.is-active {
  color: white;
}
.MLK__rows > .row .warning {
  background: #cd0030;
  color: white;
}
.MLK__rows > .row .warning svg.svg-glyph {
  width: 24px;
  height: 24px;
}
.MLK__rows > .row div {
  display: flex;
  flex-flow: column;
  align-items: center;
  justify-content: space-evenly;
  width: calc(min(var(--keycap-max-width), 10cqw) - var(--keycap-gap));
  height: var(--keycap-height);
  box-sizing: border-box;
  padding: 0;
  vertical-align: top;
  text-align: center;
  float: left;
  color: var(--keycap-text);
  fill: currentColor;
  font-size: var(--keycap-font-size, 20px);
  background: var(--keycap-background);
  border: 1px solid var(--keycap-border);
  border-bottom-color: var(--keycap-border-bottom);
  border-radius: 6px;
  cursor: pointer;
  touch-action: none;
  /* Keys with a variants panel */
  position: relative;
  overflow: hidden;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}
.MLK__rows > .row div:hover {
  background: var(--keycap-background-hover);
}
.MLK__rows > .row div .ML__mathlive {
  pointer-events: none;
  touch-action: none;
}
.MLK__rows > .row div svg.svg-glyph {
  margin: 8px 0;
  width: 20px;
  height: 20px;
}
.MLK__rows > .row div svg.svg-glyph-lg {
  margin: 8px 0;
  width: 24px;
  height: 24px;
}
.MLK__rows > .row div.MLK__tex-math {
  font-size: 25px;
}
.MLK__rows > .row div.is-pressed {
  background: var(--keycap-background-active);
  color: var(--keyboard-toolbar-text-active);
}
.MLK__rows > .row div.MLK__keycap.is-active,
.MLK__rows > .row div.action.is-active,
.MLK__rows > .row div.MLK__keycap.is-pressed,
.MLK__rows > .row div.action.is-pressed {
  z-index: calc(var(--keyboard-zindex, 105) - 5);
  background: var(--keyboard-accent-color);
  color: #fff;
}
.MLK__rows > .row div.MLK__keycap.is-active aside,
.MLK__rows > .row div.action.is-active aside,
.MLK__rows > .row div.MLK__keycap.is-pressed aside,
.MLK__rows > .row div.action.is-pressed aside {
  display: none;
}
.MLK__rows > .row div.MLK__keycap.is-active .MLK__shift,
.MLK__rows > .row div.action.is-active .MLK__shift,
.MLK__rows > .row div.MLK__keycap.is-pressed .MLK__shift,
.MLK__rows > .row div.action.is-pressed .MLK__shift {
  display: none;
}
.MLK__rows > .row div.shift.is-active {
  background: var(--keyboard-toolbar-text-active);
  color: var(--keycap-text-active);
}
.MLK__rows > .row div small {
  color: var(--keycap-secondary-text);
}
.MLK__rows > .row div aside {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-size: 10px;
  line-height: 10px;
  color: var(--keycap-secondary-text);
}
/* Add an attribute 'data-tooltip' to display a tooltip on hover.
Note there are a different set of tooltip rules for the keyboard toggle
(it's in a different CSS tree) */
.MLK__tooltip {
  position: relative;
}
.MLK__tooltip::after {
  position: absolute;
  display: inline-table;
  content: attr(data-tooltip);
  top: inherit;
  bottom: 100%;
  width: max-content;
  max-width: 200px;
  padding: 8px 8px;
  background: #616161;
  color: #fff;
  text-align: center;
  z-index: 2;
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
  border-radius: 2px;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-weight: 400;
  font-size: 12px;
  transition: all 0.15s cubic-bezier(0.4, 0, 1, 1) 1s;
  opacity: 0;
  transform: scale(0.5);
}
.MLK__tooltip:hover {
  position: relative;
}
.MLK__tooltip:hover::after {
  opacity: 1;
  transform: scale(1);
}
.MLK__toolbar {
  align-self: center;
  display: flex;
  flex-flow: row;
  justify-content: space-between;
  width: 100%;
  max-width: 996px;
  min-height: 32px;
  /* Icons for undo/redo, etc. */
}
.MLK__toolbar svg {
  height: 20px;
  width: 20px;
}
.MLK__toolbar > .left {
  position: relative;
  display: flex;
  justify-content: flex-start;
  flex-flow: row;
}
.MLK__toolbar > .right {
  display: flex;
  justify-content: flex-end;
  flex-flow: row;
}
.MLK__toolbar > div > div {
  /* "button" in the toolbar */
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--keyboard-toolbar-text);
  fill: currentColor;
  background: var(--keyboard-toolbar-background);
  font-size: 135%;
  padding: 4px 15px;
  cursor: pointer;
  width: max-content;
  min-width: 42px;
  min-height: 22px;
  border: none;
  padding-left: 10px;
  padding-right: 10px;
  padding-bottom: 8px;
  padding-top: 8px;
  margin-top: 7px;
  margin-bottom: 8px;
  margin-left: 4px;
  margin-right: 4px;
  border-radius: 8px;
  box-shadow: none;
  border-bottom: 2px solid transparent;
}
.MLK__toolbar > div > div:not(.disabled):not(.selected):hover {
  background: var(--keyboard-toolbar-background-hover);
}
.MLK__toolbar > div > div.disabled svg,
.MLK__toolbar > div > div.disabled:hover svg,
.MLK__toolbar > div > div.disabled.is-pressed svg {
  color: var(--keyboard-toolbar-text);
  opacity: 0.2;
}
.MLK__toolbar > div > div:hover,
.MLK__toolbar > div > div:active,
.MLK__toolbar > div > div.is-pressed,
.MLK__toolbar > div > div.is-active {
  color: var(--keyboard-toolbar-text-active);
}
.MLK__toolbar > div > div.selected {
  color: var(--keyboard-toolbar-text-active);
  background: var(--keyboard-toolbar-background-selected);
  border-radius: 0;
  border-bottom-color: var(--keyboard-toolbar-text-active);
  padding-bottom: 4px;
  margin-bottom: 12px;
}
/* This is the element that displays variants on press+hold */
.MLK__variant-panel {
  visibility: hidden;
  position: fixed;
  display: flex;
  flex-flow: row wrap-reverse;
  justify-content: center;
  align-content: center;
  margin: 0;
  padding: 0;
  bottom: auto;
  top: 0;
  box-sizing: content-box;
  transform: none;
  z-index: calc(var(--keyboard-zindex, 105) + 1);
  touch-action: none;
  max-width: 350px;
  background: var(--variant-panel-background);
  text-align: center;
  border-radius: 6px;
  padding: 6px;
  box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
  transition: none;
}
.MLK__variant-panel.is-visible {
  visibility: visible;
}
.MLK__variant-panel.compact {
  --variant-keycap-length: 50px;
  --variant-keycap-font-size: 24px;
  --variant-keycap-aside-font-size: 10px;
}
.MLK__variant-panel .item {
  display: flex;
  flex-flow: column;
  align-items: center;
  justify-content: center;
  font-size: var(--variant-keycap-font-size);
  height: var(--variant-keycap-length);
  width: var(--variant-keycap-length);
  margin: 0;
  box-sizing: border-box;
  border-radius: 5px;
  border: 1px solid transparent;
  background: transparent;
  pointer-events: all;
  cursor: pointer;
  color: var(--variant-keycap-text);
  fill: currentColor;
}
@media (max-height: 412px) {
  .MLK__variant-panel .item {
    --variant-keycap-font-size: 24px;
    --variant-keycap-length: 50px;
  }
}
.MLK__variant-panel .item .ML__mathlive {
  pointer-events: none;
}
.MLK__variant-panel .item.is-pressed,
.MLK__variant-panel .item.is-active {
  background: var(--variant-keycap-background-active);
  color: var(--variant-keycap-text-active);
}
.MLK__variant-panel .item.small {
  font-size: var(--keycap-small-font-size, 16px);
}
.MLK__variant-panel .item.swatch-button {
  box-sizing: border-box;
  background: #fbfbfb;
}
.MLK__variant-panel .item.swatch-button > span {
  display: inline-block;
  margin: 6px;
  width: calc(100% - 12px);
  height: calc(100% - 12px);
  border-radius: 50%;
}
.MLK__variant-panel .item.swatch-button:hover {
  background: #f0f0f0;
}
.MLK__variant-panel .item.swatch-button:hover > span {
  border-radius: 2px;
}
.MLK__variant-panel .item.box > div,
.MLK__variant-panel .item.box > span {
  border: 1px dashed rgba(0, 0, 0, 0.24);
}
.MLK__variant-panel .item .warning {
  min-height: 60px;
  min-width: 60px;
  background: #cd0030;
  color: white;
  padding: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 5px;
}
.MLK__variant-panel .item .warning.is-pressed,
.MLK__variant-panel .item .warning.is-active {
  background: red;
}
.MLK__variant-panel .item .warning svg.svg-glyph {
  width: 50px;
  height: 50px;
}
.MLK__variant-panel .item aside {
  font-size: var(--variant-keycap-aside-font-size);
  line-height: 12px;
  opacity: 0.78;
  padding-top: 2px;
}
.MLK__keycap {
  position: relative;
}
.MLK__shift {
  display: block;
  position: absolute;
  right: 4px;
  top: 4px;
  font-size: var(--keycap-shift-font-size);
  color: var(--keycap-shift-color);
}
.hide-shift .MLK__shift {
  display: none;
}
@media (max-width: 414px) {
  .MLK__variant-panel {
    max-width: 350px;
    --variant-keycap-font-size: 24px;
    --variant-keycap-length: 50px;
  }
}
/* @xs breakpoint: iPhone 5 */
@container (max-width: 414px) {
  .MLK__toolbar > div > div {
    font-size: 100%;
    padding: 0;
    margin-left: 2px;
    margin-right: 2px;
  }
  .MLK__rows > .row > div {
    width: calc(10cqw - 2px);
    height: 42px;
  }
  .MLK__rows .w5 {
    width: calc(5cqw - 2px);
  }
  .MLK__rows .w15 {
    width: calc(15cqw - 2px);
  }
  .MLK__rows .w20 {
    width: calc(20cqw - 2px);
  }
  .MLK__rows .w50 {
    width: calc(50cqw - 2px);
  }
  .MLK__rows .separator {
    width: 2px;
    min-width: 2px;
  }
  .MLK__rows .shift,
  .MLK__rows .action {
    font-size: 65%;
  }
  .MLK__rows .warning svg.svg-glyph {
    width: 14px;
    height: 14px;
  }
}
@container (max-width: 744px) {
  .MLK__rows {
    --keycap-gap: 2px;
    --keycap-height: 52px;
    --keycap-max-width: 62px;
  }
  .MLK__toolbar > div > div {
    padding-left: 0;
    padding-right: 0;
  }
  .MLK__tooltip::after {
    padding: 8px 16px;
    font-size: 16px;
  }
  .MLK__rows > .row > div.fnbutton {
    font-size: 16px;
  }
  .MLK__rows > .row > div.bigfnbutton {
    font-size: calc(var(--keycap-extra-small-font-size, 14px) / 1.55);
  }
  .MLK__rows > .row > div.small {
    font-size: 13px;
  }
  .MLK__rows > .row > div > aside {
    display: none;
  }
  .MLK__shift {
    display: none;
  }
}
/* Medium breakpoint: larger phones */
@container (max-width: 768px) {
  .ML__keyboard {
    --keycap-height: 42px;
  }
  .MLK__rows > .row > div > small {
    font-size: 14px;
  }
}
@container (max-width: 1444px) {
  .MLK__rows .if-wide {
    display: none;
  }
}
@media (prefers-color-scheme: dark) {
  .ML__keyboard {
    --keyboard-accent-color: #56a6f6;
    --keyboard-background: #151515;
    --keyboard-border: transparent;
    --keyboard-toolbar-text: #e3e4e8;
    --keyboard-toolbar-text-active: var(--keyboard-accent-color);
    --keyboard-toolbar-background: transparent;
    --keyboard-toolbar-background-hover: #303030;
    --keyboard-toolbar-background-selected: transparent;
    --keyboard-horizontal-rule: 1px solid #303030;
    --keycap-background: #1f2022;
    --keycap-background-hover: #2f3032;
    --keycap-background-active: #2f3032;
    --keycap-border: transparent;
    --keycap-border-bottom: transparent;
    --keycap-text: #e3e4e8;
    --keycap-text-active: #000;
    --keycap-secondary-background: #3d4144;
    --keycap-secondary-background-hover: #4d5154;
    --keycap-secondary-text: #e7ebee;
    --keycap-secondary-border: transparent;
    --keycap-secondary-border-bottom: transparent;
    --variant-panel-background: #303030;
    --variant-keycap-text: var(--keycap-text);
    --variant-keycap-text-active: #fff;
  }
}
/* Same as the media query, but with a class */
[theme='dark'] .ML__keyboard {
  --keyboard-accent-color: #56a6f6;
  --keyboard-background: #151515;
  --keyboard-border: transparent;
  --keyboard-toolbar-text: #e3e4e8;
  --keyboard-toolbar-text-active: var(--keyboard-accent-color);
  --keyboard-toolbar-background: transparent;
  --keyboard-toolbar-background-hover: #303030;
  --keyboard-toolbar-background-selected: transparent;
  --keyboard-horizontal-rule: border 1px solid #4d5154;
  --keycap-background: #1f2022;
  --keycap-background-hover: #2f3032;
  --keycap-background-active: #2f3032;
  --keycap-border: transparent;
  --keycap-border-bottom: transparent;
  --keycap-text: #e3e4e8;
  --keycap-text-active: #000;
  --keycap-secondary-background: #3d4144;
  --keycap-secondary-background-hover: #4d5154;
  --keycap-secondary-text: #e7ebee;
  --keycap-secondary-border: transparent;
  --keycap-secondary-border-bottom: transparent;
  --variant-panel-background: #303030;
  --variant-keycap-text: var(--keycap-text);
  --variant-keycap-text-active: #fff;
}
[theme='light'] .ML__keyboard {
  --keyboard-accent-color: #0c75d8;
  --keyboard-background: #cacfd7;
  --keyboard-border: #ddd;
  --keyboard-toolbar-text: #2c2e2f;
  --keyboard-toolbar-text-active: var(--keyboard-accent-color);
  --keyboard-toolbar-background: transparent;
  --keyboard-toolbar-background-hover: #eee;
  --keyboard-toolbar-background-selected: transparent;
  --keycap-background: white;
  --keycap-background-hover: #f5f5f7;
  --keycap-background-active: white;
  --keycap-border: #e5e6e9;
  --keycap-border-bottom: #8d8f92;
  --keycap-text: #000;
  --keycap-text-active: #fff;
  --keycap-text-hover: #fff;
  --keycap-secondary-text: #333;
  --keycap-secondary-background: #a0a9b6;
  --keycap-secondary-background-hover: #949ead;
  --keycap-secondary-text: #060707;
  --keycap-secondary-border: #c5c9d0;
  --keycap-secondary-border-bottom: #989da6;
  --variant-panel-background: #fff;
  --variant-keycap-text: var(--keycap-text, #000);
  --variant-keycap-text-active: #fff;
  --variant-keycap-background-active: var(--keyboard-accent-color);
}
`;

  // src/virtual-keyboard/data.ts
  var LAYOUTS = {
    "numeric": {
      label: "123",
      labelClass: "MLK__tex-math",
      tooltip: "keyboard.tooltip.numeric",
      rows: [
        [
          {
            latex: "x",
            shift: "y",
            variants: [
              "y",
              "z",
              "t",
              "r",
              { latex: "f(#?)", class: "small" },
              { latex: "g(#?)", class: "small" },
              "x^2",
              "x^n",
              "x_n",
              "x_{n+1}",
              "x_i",
              "x_{i+1}"
            ]
          },
          { latex: "n", shift: "a", variants: ["i", "j", "p", "k", "a", "u"] },
          "[separator-5]",
          "[7]",
          "[8]",
          "[9]",
          "[/]",
          "[separator-5]",
          {
            latex: "e",
            shift: "\\ln",
            variants: ["\\exp", "\\times 10^{#?}", "\\ln", "\\log_{10}", "\\log"]
          },
          {
            latex: "\\imaginaryI",
            variants: ["\\Re", "\\Im", "\\imaginaryJ", "\\Vert #0 \\Vert"]
          },
          {
            latex: "\\pi",
            shift: "\\sin",
            variants: [
              "\\prod",
              { latex: "\\theta", aside: "theta" },
              { latex: "\\rho", aside: "rho" },
              { latex: "\\tau", aside: "tau" },
              "\\sin",
              "\\cos",
              "\\tan"
            ]
          }
        ],
        [
          {
            label: "<",
            latex: "<",
            class: "hide-shift",
            shift: { latex: "\\le", label: "\u2264" }
          },
          {
            label: ">",
            latex: ">",
            class: "hide-shift",
            shift: { latex: "\\ge", label: "\u2265" }
          },
          "[separator-5]",
          "[4]",
          "[5]",
          "[6]",
          "[*]",
          "[separator-5]",
          {
            class: "hide-shift",
            latex: "#@^2}",
            shift: "#@^{\\prime}}"
          },
          {
            latex: "#@^{#0}}",
            class: "hide-shift",
            shift: "#@_{#?}"
          },
          {
            class: "hide-shift",
            latex: "\\sqrt{#0}",
            shift: { latex: "\\sqrt[#0]{#?}}" }
          }
        ],
        [
          "[(]",
          "[)]",
          "[separator-5]",
          "[1]",
          "[2]",
          "[3]",
          "[-]",
          "[separator-5]",
          {
            latex: "\\int^{\\infty}_{0}",
            class: "small hide-shift",
            shift: "\\int",
            variants: [
              { latex: "\\int_{#?}^{#?}", class: "small" },
              { latex: "\\int", class: "small" },
              { latex: "\\smallint", class: "small" },
              { latex: "\\iint", class: "small" },
              { latex: "\\iiint", class: "small" },
              { latex: "\\oint", class: "small" },
              { latex: "\\dfrac{\\rd}{\\rd x}", class: "small" },
              { latex: "\\frac{\\partial}{\\partial x}", class: "small" },
              "\\capitalDifferentialD",
              "\\rd",
              "\\partial"
            ]
          },
          {
            class: "hide-shift",
            latex: "\\forall",
            shift: "\\exists"
          },
          { label: "[backspace]", width: 1 }
        ],
        [
          { label: "[shift]", width: 2 },
          "[separator-5]",
          "[0]",
          "[.]",
          "[=]",
          "[+]",
          "[separator-5]",
          "[left]",
          "[right]",
          { label: "[action]", width: 1 }
        ]
      ]
    },
    "greek": {
      label: "&alpha;&beta;&gamma;",
      labelClass: "MLK__tex-math",
      tooltip: "keyboard.tooltip.greek",
      rows: [
        [
          {
            label: "<i>&#x03c6;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\varphi",
            aside: "phi var.",
            shift: "\\Phi"
          },
          {
            label: "<i>&#x03c2;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\varsigma",
            aside: "sigma var.",
            shift: "\\Sigma"
          },
          {
            label: "<i>&#x03f5;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\epsilon",
            aside: "espilon",
            shift: '\\char"0190'
          },
          {
            label: "<i>&rho;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\rho",
            aside: "rho",
            shift: '\\char"3A1'
          },
          {
            label: "<i>&tau;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\tau",
            aside: "tau",
            shift: '\\char"3A4'
          },
          {
            label: "<i>&upsilon;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\upsilon",
            aside: "upsilon",
            shift: "\\Upsilon"
          },
          {
            label: "<i>&theta;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\theta",
            aside: "theta",
            shift: "\\Theta"
          },
          {
            label: "<i>&iota;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\iota",
            aside: "iota",
            shift: '\\char"399'
          },
          {
            label: "<i>&omicron;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\omicron",
            aside: "omicron",
            shift: '\\char"39F'
          },
          {
            label: "<i>&pi;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\pi",
            aside: "pi",
            shift: "\\Pi"
          }
        ],
        [
          "[separator-5]",
          {
            label: "<i>&alpha;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\alpha",
            aside: "alpha",
            shift: '\\char"391'
          },
          {
            label: "<i>&sigma;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\sigma",
            aside: "sigma",
            shift: "\\Sigma"
          },
          {
            label: "<i>&delta;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\delta",
            aside: "delta",
            shift: "\\Delta"
          },
          {
            label: "<i>&phi;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\phi",
            aside: "phi",
            shift: "\\Phi"
          },
          {
            label: "<i>&gamma;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\gamma",
            aside: "gamma",
            shift: "\\Gamma"
          },
          {
            label: "<i>&eta;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\eta",
            aside: "eta",
            shift: '\\char"397'
          },
          {
            label: "<i>&xi;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\xi",
            aside: "xi",
            shift: "\\Xi"
          },
          {
            label: "<i>&kappa;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\kappa",
            aside: "kappa",
            shift: "\\Kappa"
          },
          {
            label: "<i>&lambda;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\lambda",
            aside: "lambda",
            shift: "\\Lambda"
          },
          "[separator-5]"
        ],
        [
          "[shift]",
          {
            label: "<i>&zeta;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\zeta",
            aside: "zeta",
            shift: '\\char"396'
          },
          {
            label: "<i>&chi;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\chi",
            aside: "chi",
            shift: '\\char"3A7'
          },
          {
            label: "<i>&psi;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\psi",
            aside: "zeta",
            shift: "\\Psi"
          },
          {
            label: "<i>&omega;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\omega",
            aside: "omega",
            shift: "\\Omega"
          },
          {
            label: "<i>&beta;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\beta",
            aside: "beta",
            shift: '\\char"392'
          },
          {
            label: "<i>&nu;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\nu",
            aside: "nu",
            shift: '\\char"39D'
          },
          {
            label: "<i>&mu;</i>",
            class: "MLK__tex hide-shift",
            insert: "\\mu",
            aside: "mu",
            shift: '\\char"39C'
          },
          "[backspace]"
        ],
        [
          "[separator]",
          {
            label: "<i>&#x03b5;</i>",
            class: "MLK__tex",
            insert: "\\varepsilon",
            aside: "espilon var."
          },
          {
            label: "<i>&#x03d1;</i>",
            class: "MLK__tex",
            insert: "\\vartheta",
            aside: "theta var."
          },
          {
            label: "<i>&#x3f0;</i>",
            class: "MLK__tex",
            insert: "\\varkappa",
            aside: "kappa var."
          },
          {
            label: "<i>&#x03d6;</i>",
            class: "MLK__tex",
            insert: "\\varpi",
            aside: "pi var."
          },
          {
            label: "<i>&#x03f1;</i>",
            class: "MLK__tex",
            insert: "\\varrho",
            aside: "rho var."
          },
          "[left]",
          "[right]",
          "[action]"
        ]
      ]
    },
    "symbols": {
      label: "&infin;\u2260\u2208",
      labelClass: "MLK__tex",
      tooltip: "keyboard.tooltip.symbols",
      rows: [
        [
          {
            latex: "\\sin",
            shift: "\\sin^{-1}",
            variants: [
              { class: "small", latex: "\\sinh" },
              { class: "small", latex: "\\sin^{-1}" },
              { class: "small", latex: "\\arsinh" }
            ]
          },
          "\\ln",
          {
            latex: "\\mathrm{abs}",
            insert: "\\mathrm{abs}\\left(#0\\right)"
          },
          {
            latex: "\\rarr",
            shift: "\\rArr",
            variants: [
              { latex: "\\implies", aside: "implies" },
              { latex: "\\to", aside: "to" },
              "\\dashv",
              { latex: "\\roundimplies", aside: "round implies" }
            ]
          },
          {
            latex: "\\exists",
            variants: ["\\nexists"],
            shift: "\\nexists"
          },
          { latex: "\\in", shift: "\\notin", variants: ["\\notin", "\\owns"] },
          "\\cup",
          {
            latex: "\\overrightarrow{#@}",
            shift: "\\overleftarrow{#@}",
            variants: [
              "\\overleftarrow{#@}",
              "\\bar{#@}",
              "\\vec{#@}",
              "\\hat{#@}",
              "\\check{#@}",
              "\\dot{#@}",
              "\\ddot{#@}",
              "\\mathring{#@}",
              "\\breve{#@}",
              "\\acute{#@}",
              "\\tilde{#@}",
              "\\grave{#@}"
            ]
          },
          "\\lim_{#?}",
          "\\exponentialE"
        ],
        [
          {
            latex: "\\cos",
            shift: "\\cos^{-1}",
            variants: [
              { class: "small", latex: "\\cosh" },
              { class: "small", latex: "\\cos^{-1}" },
              { class: "small", latex: "\\arcosh" }
            ]
          },
          {
            latex: "\\log",
            shift: "\\log_{10}",
            variants: ["\\log_{#0}", "\\log_{10}"]
          },
          "\\left\\vert#0\\right\\vert",
          {
            latex: "\\larr",
            shift: "\\lArr",
            variants: [
              { latex: "\\impliedby", aside: "implied by" },
              { latex: "\\gets", aside: "gets" },
              "\\lArr",
              "\\vdash",
              { latex: "\\models", aside: "models" }
            ]
          },
          {
            latex: "\\forall",
            shift: "\\lnot",
            variants: [
              { latex: "\\land", aside: "and" },
              { latex: "\\lor", aside: "or" },
              { latex: "\\oplus", aside: "xor" },
              { latex: "\\lnot", aside: "not" },
              { latex: "\\downarrow", aside: "nor" },
              { latex: "\\uparrow", aside: "nand" },
              { latex: "\\curlywedge", aside: "nor" },
              { latex: "\\bar\\curlywedge", aside: "nand" }
              // {latex:'\\barwedge', aside:'bar wedge'},
              // {latex:'\\curlyvee', aside:'curly vee'},
              // {latex:'\\veebar', aside:'vee bar'},
            ]
          },
          { latex: "\\ni", shift: "\\not\\owns" },
          "\\cap",
          {
            latex: "\\overline{#@}",
            shift: "\\underline{#@}",
            variants: [
              "\\overbrace{#@}",
              "\\overlinesegment{#@}",
              "\\overleftrightarrow{#@}",
              "\\overrightarrow{#@}",
              "\\overleftarrow{#@}",
              "\\overgroup{#@}",
              "\\underbrace{#@}",
              "\\underlinesegment{#@}",
              "\\underleftrightarrow{#@}",
              "\\underrightarrow{#@}",
              "\\underleftarrow{#@}",
              "\\undergroup{#@}"
            ]
          },
          {
            class: "hide-shift",
            latex: "\\int",
            shift: "\\iint",
            variants: [
              { latex: "\\int_{#?}^{#?}", class: "small" },
              { latex: "\\int", class: "small" },
              { latex: "\\smallint", class: "small" },
              { latex: "\\iint", class: "small" },
              { latex: "\\iiint", class: "small" },
              { latex: "\\oint", class: "small" },
              "\\intop",
              "\\iiint",
              "\\oiint",
              "\\oiiint",
              "\\intclockwise",
              "\\varointclockwise",
              "\\ointctrclockwise",
              "\\intctrclockwise"
            ]
          },
          { latex: "\\pi", shift: "\\tau", variants: ["\\tau"] }
        ],
        [
          {
            latex: "\\tan",
            shift: "\\tan^{-1}",
            variants: [
              { class: "small", latex: "\\tanh" },
              { class: "small", latex: "\\tan^{-1}" },
              { class: "small", latex: "\\artanh" },
              { class: "small", latex: "\\arctan" },
              { class: "small", latex: "\\arctg" },
              { class: "small", latex: "\\tg" }
            ]
          },
          {
            latex: "\\mathrm{exp}",
            insert: "\\mathrm{exp}\\left(#0\\right)",
            variants: ["\\exponentialE^{#0}"]
          },
          "\\left\\Vert#0\\right\\Vert",
          {
            latex: "\\lrArr",
            shift: "\\leftrightarrow",
            variants: [
              { latex: "\\iff", aside: "if and only if" },
              "\\leftrightarrow",
              "\\leftrightarrows",
              "\\Leftrightarrow",
              { latex: "^\\biconditional", aside: "biconditional" }
            ]
          },
          { latex: "\\vert", shift: "!" },
          {
            latex: "#@^{\\complement}",
            aside: "complement",
            variants: [
              { latex: "\\setminus", aside: "set minus" },
              { latex: "\\smallsetminus", aside: "small set minus" }
            ]
          },
          {
            latex: "\\subset",
            shift: "\\subseteq",
            variants: [
              "\\subset",
              "\\subseteq",
              "\\subsetneq",
              "\\varsubsetneq",
              "\\subsetneqq",
              "\\nsubset",
              "\\nsubseteq",
              "\\supset",
              "\\supseteq",
              "\\supsetneq",
              "\\supsetneqq",
              "\\nsupset",
              "\\nsupseteq"
            ]
          },
          {
            latex: "#@^{\\prime}",
            shift: "#@^{\\doubleprime}",
            variants: ["#@^{\\doubleprime}", "#@\\degree"]
          },
          {
            latex: "\\rd",
            shift: "\\partial",
            variants: [
              { latex: "\\dfrac{\\rd}{\\rd x}", class: "small" },
              { latex: "\\frac{\\partial}{\\partial x}", class: "small" },
              "\\capitalDifferentialD",
              "\\rd",
              "\\partial"
            ]
          },
          {
            latex: "\\infty",
            variants: ["\\aleph_0", "\\aleph_1", "\\omega", "\\mathfrak{m}"]
          }
        ],
        [
          { label: "[shift]", width: 2 },
          {
            class: "box",
            latex: ",",
            shift: ";",
            variants: [";", "?"]
          },
          {
            class: "box",
            latex: "\\colon",
            shift: "\\Colon",
            variants: [
              { latex: "\\Colon", aside: "such that", class: "box" },
              { latex: ":", aside: "ratio", class: "box" },
              { latex: "\\vdots", aside: "", class: "box" },
              { latex: "\\ddots", aside: "", class: "box" },
              { latex: "\\ldotp", aside: "low dot", class: "box" },
              { latex: "\\cdotp", aside: "center dot", class: "box" },
              { latex: "\\ldots", aside: "low ellipsis", class: "box" },
              { latex: "\\cdots", aside: "center ellipsis", class: "box" },
              { latex: "\\therefore", aside: "therefore", class: "box" },
              { latex: "\\because", aside: "because", class: "box" }
            ]
          },
          {
            class: "box",
            latex: "\\cdot",
            aside: "centered dot",
            shift: "\\ast",
            variants: [
              "\\circ",
              "\\bigcirc",
              "\\bullet",
              "\\odot",
              "\\oslash",
              "\\circledcirc",
              "\\ast",
              "\\star",
              "\\times",
              "\\doteq",
              "\\doteqdot"
            ]
          },
          "[separator]",
          "[left]",
          "[right]",
          {
            label: "[backspace]",
            width: 1,
            class: "action hide-shift"
          },
          { label: "[action]", width: 1 }
        ]
      ]
    },
    "compact": {
      label: "compact",
      rows: [
        [
          "[+]",
          "[-]",
          "[*]",
          "[/]",
          "[=]",
          "[.]",
          "[(]",
          "[)]",
          "\\sqrt{#0}",
          "#@^{#?}"
        ],
        ["[1]", "[2]", "[3]", "[4]", "[5]", "[6]", "[7]", "[8]", "[9]", "[0]"],
        ["[hr]"],
        [
          "[undo]",
          "[redo]",
          "[separator]",
          "[separator]",
          "[separator]",
          "[left]",
          "[right]",
          { label: "[backspace]", class: "action hide-shift" },
          "[hide-keyboard]"
        ]
      ]
    },
    "minimalist": {
      label: "minimalist",
      layers: [
        {
          style: `
          .minimalist-backdrop {
            display: flex;
            justify-content: center;
          }          
          .minimalist-container {
            --keycap-height: 40px;
            --keycap-max-width: 53px;
            --keycap-small-font-size: 12px;
            background: var(--keyboard-background);
            padding: 20px;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            border: 1px solid var(--keyboard-border);
            box-shadow: 0 0 32px rgb(0 0 0 / 30%);
          }        
        `,
          backdrop: "minimalist-backdrop",
          container: "minimalist-container",
          rows: [
            [
              "+",
              "-",
              "\\times",
              { latex: "\\frac{#@}{#0}", class: "small" },
              "=",
              "[.]",
              "(",
              ")",
              { latex: "\\sqrt{#0}", class: "small" },
              { latex: "#@^{#?}", class: "small" }
            ],
            ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"],
            ["[hr]"],
            [
              "[undo]",
              "[redo]",
              "[separator]",
              "[separator]",
              "[separator]",
              "[left]",
              "[right]",
              { label: "[backspace]", class: "action hide-shift" },
              "[hide-keyboard]"
            ]
          ]
        }
      ]
    },
    "numeric-only": {
      label: "123",
      labelClass: "MLK__tex-math",
      tooltip: "keyboard.tooltip.numeric",
      id: "numeric-only",
      rows: [
        ["7", "8", "9", "[separator]", { label: "[backspace]", width: 2 }],
        ["4", "5", "6", "[separator]", "[separator]", "[separator]"],
        ["1", "2", "3", "[separator]", "[separator]", "[separator]"],
        [
          "0",
          { label: "[.]", variants: [] },
          "-",
          "[separator]",
          "[left]",
          "[right]"
        ]
      ]
    }
  };

  // src/editor/scrim.ts
  var Scrim = class {
    /**
     * - If `options.preventOverlayClose` is false, the scrim is closed if the
     * user clicks on the scrim. That's the behavior for menus, for example.
     * When you need a fully modal situation until the user has made an
     * explicit choice (validating cookie usage, for example), set
     * `preventOverlayClose` to true.
     * - `onClose()` is called when the scrim is being closed
     * -
     */
    constructor(options) {
      var _a3, _b3;
      this.preventOverlayClose = (_a3 = options == null ? void 0 : options.preventOverlayClose) != null ? _a3 : false;
      this.translucent = (_b3 = options == null ? void 0 : options.translucent) != null ? _b3 : false;
      this.state = "closed";
    }
    get element() {
      if (this._element)
        return this._element;
      const element = document.createElement("div");
      element.setAttribute("role", "presentation");
      element.style.position = "fixed";
      element.style.contain = "content";
      element.style.top = "0";
      element.style.left = "0";
      element.style.right = "0";
      element.style.bottom = "0";
      element.style.zIndex = "var(--scrim-zindex, 10099)";
      element.style.outline = "none";
      if (this.translucent) {
        element.style.background = "rgba(255, 255, 255, .2)";
        element.style["backdropFilter"] = "contrast(40%)";
      } else
        element.style.background = "transparent";
      this._element = element;
      return element;
    }
    open(options) {
      var _a3;
      if (this.state !== "closed")
        return;
      this.state = "opening";
      this.savedActiveElement = deepActiveElement();
      const { element } = this;
      ((_a3 = options == null ? void 0 : options.root) != null ? _a3 : document.body).appendChild(element);
      element.addEventListener("click", this);
      document.addEventListener("touchmove", this, false);
      document.addEventListener("scroll", this, false);
      const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
      this.savedMarginRight = document.body.style.marginRight;
      this.savedOverflow = document.body.style.overflow;
      document.body.style.overflow = "hidden";
      const marginRight = Number.parseFloat(
        getComputedStyle(document.body).marginRight
      );
      document.body.style.marginRight = `${marginRight + scrollbarWidth}px`;
      if (options == null ? void 0 : options.child)
        element.append(options.child);
      this.state = "open";
    }
    close() {
      var _a3, _b3, _c2, _d2;
      if (this.state !== "open")
        return;
      this.state = "closing";
      if (typeof this.onClose === "function")
        this.onClose();
      const { element } = this;
      element.removeEventListener("click", this);
      document.removeEventListener("touchmove", this, false);
      document.removeEventListener("scroll", this, false);
      element.remove();
      document.body.style.overflow = (_a3 = this.savedOverflow) != null ? _a3 : "";
      document.body.style.marginRight = (_b3 = this.savedMarginRight) != null ? _b3 : "";
      if (deepActiveElement() !== this.savedActiveElement)
        (_d2 = (_c2 = this.savedActiveElement) == null ? void 0 : _c2.focus) == null ? void 0 : _d2.call(_c2);
      element.innerHTML = "";
      this.state = "closed";
    }
    handleEvent(ev) {
      if (!this.preventOverlayClose) {
        if (ev.target === this._element && ev.type === "click") {
          this.close();
          ev.preventDefault();
          ev.stopPropagation();
        } else if (ev.target === document && (ev.type === "touchmove" || ev.type === "scroll")) {
          this.close();
          ev.preventDefault();
          ev.stopPropagation();
        }
      }
    }
  };
  function deepActiveElement() {
    var _a3;
    let a = document.activeElement;
    while ((_a3 = a == null ? void 0 : a.shadowRoot) == null ? void 0 : _a3.activeElement)
      a = a.shadowRoot.activeElement;
    return a;
  }

  // src/virtual-keyboard/variants.ts
  var VARIANTS2 = {
    // '0-extended': [
    //   '\\emptyset',
    //   '\\varnothing',
    //   '\\infty',
    //   { latex: '#?_0', insert: '#@_0' },
    //   '\\circ',
    //   '\\bigcirc',
    //   '\\bullet',
    // ],
    "0": ["\\varnothing", "\\infty"],
    "1": ["\\frac{1}{#@}", "#@^{-1}", "\\times 10^{#?}", "\\phi", "\\imaginaryI"],
    "2": ["\\frac{1}{2}", "#@^2", "\\sqrt2", "\\exponentialE"],
    "3": ["\\frac{1}{3}", "#@^3", "\\sqrt3", "\\pi"],
    "4": ["\\frac{1}{4}", "#@^4"],
    "5": ["\\frac{1}{5}", "#@^5", "\\sqrt5"],
    "6": ["\\frac{1}{6}", "#@^6"],
    "7": ["\\frac{1}{7}", "#@^7"],
    "8": ["\\frac{1}{8}", "#@^8"],
    "9": ["\\frac{1}{9}", "#@^9"],
    ".": [".", ",", ";", "\\colon"],
    // '(-extended': [
    //   '\\left( #0\\right)',
    //   '\\left[ #0\\right]',
    //   '\\left\\{ #0\\right\\}',
    //   '\\left\\langle #0\\right\\rangle',
    //   '\\lfloor',
    //   '\\llcorner',
    //   '(',
    //   '\\lbrack',
    //   '\\lvert',
    //   '\\lVert',
    //   '\\lgroup',
    //   '\\langle',
    //   '\\lceil',
    //   '\\ulcorner',
    //   '\\lmoustache',
    //   '\\lbrace',
    // ],
    // ')-extended': [
    //   '\\rfloor',
    //   '\\lrcorner',
    //   ')',
    //   '\\rbrack',
    //   '\\rvert',
    //   '\\rVert',
    //   '\\rgroup',
    //   '\\rangle',
    //   '\\rceil',
    //   '\\urcorner',
    //   '\\rmoustache',
    //   '\\rbrace',
    // ],
    // '=-extended': [
    //   '\\cong',
    //   '\\asymp',
    //   '\\equiv',
    //   '\\differencedelta',
    //   '\\varpropto',
    //   '\\thickapprox',
    //   '\\approxeq',
    //   '\\thicksim',
    //   '\\backsim',
    //   '\\eqsim',
    //   '\\simeq',
    //   '\\Bumpeq',
    //   '\\bumpeq',
    //   '\\doteq',
    //   '\\Doteq',
    //   '\\fallingdotseq',
    //   '\\risingdotseq',
    //   '\\coloneq',
    //   '\\eqcirc',
    //   '\\circeq',
    //   '\\triangleq',
    //   '\\between',
    // ],
    // '<': [
    //   '\\leq',
    //   '\\leqq',
    //   '\\lneqq',
    //   '\\ll',
    //   '\\lessgtr',
    //   '\\nless',
    //   '\\nleq',
    //   '\\lesssim',
    //   '\\precsim',
    //   '\\prec',
    //   '\\nprec',
    //   '\\preccurlyeq',
    //   '\\lessdot',
    // ],
    // '>': [
    //   '\\geq',
    //   '\\geqq',
    //   '\\gneqq',
    //   '\\gg',
    //   '\\gtrless',
    //   '\\ngtr',
    //   '\\ngeq',
    //   '\\gtrsim',
    //   '\\succsim',
    //   '\\succ',
    //   '\\nsucc',
    //   '\\succcurlyeq',
    //   '\\gtrdot',
    // ],
    // 'nabla': ['\\nabla\\times', '\\nabla\\cdot', '\\nabla^{2}'],
    // 'xleftarrows': [
    //   '\\xlongequal{#@}',
    //   '\\xleftrightarrow{#@}',
    //   '\\xLeftrightarrow{#@}',
    //   '\\xleftrightharpoons{#@}',
    //   '\\xLeftarrow{#@}',
    //   '\\xleftharpoonup{#@}',
    //   '\\xleftharpoondown{#@}',
    //   '\\xtwoheadleftarrow{#@}',
    //   '\\xhookleftarrow{#@}',
    //   '\\xtofrom{#@}',
    //   '\\xleftequilibrium{#@}', // From mhchem.sty package
    //   '\\xrightleftarrows{#@}', // From mhchem.sty package
    // ],
    // 'xrightarrows': [
    //   '\\xrightarrow{#@}',
    //   '\\xlongequal{#@}',
    //   '\\xleftrightarrow{#@}',
    //   '\\xLeftrightarrow{#@}',
    //   '\\xleftrightharpoons{#@}',
    //   '\\xRightarrow{#@}',
    //   '\\xrightharpoonup{#@}',
    //   '\\xrightharpoondown{#@}',
    //   '\\xtwoheadrightarrow{#@}',
    //   '\\xrightleftharpoons{#@}',
    //   '\\xhookrightarrow{#@}',
    //   '\\xmapsto{#@}',
    //   '\\xrightequilibrium{#@}', // From mhchem.sty package
    //   '\\xrightleftarrows{#@}', // From mhchem.sty package
    // ],
    // 'absnorm': [{latex:'\\lVert #@ \\rVert', aside:'norm'},
    //     {latex:'\\lvert #@ \\rvert', aside:'determinant'},
    //     {latex:'\\begin{cardinality} #@ \\end{cardinality}', aside:'cardinality'},
    //     {latex:'\\lvert #@ \\rvert', aside:'length'},
    //     {latex:'\\lvert #@ \\rvert', aside:'order'},
    // ],
    "a": [
      { latex: "\\aleph", aside: "aleph" },
      { latex: "\\forall", aside: "for all" }
    ],
    "b": [{ latex: "\\beth", aside: "beth" }],
    "c": [{ latex: "\\C", aside: "set of complex numbers" }],
    "d": [{ latex: "\\daleth", aside: "daleth" }],
    "e": [
      { latex: "\\exponentialE", aside: "exponential e" },
      { latex: "\\exists", aside: "there is" },
      { latex: "\\nexists", aside: "there isn\u2019t" }
    ],
    "g": [{ latex: "\\gimel", aside: "gimel" }],
    "h": [
      { latex: "\\hbar", aside: "h bar" },
      { latex: "\\hslash", aside: "h slash" }
    ],
    "i": [{ latex: "\\imaginaryI", aside: "imaginary i" }],
    "j": [{ latex: "\\imaginaryJ", aside: "imaginary j" }],
    "l": [{ latex: "\\ell", aside: "ell" }],
    "n": [{ latex: "\\mathbb{N}", aside: "set of natural numbers" }],
    "p": [{ latex: "\\mathbb{P}", aside: "set of primes" }],
    "q": [{ latex: "\\mathbb{Q}", aside: "set of rational numbers" }],
    "r": [{ latex: "\\mathbb{R}", aside: "set of real numbers" }],
    "z": [{ latex: "\\mathbb{Z}", aside: "set of integers" }],
    "space": [
      {
        latex: '\\char"203A\\!\\char"2039',
        insert: "\\!",
        aside: "negative thin space<br>\u207B\xB3\u29F8\u2081\u2088 em"
      },
      {
        latex: '\\unicode{"203A}\\,\\unicode{"2039}',
        insert: "\\,",
        aside: "thin space<br>\xB3\u29F8\u2081\u2088 em"
      },
      {
        latex: '\\unicode{"203A}\\:\\unicode{"2039}',
        insert: "\\:",
        aside: "medium space<br>\u2074\u29F8\u2081\u2088 em"
      },
      {
        latex: '\\unicode{"203A}\\;\\unicode{"2039}',
        insert: "\\;",
        aside: "thick space<br>\u2075\u29F8\u2081\u2088 em"
      },
      {
        latex: '\\unicode{"203A}\\ \\unicode{"2039}',
        insert: "\\ ",
        aside: "\u2153 em"
      },
      {
        latex: '\\unicode{"203A}\\enspace\\unicode{"2039}',
        insert: "\\enspace",
        aside: "\xBD em"
      },
      {
        latex: '\\unicode{"203A}\\quad\\unicode{"2039}',
        insert: "\\quad",
        aside: "1 em"
      },
      {
        latex: '\\unicode{"203A}\\qquad\\unicode{"2039}',
        insert: "\\qquad",
        aside: "2 em"
      }
    ]
  };
  var variantPanelController;
  function showVariantsPanel(element, onClose) {
    var _a3, _b3;
    const keyboard = VirtualKeyboard.singleton;
    const keycap = parentKeycap(element);
    const variantDef = (_b3 = (_a3 = keyboard.getKeycap(keycap == null ? void 0 : keycap.id)) == null ? void 0 : _a3.variants) != null ? _b3 : "";
    if (typeof variantDef === "string" && !hasVariants(variantDef) || Array.isArray(variantDef) && variantDef.length === 0) {
      onClose == null ? void 0 : onClose();
      return;
    }
    const variants = {};
    let markup = "";
    for (const variant of getVariants(variantDef)) {
      const keycap2 = normalizeKeycap(variant);
      const id = Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
      variants[id] = keycap2;
      const [keycapMarkup, keycapCls] = renderKeycap(keycap2);
      markup += `<div id=${id} class="item ${keycapCls}">${keycapMarkup}</div>`;
    }
    const variantPanel = document.createElement("div");
    variantPanel.setAttribute("aria-hidden", "true");
    variantPanel.className = "MLK__variant-panel";
    variantPanel.style.height = "auto";
    const l = Object.keys(variants).length;
    let w = 5;
    if (l === 1)
      w = 1;
    else if (l === 2 || l === 4)
      w = 2;
    else if (l === 3 || l === 5 || l === 6)
      w = 3;
    else if (l >= 7 && l < 14)
      w = 4;
    variantPanel.style.width = `calc(var(--variant-keycap-length) * ${w} + 12px)`;
    variantPanel.innerHTML = mathfield_element_default.createHTML(markup);
    if (!Scrim.scrim)
      Scrim.scrim = new Scrim();
    Scrim.scrim.open({ root: keyboard.container, child: variantPanel });
    variantPanelController == null ? void 0 : variantPanelController.abort();
    variantPanelController = new AbortController();
    variantPanel.addEventListener(
      "pointerup",
      (ev) => {
        const target = parentKeycap(ev.target);
        if (!(target == null ? void 0 : target.id) || !variants[target.id])
          return;
        executeKeycapCommand(variants[target.id]);
        hideVariantsPanel();
        onClose == null ? void 0 : onClose();
        ev.preventDefault();
      },
      { capture: true, passive: false, signal: variantPanelController.signal }
    );
    variantPanel.addEventListener(
      "pointerenter",
      (ev) => {
        const target = parentKeycap(ev.target);
        if (!(target == null ? void 0 : target.id) || !variants[target.id])
          return;
        target.classList.add("is-active");
      },
      { capture: true, signal: variantPanelController.signal }
    );
    variantPanel.addEventListener(
      "pointerleave",
      (ev) => {
        const target = parentKeycap(ev.target);
        if (!(target == null ? void 0 : target.id) || !variants[target.id])
          return;
        target.classList.remove("is-active");
      },
      { capture: true, signal: variantPanelController.signal }
    );
    window.addEventListener(
      "pointercancel",
      () => {
        hideVariantsPanel();
        onClose == null ? void 0 : onClose();
      },
      { signal: variantPanelController.signal }
    );
    window.addEventListener(
      "pointerup",
      () => {
        hideVariantsPanel();
        onClose == null ? void 0 : onClose();
      },
      { signal: variantPanelController.signal }
    );
    const position = element == null ? void 0 : element.getBoundingClientRect();
    if (position) {
      if (position.top - variantPanel.clientHeight < 0) {
        variantPanel.style.width = "auto";
        if (l <= 6)
          variantPanel.style.height = "56px";
        else if (l <= 12)
          variantPanel.style.height = "108px";
        else if (l <= 18)
          variantPanel.style.height = "205px";
        else
          variantPanel.classList.add("compact");
      }
      const left = Math.max(
        0,
        Math.min(
          window.innerWidth - variantPanel.offsetWidth,
          (position.left + position.right - variantPanel.offsetWidth) / 2
        )
      );
      const top = position.top - variantPanel.clientHeight + 5;
      variantPanel.style.transform = `translate(${left}px, ${top}px)`;
      variantPanel.classList.add("is-visible");
    }
    return;
  }
  function hideVariantsPanel() {
    var _a3;
    variantPanelController == null ? void 0 : variantPanelController.abort();
    (_a3 = Scrim.scrim) == null ? void 0 : _a3.close();
  }
  function makeVariants(id) {
    if (id === "foreground-color") {
      const result = [];
      for (const color of Object.keys(FOREGROUND_COLORS)) {
        result.push({
          class: "swatch-button",
          label: '<span style="border: 3px solid ' + FOREGROUND_COLORS[color] + '"></span>',
          command: ["applyStyle", { color }]
        });
      }
      return result;
    }
    if (id === "background-color") {
      const result = [];
      for (const color of Object.keys(BACKGROUND_COLORS)) {
        result.push({
          class: "swatch-button",
          label: '<span style="background:' + BACKGROUND_COLORS[color] + '"></span>',
          command: ["applyStyle", { backgroundColor: color }]
        });
      }
      return result;
    }
    return void 0;
  }
  function hasVariants(id) {
    return VARIANTS2[id] !== void 0;
  }
  function getVariants(id) {
    var _a3;
    if (typeof id !== "string")
      return id;
    if (!VARIANTS2[id])
      VARIANTS2[id] = (_a3 = makeVariants(id)) != null ? _a3 : [];
    return VARIANTS2[id];
  }

  // src/virtual-keyboard/utils.ts
  function jsonToCssProps(json) {
    if (typeof json === "string")
      return json;
    return Object.entries(json).map(([k, v]) => `${k}:${v} !important`).join(";");
  }
  function jsonToCss(json) {
    return Object.keys(json).map((k) => {
      return `${k} {${jsonToCssProps(json[k])}}`;
    }).join("");
  }
  function latexToMarkup2(latex) {
    if (!latex)
      return "";
    const globalContext = defaultGlobalContext();
    const root = new Atom("root", globalContext);
    const args = (arg) => arg === "@" ? "{\\class{ML__box-placeholder}{\\blacksquare}}" : "\\placeholder{}";
    root.body = parseLatex(latex, globalContext, { parseMode: "math", args });
    const context = new Context(
      { registers: globalContext.registers },
      { fontSize: DEFAULT_FONT_SIZE },
      "displaystyle"
    );
    const box = coalesce(
      adjustInterAtomSpacing(
        new Box(root.render(context), { classes: "ML__base" }),
        context
      )
    );
    return makeStruts(box, { classes: "ML__mathlive" }).toMarkup();
  }
  function normalizeLayer(layer) {
    var _a3;
    if (Array.isArray(layer))
      return layer.map((x) => normalizeLayer(x)).flat();
    const result = typeof layer === "string" ? { markup: layer } : layer;
    if ("rows" in result && Array.isArray(result.rows))
      result.rows = result.rows.map((row) => row.map((x) => normalizeKeycap(x)));
    (_a3 = result.id) != null ? _a3 : result.id = "ML__layer_" + Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
    return [result];
  }
  function alphabeticLayout() {
    var _a3, _b3;
    const keyboard = window.mathVirtualKeyboard;
    let layoutName = keyboard.alphabeticLayout;
    if (layoutName === "auto") {
      const activeLayout = getActiveKeyboardLayout();
      if (activeLayout)
        layoutName = activeLayout.virtualLayout;
      if (!layoutName || layoutName === "auto") {
        layoutName = (_a3 = {
          fr: "azerty",
          be: "azerty",
          al: "qwertz",
          ba: "qwertz",
          cz: "qwertz",
          de: "qwertz",
          hu: "qwertz",
          sk: "qwertz",
          ch: "qwertz"
        }[l10n.locale.slice(0, 2)]) != null ? _a3 : "qwerty";
      }
    }
    const ALPHABETIC_TEMPLATE = {
      qwerty: ["qwertyuiop", " asdfghjkl ", "^zxcvbnm~"],
      azerty: ["azertyuiop", "qsdfghjklm", "^ wxcvbn ~"],
      qwertz: ["qwertzuiop", " asdfghjkl ", "^yxcvbnm~"],
      dvorak: ["^  pyfgcrl ", "aoeuidhtns", "qjkxbmwvz~"],
      colemak: [" qwfpgjluy ", "arstdhneio", "^zxcvbkm~"]
    };
    const template = (_b3 = ALPHABETIC_TEMPLATE[layoutName]) != null ? _b3 : ALPHABETIC_TEMPLATE.qwerty;
    const rows = [
      [
        { label: "1", variants: "1" },
        { label: "2", variants: "2" },
        { label: "3", variants: "3" },
        { label: "4", variants: "4" },
        { label: "5", shift: { latex: "\\frac{#@}{#?}" }, variants: "5" },
        { label: "6", shift: { latex: "#@^#?" }, variants: "6" },
        { label: "7", variants: "4" },
        { label: "8", shift: { latex: "\\times" }, variants: "8" },
        { label: "9", shift: { label: "(", latex: "(" }, variants: "9" },
        { label: "0", shift: { label: ")", latex: ")" }, variants: "0" }
      ]
    ];
    for (const templateRow of template) {
      const row = [];
      for (const k of templateRow) {
        if (/[a-z]/.test(k)) {
          row.push({
            label: k,
            class: "hide-shift",
            shift: { label: k.toUpperCase() },
            variants: hasVariants(k) ? k : void 0
          });
        } else if (k === "~") {
          if (layoutName !== "dvorak")
            row.push("[backspace]");
          else
            row.push({ label: "[backspace]", width: 1 });
        } else if (k === "^")
          row.push("[shift]");
        else if (k === " ")
          row.push("[separator-5]");
      }
      rows.push(row);
    }
    rows.push([
      // {
      //   class: 'action',
      //   label: 'text mode',
      //   command: ['performWithFeedback', ['switchMode', 'text', '', '']],
      // },
      "[-]",
      "[+]",
      "[=]",
      { label: " ", width: 1.5 },
      ",",
      "[.]",
      "[left]",
      "[right]",
      { label: "[action]", width: 1.5 }
    ]);
    return {
      label: "abc",
      labelClass: "MLK__tex-math",
      tooltip: "keyboard.tooltip.alphabetic",
      layers: normalizeLayer({ rows })
    };
  }
  function normalizeLayout(layout) {
    if (layout === "alphabetic")
      return alphabeticLayout();
    if (typeof layout === "string") {
      console.assert(
        LAYOUTS[layout] !== void 0,
        `MathLive 0.91.2: unknown keyboard layout "${layout}"`
      );
      return normalizeLayout(LAYOUTS[layout]);
    }
    let result;
    if ("rows" in layout && Array.isArray(layout.rows)) {
      console.assert(
        !("layers" in layout || "markup" in layout),
        `MathLive 0.91.2: when providing a "rows" property, "layers" and "markup" are ignored`
      );
      const _a3 = layout, { rows } = _a3, partialLayout = __objRest(_a3, ["rows"]);
      result = __spreadProps(__spreadValues({}, partialLayout), {
        layers: normalizeLayer({ rows: layout.rows })
      });
    } else if ("markup" in layout && typeof layout.markup === "string") {
      const _b3 = layout, { markup } = _b3, partialLayout = __objRest(_b3, ["markup"]);
      result = __spreadProps(__spreadValues({}, partialLayout), {
        layers: normalizeLayer(layout.markup)
      });
    } else {
      result = __spreadValues({}, layout);
      if ("layers" in layout)
        result.layers = normalizeLayer(layout.layers);
      else {
        console.error(
          `MathLive 0.91.2: provide either a "rows", "markup" or "layers" property`
        );
      }
    }
    let hasShift = false;
    let hasEdit = false;
    for (const layer of result.layers) {
      if (layer.rows) {
        for (const keycap of layer.rows.flat()) {
          const label = keycap.label;
          if (typeof keycap !== "string" && keycap.class && /(^|\s)shift($|\s)/.test(keycap.class))
            hasShift = true;
          if (["[undo]", "[redo]", "[cut]", "[copy]", "[paste]"].includes(label))
            hasEdit = true;
        }
      }
    }
    if (!("displayShiftedKeycaps" in layout) || layout.displayShiftedKeycaps === void 0)
      result.displayShiftedKeycaps = hasShift;
    if (!("displayEditToolbar" in layout) || layout.displayEditToolbar === void 0)
      result.displayEditToolbar = !hasEdit;
    return result;
  }
  function makeLayoutsToolbar(keyboard, index) {
    var _a3, _b3;
    let markup = `<div class="left">`;
    if (keyboard.normalizedLayouts.length > 1) {
      for (const [i, l] of keyboard.normalizedLayouts.entries()) {
        const layout = l;
        const classes = [i === index ? "selected" : "layer-switch"];
        if (layout.tooltip)
          classes.push("MLK__tooltip");
        if (layout.labelClass)
          classes.push(...layout.labelClass.split(" "));
        markup += `<div class="${classes.join(" ")}"`;
        if (layout.tooltip) {
          markup += " data-tooltip='" + ((_a3 = localize(layout.tooltip)) != null ? _a3 : layout.tooltip) + "' ";
        }
        if (i !== index)
          markup += `data-layer="${layout.layers[0].id}"`;
        markup += `>${(_b3 = layout.label) != null ? _b3 : "untitled"}</div>`;
      }
    }
    markup += "</div>";
    return markup;
  }
  function makeEditToolbar(options, mathfield) {
    let result = "";
    const toolbarOptions = options.editToolbar;
    if (toolbarOptions === "none")
      return "";
    const availableActions = [];
    if (mathfield.selectionIsCollapsed)
      availableActions.push("undo", "redo", "pasteFromClipboard");
    else {
      availableActions.push(
        "cutToClipboard",
        "copyToClipboard",
        "pasteFromClipboard"
      );
    }
    const actionsMarkup = {
      undo: `<div class='action ${mathfield.canUndo === false ? "disabled" : ""}'
          data-command='"undo"'
          data-tooltip='${localize("tooltip.undo")}'>
          <svg><use xlink:href='#svg-undo' /></svg>
      </div>`,
      redo: `<div class='action ${mathfield.canRedo === false ? "disabled" : ""}'
          data-command='"redo"'
          data-tooltip='${localize("tooltip.redo")}'>
          <svg><use xlink:href='#svg-redo' /></svg>
      </div>`,
      cutToClipboard: `
        <div class='action'
            data-command='"cutToClipboard"'
            data-tooltip='${localize("tooltip.cut to clipboard")}'>
            <svg><use xlink:href='#svg-cut' /></svg>
        </div>
    `,
      copyToClipboard: `
        <div class='action'
            data-command='"copyToClipboard"'
            data-tooltip='${localize("tooltip.copy to clipboard")}'>
            <svg><use xlink:href='#svg-copy' /></svg>
        </div>
    `,
      pasteFromClipboard: `
        <div class='action'
            data-command='"pasteFromClipboard"'
            data-tooltip='${localize("tooltip.paste from clipboard")}'>
            <svg><use xlink:href='#svg-paste' /></svg>
        </div>
    `
    };
    result += availableActions.map((action) => actionsMarkup[action]).join("");
    return result;
  }
  function makeSyntheticKeycaps(elementList) {
    for (const element of elementList)
      makeSyntheticKeycap(element);
  }
  function makeSyntheticKeycap(element) {
    const keycap = {};
    if (!element.id) {
      if (element.hasAttribute("data-label"))
        keycap.label = element.dataset.label;
      if (element.hasAttribute("data-latex"))
        keycap.latex = element.dataset.latex;
      if (element.hasAttribute("data-key"))
        keycap.key = element.dataset.key;
      if (element.hasAttribute("data-insert"))
        keycap.insert = element.dataset.insert;
      if (element.hasAttribute("data-variants"))
        keycap.variants = element.dataset.variants;
      if (element.hasAttribute("data-aside"))
        keycap.aside = element.dataset.aside;
      if (element.className)
        keycap.class = element.className;
      if (!keycap.label && !keycap.latex && !keycap.key && !keycap.insert) {
        keycap.latex = element.innerText;
        keycap.label = element.innerHTML;
      }
      if (element.hasAttribute("data-command")) {
        try {
          keycap.command = JSON.parse(element.dataset.command);
        } catch (e) {
        }
      }
      element.id = VirtualKeyboard.singleton.registerKeycap(keycap);
    }
    if (!element.innerHTML) {
      const [markup, _] = renderKeycap(keycap);
      element.innerHTML = window.MathfieldElement.createHTML(markup);
    }
  }
  var gCoreStylesheet2;
  var gVirtualKeyboardStylesheet;
  var gVirtualKeyboardStylesheetHash;
  function injectStylesheets() {
    if (!gVirtualKeyboardStylesheet) {
      if (!gVirtualKeyboardStylesheetHash) {
        gVirtualKeyboardStylesheetHash = hashCode(
          virtual_keyboard_default
        ).toString(36);
      }
      gVirtualKeyboardStylesheet = inject(
        null,
        virtual_keyboard_default,
        gVirtualKeyboardStylesheetHash
      );
    }
    if (!gCoreStylesheet2) {
      gCoreStylesheet2 = inject(
        null,
        core_default,
        hashCode(core_default).toString(36)
      );
      void loadFonts();
    }
  }
  function releaseStylesheets() {
    gCoreStylesheet2 == null ? void 0 : gCoreStylesheet2.release();
    gCoreStylesheet2 = null;
    gVirtualKeyboardStylesheet == null ? void 0 : gVirtualKeyboardStylesheet.release();
    gVirtualKeyboardStylesheet = null;
  }
  var SVG_ICONS = `<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">

<symbol id="svg-delete-backward" viewBox="0 0 576 512">
  <path d="M432.1 208.1L385.9 256L432.1 303C442.3 312.4 442.3 327.6 432.1 336.1C423.6 346.3 408.4 346.3 399 336.1L352 289.9L304.1 336.1C295.6 346.3 280.4 346.3 271 336.1C261.7 327.6 261.7 312.4 271 303L318.1 256L271 208.1C261.7 199.6 261.7 184.4 271 175C280.4 165.7 295.6 165.7 304.1 175L352 222.1L399 175C408.4 165.7 423.6 165.7 432.1 175C442.3 184.4 442.3 199.6 432.1 208.1V208.1zM512 64C547.3 64 576 92.65 576 128V384C576 419.3 547.3 448 512 448H205.3C188.3 448 172 441.3 160 429.3L9.372 278.6C3.371 272.6 0 264.5 0 256C0 247.5 3.372 239.4 9.372 233.4L160 82.75C172 70.74 188.3 64 205.3 64L512 64zM528 128C528 119.2 520.8 112 512 112H205.3C201 112 196.9 113.7 193.9 116.7L54.63 256L193.9 395.3C196.9 398.3 201 400 205.3 400H512C520.8 400 528 392.8 528 384V128z"/>
</symbol>

<symbol id="svg-shift" viewBox="0 0 384 512">
  <path d="M2.438 252.3C7.391 264.2 19.06 272 32 272h80v160c0 26.51 21.49 48 48 48h64C250.5 480 272 458.5 272 432v-160H352c12.94 0 24.61-7.797 29.56-19.75c4.953-11.97 2.219-25.72-6.938-34.88l-160-176C208.4 35.13 200.2 32 192 32S175.6 35.13 169.4 41.38l-160 176C.2188 226.5-2.516 240.3 2.438 252.3zM192 86.63L313.4 224H224v208H160V224H70.63L192 86.63z"/>
</symbol>

<symbol id="svg-commit" viewBox="0 0 512 512">
  <path d="M135 432.1l-128-128C2.344 300.3 0 294.2 0 288s2.344-12.28 7.031-16.97l128-128c9.375-9.375 24.56-9.375 33.94 0s9.375 24.56 0 33.94L81.94 264H464v-208C464 42.75 474.8 32 488 32S512 42.75 512 56V288c0 13.25-10.75 24-24 24H81.94l87.03 87.03c9.375 9.375 9.375 24.56 0 33.94S144.4 442.3 135 432.1z"/>
</symbol>

<symbol id="svg-command" viewBox="0 0 640 512">
  <path d="M34.495 36.465l211.051 211.05c4.686 4.686 4.686 12.284 0 16.971L34.495 475.535c-4.686 4.686-12.284 4.686-16.97 0l-7.071-7.07c-4.686-4.686-4.686-12.284 0-16.971L205.947 256 10.454 60.506c-4.686-4.686-4.686-12.284 0-16.971l7.071-7.07c4.686-4.687 12.284-4.687 16.97 0zM640 468v-10c0-6.627-5.373-12-12-12H300c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h328c6.627 0 12-5.373 12-12z"/>
</symbol>

<symbol id="svg-undo" viewBox="0 0 512 512">
  <path d="M20 8h10c6.627 0 12 5.373 12 12v110.625C85.196 57.047 165.239 7.715 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.834 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l7.069-7.069c4.503-4.503 11.749-4.714 16.482-.454C150.782 449.238 200.935 470 256 470c117.744 0 214-95.331 214-214 0-117.744-95.331-214-214-214-82.862 0-154.737 47.077-190.289 116H180c6.627 0 12 5.373 12 12v10c0 6.627-5.373 12-12 12H20c-6.627 0-12-5.373-12-12V20c0-6.627 5.373-12 12-12z"/>
</symbol>
<symbol id="svg-redo" viewBox="0 0 512 512">
  <path d="M492 8h-10c-6.627 0-12 5.373-12 12v110.625C426.804 57.047 346.761 7.715 255.207 8.001 118.82 8.428 7.787 120.009 8 256.396 8.214 393.181 119.166 504 256 504c63.926 0 122.202-24.187 166.178-63.908 5.113-4.618 5.354-12.561.482-17.433l-7.069-7.069c-4.503-4.503-11.749-4.714-16.482-.454C361.218 449.238 311.065 470 256 470c-117.744 0-214-95.331-214-214 0-117.744 95.331-214 214-214 82.862 0 154.737 47.077 190.289 116H332c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h160c6.627 0 12-5.373 12-12V20c0-6.627-5.373-12-12-12z"/>
</symbol>
<symbol id="svg-arrow-left" viewBox="0 0 320 512">
  <path d="M206.7 464.6l-183.1-191.1C18.22 267.1 16 261.1 16 256s2.219-11.97 6.688-16.59l183.1-191.1c9.152-9.594 24.34-9.906 33.9-.7187c9.625 9.125 9.938 24.37 .7187 33.91L73.24 256l168 175.4c9.219 9.5 8.906 24.78-.7187 33.91C231 474.5 215.8 474.2 206.7 464.6z"/>
</symbol>
<symbol id="svg-arrow-right" viewBox="0 0 320 512">
  <path d="M113.3 47.41l183.1 191.1c4.469 4.625 6.688 10.62 6.688 16.59s-2.219 11.97-6.688 16.59l-183.1 191.1c-9.152 9.594-24.34 9.906-33.9 .7187c-9.625-9.125-9.938-24.38-.7187-33.91l168-175.4L78.71 80.6c-9.219-9.5-8.906-24.78 .7187-33.91C88.99 37.5 104.2 37.82 113.3 47.41z"/>
</symbol>
<symbol id="svg-tab" viewBox="0 0 448 512">
  <path d="M32 217.1c0-8.8 7.2-16 16-16h144v-93.9c0-7.1 8.6-10.7 13.6-5.7l143.5 143.1c6.3 6.3 6.3 16.4 0 22.7L205.6 410.4c-5 5-13.6 1.5-13.6-5.7v-93.9H48c-8.8 0-16-7.2-16-16v-77.7m-32 0v77.7c0 26.5 21.5 48 48 48h112v61.9c0 35.5 43 53.5 68.2 28.3l143.6-143c18.8-18.8 18.8-49.2 0-68L228.2 78.9c-25.1-25.1-68.2-7.3-68.2 28.3v61.9H48c-26.5 0-48 21.6-48 48zM436 64h-8c-6.6 0-12 5.4-12 12v360c0 6.6 5.4 12 12 12h8c6.6 0 12-5.4 12-12V76c0-6.6-5.4-12-12-12z"/>
</symbol>
<symbol id="svg-paste" viewBox="0 0 512 512"><path d="M160 32c11.6 0 21.3 8.2 23.5 19.2C185 58.6 191.6 64 199.2 64H208c8.8 0 16 7.2 16 16V96H96V80c0-8.8 7.2-16 16-16h8.8c7.6 0 14.2-5.4 15.7-12.8C138.7 40.2 148.4 32 160 32zM64 64h2.7C65 69 64 74.4 64 80V96c0 17.7 14.3 32 32 32H224c17.7 0 32-14.3 32-32V80c0-5.6-1-11-2.7-16H256c17.7 0 32 14.3 32 32h32c0-35.3-28.7-64-64-64H210.6c-9-18.9-28.3-32-50.6-32s-41.6 13.1-50.6 32H64C28.7 32 0 60.7 0 96V384c0 35.3 28.7 64 64 64H192V416H64c-17.7 0-32-14.3-32-32V96c0-17.7 14.3-32 32-32zM288 480c-17.7 0-32-14.3-32-32V192c0-17.7 14.3-32 32-32h96v56c0 22.1 17.9 40 40 40h56V448c0 17.7-14.3 32-32 32H288zM416 165.3L474.7 224H424c-4.4 0-8-3.6-8-8V165.3zM448 512c35.3 0 64-28.7 64-64V235.9c0-12.7-5.1-24.9-14.1-33.9l-59.9-59.9c-9-9-21.2-14.1-33.9-14.1H288c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H448z"/></symbol>
<symbol id="svg-cut" viewBox="0 0 512 512"><path d="M485.6 444.2L333.6 314.9C326.9 309.2 326.1 299.1 331.8 292.4C337.5 285.6 347.6 284.8 354.4 290.5L506.4 419.8C513.1 425.5 513.9 435.6 508.2 442.4C502.5 449.1 492.4 449.9 485.6 444.2zM485.7 67.76C492.5 62.07 502.5 62.94 508.2 69.69C513.9 76.45 513.1 86.55 506.3 92.24L208.5 343.1C218.3 359.7 224 379.2 224 400C224 461.9 173.9 512 112 512C50.14 512 0 461.9 0 400C0 338.1 50.14 288 112 288C141.5 288 168.4 299.4 188.4 318.1L262.2 256L188.4 193.9C168.4 212.6 141.5 224 112 224C50.14 224 0 173.9 0 112C0 50.14 50.14 0 112 0C173.9 0 224 50.14 224 112C224 132.8 218.3 152.3 208.5 168.9L287 235.1L485.7 67.76zM32 112C32 156.2 67.82 192 112 192C156.2 192 192 156.2 192 112C192 67.82 156.2 32 112 32C67.82 32 32 67.82 32 112zM112 480C156.2 480 192 444.2 192 400C192 355.8 156.2 320 112 320C67.82 320 32 355.8 32 400C32 444.2 67.82 480 112 480z"/></symbol>
<symbol id="svg-copy" viewBox="0 0 512 512"><path d="M272 416C263.2 416 256 423.2 256 432V448c0 17.67-14.33 32-32 32H64c-17.67 0-32-14.33-32-32V192c0-17.67 14.33-32 32-32h112C184.8 160 192 152.8 192 144C192 135.2 184.8 128 176 128H63.99c-35.35 0-64 28.65-64 64l.0098 256C0 483.3 28.65 512 64 512h160c35.35 0 64-28.65 64-64v-16C288 423.2 280.8 416 272 416zM502.6 86.63l-77.25-77.25C419.4 3.371 411.2 0 402.7 0H288C252.7 0 224 28.65 224 64v256c0 35.35 28.65 64 64 64h160c35.35 0 64-28.65 64-64V109.3C512 100.8 508.6 92.63 502.6 86.63zM416 45.25L466.7 96H416V45.25zM480 320c0 17.67-14.33 32-32 32h-160c-17.67 0-32-14.33-32-32V64c0-17.67 14.33-32 32-32h96l.0026 64c0 17.67 14.33 32 32 32H480V320z"/>
</symbol>
<symbol id="svg-angle-double-right" viewBox="0 0 512 512"><path d="M470.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 256 265.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160zm-352 160l160-160c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L210.7 256 73.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"/>
</symbol>
<symbol id="svg-angle-double-left" viewBox="0 0 512 512"><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160zm352-160l-160 160c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L301.3 256 438.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0z"/>
</symbol>
<symbol id="svg-trash" viewBox="0 0 448 512">
  <path d="M336 64l-33.6-44.8C293.3 7.1 279.1 0 264 0h-80c-15.1 0-29.3 7.1-38.4 19.2L112 64H24C10.7 64 0 74.7 0 88v2c0 3.3 2.7 6 6 6h26v368c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V96h26c3.3 0 6-2.7 6-6v-2c0-13.3-10.7-24-24-24h-88zM184 32h80c5 0 9.8 2.4 12.8 6.4L296 64H152l19.2-25.6c3-4 7.8-6.4 12.8-6.4zm200 432c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V96h320v368zm-176-44V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm-80 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm160 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12z"/>
</symbol>
<symbol id="svg-keyboard-down" viewBox="0 0 576 512"><path d="M64 48c-8.8 0-16 7.2-16 16V240c0 8.8 7.2 16 16 16H512c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H64zM0 64C0 28.7 28.7 0 64 0H512c35.3 0 64 28.7 64 64V240c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V64zM159 359c9.4-9.4 24.6-9.4 33.9 0l95 95 95-95c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9L305 505c-4.5 4.5-10.6 7-17 7s-12.5-2.5-17-7L159 393c-9.4-9.4-9.4-24.6 0-33.9zm1-167c0-8.8 7.2-16 16-16H400c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V192zM120 88h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H120c-8.8 0-16-7.2-16-16V104c0-8.8 7.2-16 16-16zm64 16c0-8.8 7.2-16 16-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H200c-8.8 0-16-7.2-16-16V104zm96-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H280c-8.8 0-16-7.2-16-16V104c0-8.8 7.2-16 16-16zm64 16c0-8.8 7.2-16 16-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H360c-8.8 0-16-7.2-16-16V104zm96-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H440c-8.8 0-16-7.2-16-16V104c0-8.8 7.2-16 16-16z"/></symbol>
</svg>`;
  function makeKeyboardElement(keyboard) {
    keyboard.resetKeycapRegistry();
    injectStylesheets();
    const result = document.createElement("div");
    result.className = "ML__keyboard";
    const plate = document.createElement("div");
    plate.className = "MLK__plate";
    plate.innerHTML = window.MathfieldElement.createHTML(
      SVG_ICONS + keyboard.normalizedLayouts.map((x, i) => makeLayout(keyboard, x, i)).join("")
    );
    const backdrop = document.createElement("div");
    backdrop.className = "MLK__backdrop";
    backdrop.appendChild(plate);
    result.appendChild(backdrop);
    result.addEventListener("pointerdown", handlePointerDown, { passive: false });
    const toolbars = result.querySelectorAll(".ML__edit-toolbar");
    if (toolbars) {
      for (const toolbar of toolbars) {
        toolbar.addEventListener("click", (ev) => {
          var _a3, _b3;
          let target = ev.target;
          let command = "";
          while (target && !command) {
            command = (_a3 = target == null ? void 0 : target.getAttribute("data-command")) != null ? _a3 : "";
            target = (_b3 = target == null ? void 0 : target.parentElement) != null ? _b3 : null;
          }
          if (command)
            keyboard.executeCommand(JSON.parse(command));
        });
      }
    }
    makeSyntheticKeycaps(
      result.querySelectorAll(
        ".MLK__keycap, .action, .fnbutton, .bigfnbutton"
      )
    );
    const layerElements = result.querySelectorAll(".MLK__layer");
    console.assert(layerElements.length > 0, "No virtual keyboards available");
    for (const x of layerElements)
      x.addEventListener("pointerdown", (evt) => evt.preventDefault());
    keyboard.currentLayer = keyboard.latentLayer;
    return result;
  }
  function makeLayout(keyboard, layout, index) {
    const markup = [];
    if (!("layers" in layout))
      return "";
    for (const layer of layout.layers) {
      markup.push(`<div tabindex="-1" class="MLK__layer" id="${layer.id}">`);
      markup.push(`<div class='MLK__toolbar' role='toolbar'>`);
      markup.push(makeLayoutsToolbar(keyboard, index));
      if (layout.displayEditToolbar)
        markup.push(`<div class="ML__edit-toolbar right"></div>`);
      markup.push(`</div>`);
      markup.push(makeLayer(keyboard, layer));
      markup.push("</div>");
    }
    return markup.join("");
  }
  function makeLayer(keyboard, layer) {
    if (typeof layer === "string")
      return layer;
    let layerMarkup = "";
    if (typeof layer.style === "string")
      layerMarkup += `<style>${layer.style}</style>`;
    else if (typeof layer.style === "object")
      layerMarkup += `<style>${jsonToCss(layer.style)}</style>`;
    if (layer.backdrop)
      layerMarkup += `<div class='${layer.backdrop}'>`;
    if (layer.container)
      layerMarkup += `<div class='${layer.container}'>`;
    if (layer.rows) {
      layerMarkup += `<div class='MLK__rows'>`;
      for (const row of layer.rows) {
        layerMarkup += `<div class=row>`;
        for (const keycap of row) {
          if (keycap) {
            const keycapId = keyboard.registerKeycap(keycap);
            const [markup, cls] = renderKeycap(keycap);
            if (/(^|\s)separator/.test(cls))
              layerMarkup += `<div class="${cls}"`;
            else
              layerMarkup += `<div tabindex="-1" id="${keycapId}" class="${cls}"`;
            if (keycap.tooltip)
              layerMarkup += ` data-tooltip="${keycap.tooltip}"`;
            layerMarkup += `>${markup}</div>`;
          }
        }
        layerMarkup += `</div>`;
      }
      layerMarkup += `</div>`;
    } else if (layer.markup)
      layerMarkup += layer.markup;
    if (layer.container)
      layerMarkup += "</div>";
    if (layer.backdrop)
      layerMarkup += "</div>";
    return layerMarkup;
  }
  function renderKeycap(keycap, options = { shifted: false }) {
    var _a3, _b3, _c2, _d2, _e, _f, _g;
    let markup = "";
    let cls = (_a3 = keycap.class) != null ? _a3 : "";
    if (options.shifted && /(^|\s)shift($|\s)/.test(cls))
      cls += " is-active";
    if (options.shifted && "shift" in keycap) {
      if (typeof keycap.shift === "string")
        markup = latexToMarkup2(keycap.shift);
      else if (typeof keycap.shift === "object") {
        markup = keycap.shift.label ? keycap.shift.label : (_b3 = latexToMarkup2(keycap.shift.latex || keycap.shift.insert || "") || keycap.shift.key) != null ? _b3 : "";
      }
      if (typeof keycap.shift === "object")
        cls = (_d2 = (_c2 = keycap.shift.class) != null ? _c2 : keycap.class) != null ? _d2 : "";
    } else {
      markup = keycap.label ? keycap.label : (_e = latexToMarkup2(keycap.latex || keycap.insert || "") || keycap.key) != null ? _e : "";
      if (keycap.shift) {
        let shiftLabel;
        if (typeof keycap.shift === "string")
          shiftLabel = latexToMarkup2(keycap.shift);
        else if (keycap.shift.label)
          shiftLabel = keycap.shift.label;
        else {
          shiftLabel = (_f = latexToMarkup2(keycap.shift.latex || keycap.shift.insert || "") || keycap.shift.key) != null ? _f : "";
        }
        markup += `<span class="MLK__shift">${shiftLabel}</span>`;
      }
      if (keycap.aside)
        markup += `<aside>${keycap.aside}</aside>`;
    }
    if (keycap.layer && !/layer-switch/.test(cls))
      cls += " layer-switch";
    if (!/(^|\s)(separator|action|shift|fnbutton|bigfnbutton)($|\s)/.test(cls))
      cls += " MLK__keycap";
    if (!/\bw[0-9]+\b/.test(cls) && keycap.width) {
      cls += (_g = { 0: " w0", 0.5: " w5", 1.5: " w15", 2: " w20", 5: " w50" }[keycap.width]) != null ? _g : "";
    }
    return [markup, cls || "MLK__keycap"];
  }
  var KEYCAP_SHORTCUTS = {
    "[left]": {
      class: "action hide-shift",
      label: "<svg class=svg-glyph><use xlink:href=#svg-arrow-left /></svg>",
      command: ["performWithFeedback", "moveToPreviousChar"],
      shift: {
        label: "<svg class=svg-glyph><use xlink:href=#svg-angle-double-left /></svg>",
        command: ["performWithFeedback", "extendSelectionBackward"]
      }
    },
    "[right]": {
      class: "action hide-shift",
      label: "<svg class=svg-glyph><use xlink:href=#svg-arrow-right /></svg>",
      command: ["performWithFeedback", "moveToNextChar"],
      shift: {
        label: "<svg class=svg-glyph><use xlink:href=#svg-angle-double-right /></svg>",
        command: ["performWithFeedback", "extendSelectionForward"]
      }
    },
    "[return]": {
      class: "action",
      command: ["performWithFeedback", "commit"],
      width: 1.5,
      label: "<svg class=svg-glyph><use xlink:href=#svg-commit /></svg>"
    },
    "[action]": {
      class: "action",
      command: ["performWithFeedback", "commit"],
      width: 1.5,
      label: "<svg class=svg-glyph><use xlink:href=#svg-commit /></svg>"
    },
    "[hr]": {
      class: "separator horizontal-rule"
    },
    "[hide-keyboard]": {
      class: "action",
      command: ["performWithFeedback", "hideVirtualKeyboard"],
      width: 1.5,
      label: "<svg class=svg-glyph-lg><use xlink:href=#svg-keyboard-down /></svg>"
    },
    "[.]": {
      variants: ".",
      command: "insertDecimalSeparator",
      shift: ",",
      class: "big-op hide-shift"
    },
    "[+]": {
      variants: [{ latex: "\\sum_{#0}^{#0}", class: "small" }, "\\oplus"],
      latex: "+",
      label: "+",
      class: "big-op hide-shift",
      shift: {
        latex: "\\sum",
        insert: "\\sum_{#?}^{#?}",
        class: "small"
      }
    },
    "[-]": {
      variants: ["\\pm", "\\ominus"],
      latex: "-",
      label: "&#x2212;",
      shift: "\\pm",
      class: "big-op hide-shift"
    },
    "[/]": {
      class: "big-op hide-shift",
      shift: { class: "", latex: "\\frac{1}{#@}" },
      variants: ["/", "\\div", "\\%", "\\oslash"],
      latex: "\\frac{#@}{#?}",
      label: "&divide;"
    },
    "[*]": {
      variants: [{ latex: "\\prod_{#0}^{#0}", class: "small" }, "\\otimes"],
      latex: "\\times",
      label: "&times;",
      shift: {
        latex: "\\prod",
        insert: "\\prod_{#?}^{#?}",
        class: "small"
      },
      class: "big-op hide-shift"
    },
    "[=]": {
      variants: [
        "\\neq",
        "\\equiv",
        "\\varpropto",
        "\\thickapprox",
        "\\lt",
        "\\gt",
        "\\le",
        "\\ge"
      ],
      latex: "=",
      label: "=",
      shift: { label: "\u2260", latex: "\\ne" },
      class: "big-op hide-shift"
    },
    "[backspace]": {
      class: "action bottom right hide-shift",
      width: 1.5,
      command: ["performWithFeedback", "deleteBackward"],
      label: "<svg class=svg-glyph><use xlink:href=#svg-delete-backward /></svg>",
      shift: {
        class: "action warning",
        label: "<svg class=svg-glyph><use xlink:href=#svg-trash /></svg>",
        command: "deleteAll"
      }
    },
    "[undo]": {
      class: "ghost if-can-undo",
      command: "undo",
      label: "<svg class=svg-glyph><use xlink:href=#svg-undo /></svg>",
      tooltip: localize("tooltip.undo")
    },
    "[redo]": {
      class: "ghost  if-can-redo",
      command: "redo",
      label: "<svg class=svg-glyph><use xlink:href=#svg-redo /></svg>"
    },
    "[(]": {
      variants: ["\\lbrack", "\\langle", "\\lfloor", "\\lceil", "\\lbrace"],
      latex: "(",
      label: "(",
      shift: { label: "[", latex: "\\lbrack" },
      class: "hide-shift"
    },
    "[)]": {
      variants: ["\\rbrack", "\\rangle", "\\rfloor", "\\rceil", "\\rbrace"],
      latex: ")",
      label: ")",
      shift: { label: "]", latex: "\\rbrack" },
      class: "hide-shift"
    },
    "[0]": {
      variants: "0",
      latex: "0",
      label: "0",
      shift: "\\infty",
      class: "hide-shift"
    },
    "[1]": {
      variants: "1",
      latex: "1",
      label: "1",
      shift: "#@^{-1}",
      class: "hide-shift"
    },
    "[2]": {
      variants: "2",
      latex: "2",
      label: "2",
      shift: "#@^2",
      class: "hide-shift"
    },
    "[3]": {
      variants: "3",
      latex: "3",
      label: "3",
      shift: "#@^3",
      class: "hide-shift"
    },
    "[4]": {
      variants: "4",
      latex: "4",
      label: "4",
      shift: "#@^4",
      class: "hide-shift"
    },
    "[5]": {
      variants: "5",
      latex: "5",
      label: "5",
      shift: "#@^5",
      class: "hide-shift"
    },
    "[6]": {
      variants: "6",
      latex: "6",
      label: "6",
      shift: "#@^6",
      class: "hide-shift"
    },
    "[7]": {
      variants: "7",
      latex: "7",
      label: "7",
      shift: "#@^7",
      class: "hide-shift"
    },
    "[8]": {
      variants: "8",
      latex: "8",
      label: "8",
      shift: "#@^8",
      class: "hide-shift"
    },
    "[9]": {
      variants: "9",
      latex: "9",
      label: "9",
      shift: "#@^9",
      class: "hide-shift"
    },
    "[separator-5]": { class: "separator", width: 0.5 },
    "[separator]": { class: "separator" },
    "[separator-10]": { class: "separator" },
    "[separator-15]": { class: "separator", width: 1.5 },
    "[separator-20]": { class: "separator", width: 2 },
    "[separator-50]": { class: "separator", width: 5 },
    "[shift]": {
      class: "shift bottom left",
      width: 1.5,
      label: "<span class=caps-lock-indicator></span><svg class=svg-glyph><use xlink:href=#svg-shift /></svg>"
    },
    "[foreground-color]": {
      variants: "foreground-color",
      command: ["applyStyle", { color: "red" }],
      label: "<span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428; box-sizing: border-box'>"
    },
    "[background-color]": {
      variants: "background-color",
      command: ["applyStyle", { backgroundColor: "yellow" }],
      label: "<span style='border-radius: 50%;width:22px;height:22px; background:#fff590; box-sizing: border-box'></span>"
    }
  };
  function normalizeKeycap(keycap) {
    var _a3;
    if (typeof keycap === "string") {
      if (!KEYCAP_SHORTCUTS[keycap])
        return { latex: keycap };
      keycap = { label: keycap };
    }
    if ("label" in keycap && keycap.label && KEYCAP_SHORTCUTS[keycap.label]) {
      let shortcut = __spreadProps(__spreadValues(__spreadValues({}, KEYCAP_SHORTCUTS[keycap.label]), keycap), {
        label: KEYCAP_SHORTCUTS[keycap.label].label
      });
      if (shortcut.command === "insertDecimalSeparator")
        shortcut.label = (_a3 = window.MathfieldElement.decimalSeparator) != null ? _a3 : ".";
      if (keycap.label === "[action]") {
        shortcut = __spreadValues(__spreadValues({}, shortcut), window.mathVirtualKeyboard.actionKeycap);
      }
      if (keycap.label === "[shift]") {
        shortcut = __spreadValues(__spreadValues({}, shortcut), window.mathVirtualKeyboard.shiftKeycap);
      }
      if (keycap.label === "[backspace]") {
        shortcut = __spreadValues(__spreadValues({}, shortcut), window.mathVirtualKeyboard.backspaceKeycap);
      }
      if (keycap.label === "[tab]") {
        shortcut = __spreadValues(__spreadValues({}, shortcut), window.mathVirtualKeyboard.tabKeycap);
      }
      return shortcut;
    }
    return keycap;
  }
  var pressAndHoldTimer;
  function handlePointerDown(ev) {
    var _a3;
    if (ev.button !== 0)
      return;
    const keyboard = VirtualKeyboard.singleton;
    let layerButton = ev.target;
    while (layerButton && !layerButton.getAttribute("data-layer"))
      layerButton = layerButton.parentElement;
    if (layerButton) {
      keyboard.currentLayer = (_a3 = layerButton.getAttribute("data-layer")) != null ? _a3 : "";
      ev.preventDefault();
      return;
    }
    const target = parentKeycap(ev.target);
    if (!(target == null ? void 0 : target.id))
      return;
    const keycap = keyboard.getKeycap(target.id);
    if (!keycap)
      return;
    console.assert(ev.type === "pointerdown");
    const controller = new AbortController();
    target.classList.add("is-pressed");
    target.addEventListener(
      "pointerenter",
      handleVirtualKeyboardEvent(controller),
      {
        capture: true,
        signal: controller.signal
      }
    );
    target.addEventListener(
      "pointerleave",
      handleVirtualKeyboardEvent(controller),
      {
        capture: true,
        signal: controller.signal
      }
    );
    target.addEventListener(
      "pointercancel",
      handleVirtualKeyboardEvent(controller),
      {
        signal: controller.signal
      }
    );
    target.addEventListener("pointerup", handleVirtualKeyboardEvent(controller), {
      signal: controller.signal
    });
    if (keycap.class && /(^|\s)shift($|\s)/.test(keycap.class)) {
      target.classList.add("is-active");
      keyboard.isShifted = true;
    }
    if (keycap.variants) {
      if (pressAndHoldTimer)
        clearTimeout(pressAndHoldTimer);
      pressAndHoldTimer = setTimeout(() => {
        if (target.classList.contains("is-pressed")) {
          target.classList.remove("is-pressed");
          target.classList.add("is-active");
          if (ev.target && "releasePointerCapture" in ev.target)
            ev.target.releasePointerCapture(ev.pointerId);
          showVariantsPanel(target, () => {
            controller.abort();
            target == null ? void 0 : target.classList.remove("is-active");
          });
        }
      }, 200);
    }
    ev.preventDefault();
  }
  function handleVirtualKeyboardEvent(controller) {
    return (ev) => {
      const target = parentKeycap(ev.target);
      if (!(target == null ? void 0 : target.id))
        return;
      const keyboard = VirtualKeyboard.singleton;
      const keycap = keyboard.getKeycap(target.id);
      if (!keycap)
        return;
      if (ev.type === "pointerenter" && ev.target === target) {
        const pev = ev;
        if (pev.isPrimary)
          target.classList.add("is-pressed");
      }
      if (ev.type === "pointercancel") {
        target.classList.remove("is-pressed");
        if (keycap.class && /(^|\s)shift($|\s)/.test(keycap.class)) {
          keyboard.isShifted = false;
          target.classList.toggle("is-active", keyboard.isShifted);
        }
        controller.abort();
        return;
      }
      if (ev.type === "pointerleave" && ev.target === target) {
        target.classList.remove("is-pressed");
        if (keycap.class && /(^|\s)shift($|\s)/.test(keycap.class)) {
          keyboard.isShifted = false;
          target.classList.toggle("is-active", keyboard.isShifted);
        }
        return;
      }
      if (ev.type === "pointerup") {
        if (pressAndHoldTimer)
          clearTimeout(pressAndHoldTimer);
        if (keycap.class && /(^|\s)shift($|\s)/.test(keycap.class)) {
          keyboard.isShifted = false;
          target.classList.toggle("is-active", keyboard.isShifted);
        } else if (target.classList.contains("is-pressed")) {
          target.classList.remove("is-pressed");
          target.classList.add("is-active");
          setTimeout(() => target == null ? void 0 : target.classList.remove("is-active"), 150);
          if (VirtualKeyboard.singleton.isShifted && keycap.shift) {
            if (typeof keycap.shift === "string") {
              VirtualKeyboard.singleton.executeCommand([
                "insert",
                keycap.shift,
                {
                  focus: true,
                  feedback: true,
                  scrollIntoView: true,
                  mode: "math",
                  format: "latex",
                  resetStyle: true
                }
              ]);
            } else
              executeKeycapCommand(keycap.shift);
          } else
            executeKeycapCommand(keycap);
        }
        controller.abort();
        ev.preventDefault();
        return;
      }
    };
  }
  function executeKeycapCommand(keycap) {
    let command = keycap.command;
    if (!command && keycap.insert) {
      command = [
        "insert",
        keycap.insert,
        {
          focus: true,
          feedback: true,
          scrollIntoView: true,
          mode: "math",
          format: "latex",
          resetStyle: true
        }
      ];
    }
    if (!command && keycap.latex) {
      command = [
        "insert",
        keycap.latex,
        {
          focus: true,
          feedback: true,
          scrollIntoView: true,
          mode: "math",
          format: "latex",
          resetStyle: true
        }
      ];
    }
    if (!command) {
      command = [
        "typedText",
        keycap.key || keycap.label,
        { focus: true, feedback: true, simulateKeystroke: true }
      ];
    }
    VirtualKeyboard.singleton.executeCommand(command);
  }
  function isKeycapElement(el) {
    if (el.nodeType !== 1)
      return false;
    const classes = el.classList;
    return classes.contains("MLK__keycap") || classes.contains("shift") || classes.contains("action") || classes.contains("fnbutton") || classes.contains("bigfnbutton");
  }
  function parentKeycap(el) {
    if (!el)
      return void 0;
    let node = el;
    while (node && !isKeycapElement(node))
      node = node.parentNode;
    return node != null ? node : void 0;
  }

  // src/virtual-keyboard/virtual-keyboard.ts
  var VirtualKeyboard = class {
    constructor() {
      this.originalContainerBottomPadding = null;
      this.keycapRegistry = {};
      this._isCapslock = false;
      this._isShifted = false;
      var _a3, _b3, _c2;
      this.targetOrigin = window.origin;
      this.originValidator = "none";
      this._alphabeticLayout = "auto";
      this._layouts = "default";
      this._editToolbar = "default";
      this._container = (_b3 = (_a3 = window.document) == null ? void 0 : _a3.body) != null ? _b3 : null;
      this._visible = false;
      this._dirty = false;
      this.observer = new ResizeObserver((_entries) => {
        this.adjustBoundingRect();
        this.dispatchEvent(new Event("geometrychange"));
        this.sendMessage("geometry-changed", { boundingRect: this.boundingRect });
      });
      this.listeners = {};
      (_c2 = window.top) == null ? void 0 : _c2.addEventListener("message", this);
      document.body.addEventListener("focusin", (event) => {
        var _a4;
        const target = event.target;
        if ((target == null ? void 0 : target.isConnected) && ((_a4 = target.tagName) == null ? void 0 : _a4.toLowerCase()) === "math-field" && isTouchCapable()) {
          const mf = target;
          if (mf.mathVirtualKeyboardPolicy === "auto" && !mf.readOnly)
            this.show({ animate: true });
        }
      });
      document.addEventListener("focusout", (evt) => {
        const target = evt.target;
        if (target.mathVirtualKeyboardPolicy !== "manual") {
          setTimeout(() => {
            var _a4, _b4, _c3;
            let target2 = document.activeElement;
            let focusedMathfield = false;
            while (target2) {
              if (((_a4 = target2.tagName) == null ? void 0 : _a4.toLowerCase()) === "math-field") {
                focusedMathfield = true;
                break;
              }
              target2 = (_c3 = (_b4 = target2.shadowRoot) == null ? void 0 : _b4.activeElement) != null ? _c3 : null;
            }
            if (!focusedMathfield)
              this.hide();
          }, 300);
        }
      });
    }
    get currentLayer() {
      var _a3, _b3, _c2;
      return (_c2 = (_b3 = (_a3 = this._element) == null ? void 0 : _a3.querySelector(".MLK__layer.is-visible")) == null ? void 0 : _b3.id) != null ? _c2 : "";
    }
    set currentLayer(id) {
      var _a3;
      if (!this._element) {
        this.latentLayer = id;
        return;
      }
      let newActive = id ? this._element.querySelector(`#${id}.MLK__layer`) : null;
      if (!newActive)
        newActive = this._element.querySelector(".MLK__layer");
      if (newActive) {
        (_a3 = this._element.querySelector(".MLK__layer.is-visible")) == null ? void 0 : _a3.classList.remove("is-visible");
        newActive.classList.add("is-visible");
      }
    }
    get isCapslock() {
      return this._isCapslock;
    }
    set isCapslock(val) {
      var _a3;
      if (val === this._isCapslock)
        return;
      (_a3 = this._element) == null ? void 0 : _a3.classList.toggle("is-caps-lock", val);
      this._isCapslock = val;
      this.isShifted = val;
    }
    get isShifted() {
      return this._isShifted;
    }
    set isShifted(shifted) {
      if (this._isCapslock)
        shifted = true;
      if (this._isShifted === shifted)
        return;
      this._isShifted = shifted;
      this.render();
    }
    resetKeycapRegistry() {
      this.keycapRegistry = {};
    }
    registerKeycap(keycap) {
      const id = "ML__k" + Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
      this.keycapRegistry[id] = keycap;
      return id;
    }
    getKeycap(id) {
      return id ? this.keycapRegistry[id] : void 0;
    }
    getLayer(id) {
      const layouts = this.normalizedLayouts;
      for (const layout of layouts)
        for (const layer of layout.layers)
          if (layer.id === id)
            return layer;
      return void 0;
    }
    get alphabeticLayout() {
      return this._alphabeticLayout;
    }
    set alphabeticLayout(value) {
      this._alphabeticLayout = value;
      this.rebuild();
    }
    get actionKeycap() {
      return this._actionKeycap;
    }
    set actionKeycap(value) {
      this._actionKeycap = typeof value === "string" ? { label: value } : value;
    }
    get shiftKeycap() {
      return this._shiftKeycap;
    }
    set shiftKeycap(value) {
      this._shiftKeycap = typeof value === "string" ? { label: value } : value;
    }
    get backspaceKeycap() {
      return this._backspaceKeycap;
    }
    set backspaceKeycap(value) {
      this._backspaceKeycap = typeof value === "string" ? { label: value } : value;
    }
    get tabKeycap() {
      return this._tabKeycap;
    }
    set tabKeycap(value) {
      this._tabKeycap = typeof value === "string" ? { label: value } : value;
    }
    get layouts() {
      return this._layouts;
    }
    set layouts(value) {
      this._normalizedLayouts = void 0;
      this._layouts = value;
      this.rebuild();
    }
    get normalizedLayouts() {
      if (!this._normalizedLayouts) {
        const layouts = Array.isArray(this._layouts) ? [...this._layouts] : [this._layouts];
        const defaultIndex = layouts.findIndex((x) => x === "default");
        if (defaultIndex >= 0) {
          layouts.splice(
            defaultIndex,
            1,
            "numeric",
            "symbols",
            "alphabetic",
            "greek"
          );
        }
        this._normalizedLayouts = layouts.map((x) => normalizeLayout(x));
      }
      return this._normalizedLayouts;
    }
    get editToolbar() {
      return this._editToolbar;
    }
    set editToolbar(value) {
      this._editToolbar = value;
      this.rebuild();
    }
    get container() {
      return this._container;
    }
    set container(value) {
      this._container = value;
      this.rebuild();
    }
    static get singleton() {
      if (!this._singleton)
        this._singleton = new VirtualKeyboard();
      return this._singleton;
    }
    addEventListener(type, callback, _options) {
      if (!this.listeners[type])
        this.listeners[type] = /* @__PURE__ */ new Set();
      if (!this.listeners[type].has(callback))
        this.listeners[type].add(callback);
    }
    dispatchEvent(event) {
      if (!this.listeners[event.type] || this.listeners[event.type].size === 0)
        return true;
      this.listeners[event.type].forEach((x) => {
        if (typeof x === "function")
          x(event);
        else
          x == null ? void 0 : x.handleEvent(event);
      });
      return !event.defaultPrevented;
    }
    removeEventListener(type, callback, _options) {
      if (this.listeners[type])
        this.listeners[type].delete(callback);
    }
    get element() {
      return this._element;
    }
    set element(val) {
      var _a3;
      if (this._element === val)
        return;
      (_a3 = this._element) == null ? void 0 : _a3.remove();
      this._element = val;
    }
    get visible() {
      return this._visible;
    }
    set visible(val) {
      if (val)
        this.show();
      else
        this.hide();
    }
    get boundingRect() {
      var _a3;
      if (!this._visible)
        return new DOMRect();
      const plate = (_a3 = this._element) == null ? void 0 : _a3.getElementsByClassName("MLK__plate")[0];
      if (plate)
        return plate.getBoundingClientRect();
      return new DOMRect();
    }
    adjustBoundingRect() {
      var _a3, _b3;
      const h = this.boundingRect.height;
      if (this.container === document.body) {
        (_a3 = this._element) == null ? void 0 : _a3.style.setProperty(
          "--keyboard-height",
          `calc(${h}px + env(safe-area-inset-bottom, 0))`
        );
        const keyboardHeight = h - 1;
        this.container.style.paddingBottom = this.originalContainerBottomPadding ? `calc(${this.originalContainerBottomPadding} + ${keyboardHeight}px)` : `${keyboardHeight}px`;
      } else
        (_b3 = this._element) == null ? void 0 : _b3.style.setProperty("--keyboard-height", `${h}px`);
    }
    rebuild() {
      if (!this._element) {
        this._dirty = false;
        return;
      }
      if (this._dirty)
        return;
      this._dirty = true;
      const currentLayerId = this.currentLayer;
      requestAnimationFrame(() => {
        this._dirty = false;
        if (this._element) {
          this._element.remove();
          this._element = void 0;
        }
        if (this.visible) {
          this.buildAndAttachElement();
          this.adjustBoundingRect();
          this.currentLayer = currentLayerId;
          this.render();
          this._element.classList.add("is-visible");
        }
      });
    }
    /** Update the keycaps to account for the current state */
    render() {
      if (!this._element)
        return;
      const layer = this.getLayer(this.currentLayer);
      this._element.classList.toggle(
        "backdrop-is-transparent",
        Boolean(layer && (layer.backdrop || layer.container))
      );
      const keycaps = this._element.querySelectorAll(
        ".MLK__layer.is-visible .MLK__keycap, .MLK__layer.is-visible .action, .fnbutton, .MLK__layer.is-visible .bigfnbutton, .MLK__layer.is-visible .shift"
      );
      if (!keycaps)
        return;
      for (const keycapElement of keycaps) {
        const keycap = this.getKeycap(keycapElement.id);
        if (keycap) {
          const [markup, cls] = renderKeycap(keycap, { shifted: this.isShifted });
          keycapElement.innerHTML = window.MathfieldElement.createHTML(markup);
          keycapElement.className = cls;
        }
      }
    }
    show(options) {
      if (this._visible)
        return;
      const container = this.container;
      if (!container)
        return;
      if (!this.stateWillChange(true))
        return;
      if (!this._element) {
        this.buildAndAttachElement();
        this.adjustBoundingRect();
      }
      if (!this._visible) {
        const plate = this._element.getElementsByClassName(
          "MLK__plate"
        )[0];
        if (plate)
          this.observer.observe(plate);
        if (container === window.document.body) {
          const padding = container.style.paddingBottom;
          this.originalContainerBottomPadding = padding;
          const keyboardHeight = plate.offsetHeight - 1;
          container.style.paddingBottom = padding ? `calc(${padding} + ${keyboardHeight}px)` : `${keyboardHeight}px`;
        }
        window.addEventListener("mouseup", this);
        window.addEventListener("blur", this);
        window.addEventListener("keydown", this, { capture: true });
        window.addEventListener("keyup", this, { capture: true });
        this.currentLayer = this.latentLayer;
        this.render();
      }
      this._visible = true;
      if (options == null ? void 0 : options.animate) {
        requestAnimationFrame(() => {
          if (this._element) {
            this._element.classList.add("animate");
            this._element.addEventListener(
              "transitionend",
              () => {
                var _a3;
                return (_a3 = this._element) == null ? void 0 : _a3.classList.remove("animate");
              },
              { once: true }
            );
            this._element.classList.add("is-visible");
          }
          this.stateChanged();
        });
      } else {
        this._element.classList.add("is-visible");
        this.stateChanged();
      }
    }
    hide(_options) {
      var _a3;
      const container = this.container;
      if (!container)
        return;
      if (!this._visible)
        return;
      if (!this.stateWillChange(false))
        return;
      this._visible = false;
      if (this._element) {
        this.latentLayer = this.currentLayer;
        const plate = this._element.getElementsByClassName("MLK__plate")[0];
        if (plate)
          this.observer.unobserve(plate);
        window.removeEventListener("mouseup", this);
        window.removeEventListener("blur", this);
        window.removeEventListener("keydown", this, { capture: true });
        window.removeEventListener("keyup", this, { capture: true });
        window.removeEventListener("contextmenu", this, { capture: true });
        hideVariantsPanel();
        releaseStylesheets();
        (_a3 = this._element) == null ? void 0 : _a3.remove();
        this._element = void 0;
        if (this.originalContainerBottomPadding !== null)
          container.style.paddingBottom = this.originalContainerBottomPadding;
      }
      this.stateChanged();
    }
    get height() {
      var _a3, _b3;
      return (_b3 = (_a3 = this.element) == null ? void 0 : _a3.offsetHeight) != null ? _b3 : 0;
    }
    buildAndAttachElement() {
      var _a3;
      console.assert(!this.element);
      this.element = makeKeyboardElement(this);
      window.addEventListener("contextmenu", this, { capture: true });
      this.element.addEventListener(
        "contextmenu",
        (ev) => {
          if (!ev.shiftKey) {
            if (ev.ctrlKey || ev.button === 2)
              showVariantsPanel(ev.target);
            ev.preventDefault();
            ev.stopPropagation();
          }
        },
        { capture: true }
      );
      (_a3 = this.container) == null ? void 0 : _a3.appendChild(this.element);
    }
    handleEvent(evt) {
      if (isVirtualKeyboardMessage(evt)) {
        if (!validateOrigin(evt.origin, this.originValidator)) {
          throw new DOMException(
            `Message from unknown origin (${evt.origin}) cannot be handled`,
            "SecurityError"
          );
        }
        if (evt.data.action === "disconnect")
          this.connectedMathfieldWindow = void 0;
        else if (evt.data.action !== "update-setting" && evt.data.action !== "proxy-created" && evt.data.action !== "execute-command") {
          console.assert(evt.source !== void 0);
          this.connectedMathfieldWindow = evt.source;
        }
        this.handleMessage(evt.data, evt.source);
      }
      if (!this._element)
        return;
      switch (evt.type) {
        case "mouseup":
        case "blur":
          document.body.style.userSelect = "";
          this.isShifted = false;
          break;
        case "contextmenu":
          if (evt.button !== 2)
            evt.preventDefault();
          break;
        case "keydown": {
          const kev = evt;
          this.isCapslock = kev.getModifierState("CapsLock");
          if (kev.key === "Shift")
            this.isShifted = true;
          break;
        }
        case "keyup": {
          const kev = evt;
          if (kev.key === "Shift")
            this.isShifted = false;
          this.isCapslock = kev.getModifierState("CapsLock");
          break;
        }
      }
    }
    handleMessage(msg, source) {
      const { action } = msg;
      if (action === "execute-command") {
        const { command } = msg;
        const commandTarget = getCommandTarget(command);
        if (commandTarget !== "virtual-keyboard" && window === window.parent)
          return;
        this.executeCommand(command);
        return;
      }
      if (action === "connect") {
        this.sendMessage(
          "synchronize-proxy",
          {
            boundingRect: this.boundingRect,
            alphabeticLayout: this._alphabeticLayout,
            layouts: this._layouts,
            editToolbar: this._editToolbar
          },
          source
        );
      }
      if (action === "disconnect")
        return;
      if (window !== window.top)
        return;
      if (action === "show") {
        if (typeof msg.animate !== "undefined")
          this.show({ animate: msg.animate });
        else
          this.show();
        return;
      }
      if (action === "hide") {
        if (typeof msg.animate !== "undefined")
          this.hide({ animate: msg.animate });
        else
          this.hide();
        return;
      }
      if (action === "update-setting") {
        if (msg.alphabeticLayout)
          this.alphabeticLayout = msg.alphabeticLayout;
        if (msg.layouts)
          this.layouts = msg.layouts;
        if (msg.editToolbar)
          this.editToolbar = msg.editToolbar;
        return;
      }
      if (action === "proxy-created") {
        this.sendMessage(
          "synchronize-proxy",
          {
            boundingRect: this.boundingRect,
            alphabeticLayout: this._alphabeticLayout,
            layouts: this._layouts,
            editToolbar: this._editToolbar
          },
          source
        );
        return;
      }
    }
    sendMessage(action, payload, target) {
      if (!target)
        target = this.connectedMathfieldWindow;
      if (this.targetOrigin === null || this.targetOrigin === "null" || target === window) {
        window.dispatchEvent(
          new MessageEvent("message", {
            source: window,
            data: __spreadValues({
              type: VIRTUAL_KEYBOARD_MESSAGE,
              action
            }, payload)
          })
        );
        return;
      }
      target == null ? void 0 : target.postMessage(
        __spreadValues({
          type: VIRTUAL_KEYBOARD_MESSAGE,
          action
        }, payload),
        { targetOrigin: this.targetOrigin }
      );
    }
    stateWillChange(visible) {
      const defaultNotPrevented = this.dispatchEvent(
        new CustomEvent("before-virtual-keyboard-toggle", {
          detail: { visible },
          bubbles: true,
          cancelable: true,
          composed: true
        })
      );
      return defaultNotPrevented;
    }
    stateChanged() {
      this.dispatchEvent(new Event("virtual-keyboard-toggle"));
      this.sendMessage("geometry-changed", {
        boundingRect: this.boundingRect
      });
    }
    /**
     * @category Focus
     */
    focus() {
      this.sendMessage("focus", {});
    }
    /**
     * @category Focus
     */
    blur() {
      this.sendMessage("blur", {});
    }
    updateToolbar(mf) {
      const el = this._element;
      if (!el)
        return;
      el.classList.toggle("can-undo", mf.canUndo);
      el.classList.toggle("can-redo", mf.canRedo);
      el.classList.toggle("can-copy", !mf.selectionIsCollapsed);
      el.classList.toggle("can-copy", !mf.selectionIsCollapsed);
      el.classList.toggle("can-paste", true);
      const toolbars = el.querySelectorAll(".ML__edit-toolbar");
      if (!toolbars)
        return;
      for (const toolbar of toolbars)
        toolbar.innerHTML = makeEditToolbar(this, mf);
    }
    connect() {
      this.connectedMathfieldWindow = window;
    }
    disconnect() {
      this.connectedMathfieldWindow = void 0;
    }
    executeCommand(command) {
      let selector;
      let args = [];
      if (isArray(command)) {
        selector = command[0];
        args = command.slice(1);
      } else
        selector = command;
      selector = selector.replace(
        /-\w/g,
        (m) => m[1].toUpperCase()
      );
      if (getCommandTarget(command) === "virtual-keyboard")
        return COMMANDS[selector].fn(...args);
      this.sendMessage("execute-command", { command });
      return false;
    }
    dispose() {
      window.removeEventListener("mouseup", this);
      window.removeEventListener("blur", this);
      window.removeEventListener("message", this);
    }
  };

  // src/virtual-keyboard/global.ts
  if (isBrowser() && !("mathVirtualKeyboard" in window)) {
    if (window === window["top"]) {
      const kbd = VirtualKeyboard.singleton;
      Object.defineProperty(window, "mathVirtualKeyboard", {
        get: () => kbd
      });
    } else {
      Object.defineProperty(window, "mathVirtualKeyboard", {
        get: () => VirtualKeyboardProxy.singleton,
        configurable: true
      });
    }
  }

  // src/editor/options.ts
  function update(current, updates) {
    const result = get(
      current,
      Object.keys(current)
    );
    for (const key of Object.keys(updates)) {
      switch (key) {
        case "scriptDepth":
          if (isArray(updates.scriptDepth))
            result.scriptDepth = [updates.scriptDepth[0], updates.scriptDepth[1]];
          else if (typeof updates.scriptDepth === "number")
            result.scriptDepth = [updates.scriptDepth, updates.scriptDepth];
          else
            throw new TypeError("Unexpected value for scriptDepth");
          break;
        case "mathVirtualKeyboardPolicy":
          let keyboardPolicy = updates.mathVirtualKeyboardPolicy.toLowerCase();
          if (keyboardPolicy === "sandboxed") {
            if (window !== window["top"]) {
              const kbd = VirtualKeyboard.singleton;
              Object.defineProperty(window, "mathVirtualKeyboard", {
                get: () => kbd
              });
            }
            keyboardPolicy = "manual";
          }
          result.mathVirtualKeyboardPolicy = keyboardPolicy;
          break;
        case "letterShapeStyle":
          if (updates.letterShapeStyle === "auto") {
            if (l10n.locale.startsWith("fr"))
              result.letterShapeStyle = "french";
            else
              result.letterShapeStyle = "tex";
          } else
            result.letterShapeStyle = updates.letterShapeStyle;
          break;
        case "defaultMode":
          if (!["text", "math", "inline-math"].includes(
            updates.defaultMode
          )) {
            console.error(
              `MathLive 0.91.2:  valid values for defaultMode are "text", "math" or "inline-math"`
            );
            result.defaultMode = "math";
          } else
            result.defaultMode = updates.defaultMode;
          break;
        case "macros":
          result.macros = normalizeMacroDictionary(updates.macros);
          break;
        default:
          if (isArray(updates[key]))
            result[key] = [...updates[key]];
          else if (typeof updates[key] === "object")
            result[key] = __spreadValues({}, updates[key]);
          else
            result[key] = updates[key];
      }
    }
    return result;
  }
  function get(config, keys) {
    let resolvedKeys;
    if (typeof keys === "string")
      resolvedKeys = [keys];
    else if (keys === void 0)
      resolvedKeys = Object.keys(config);
    else
      resolvedKeys = keys;
    const result = {};
    for (const x of resolvedKeys) {
      if (config[x] === null)
        result[x] = null;
      else if (isArray(config[x]))
        result[x] = [...config[x]];
      else if (typeof config[x] === "object" && !(config[x] instanceof Element) && x !== "computeEngine") {
        result[x] = __spreadValues({}, config[x]);
      } else
        result[x] = config[x];
    }
    if (typeof keys === "string")
      return result[keys];
    return result;
  }
  function getDefault() {
    return {
      readOnly: false,
      defaultMode: "math",
      macros: getMacros(),
      registers: {},
      colorMap: defaultColorMap,
      backgroundColorMap: defaultBackgroundColorMap,
      letterShapeStyle: l10n.locale.startsWith("fr") ? "french" : "tex",
      smartMode: false,
      smartFence: true,
      smartSuperscript: true,
      scriptDepth: [Infinity, Infinity],
      removeExtraneousParentheses: true,
      mathModeSpace: "",
      placeholderSymbol: "\u25A2",
      popoverPolicy: "auto",
      keybindings: DEFAULT_KEYBINDINGS,
      inlineShortcuts: INLINE_SHORTCUTS,
      inlineShortcutTimeout: 0,
      mathVirtualKeyboardPolicy: "auto",
      virtualKeyboardTargetOrigin: window == null ? void 0 : window.origin,
      originValidator: "none",
      onInlineShortcut: () => "",
      onExport: defaultExportHook,
      value: ""
    };
  }
  function effectiveMode(options) {
    if (options.defaultMode === "inline-math")
      return "math";
    return options.defaultMode;
  }

  // src/editor-model/utils.ts
  function isOffset(value) {
    return typeof value === "number" && !Number.isNaN(value);
  }
  function isRange(value) {
    return Array.isArray(value) && value.length === 2;
  }
  function isSelection(value) {
    return value !== void 0 && value !== null && typeof value === "object" && "ranges" in value && Array.isArray(value.ranges);
  }

  // src/addons/math-ml.ts
  var SPECIAL_OPERATORS = {
    "\\ne": "<mo>&ne;</mo>",
    "\\neq": "<mo>&neq;</mo>",
    "\\pm": "&#177;",
    "\\times": "&#215;",
    "\\colon": ":",
    "\\vert": "|",
    "\\Vert": "\u2225",
    "\\mid": "\u2223",
    "\\lbrace": "{",
    "\\rbrace": "}",
    "\\lparen": "(",
    "\\rparen": ")",
    "\\langle": "\u27E8",
    "\\rangle": "\u27E9",
    "\\lfloor": "\u230A",
    "\\rfloor": "\u230B",
    "\\lceil": "\u2308",
    "\\rceil": "\u2309",
    "\\vec": "&#x20d7;",
    "\\acute": "&#x00b4;",
    "\\grave": "&#x0060;",
    "\\dot": "&#x02d9;",
    "\\ddot": "&#x00a8;",
    "\\tilde": "&#x007e;",
    "\\bar": "&#x00af;",
    "\\breve": "&#x02d8;",
    "\\check": "&#x02c7;",
    "\\hat": "&#x005e;"
  };
  var APPLY_FUNCTION = "<mo>&#x2061;</mo>";
  var INVISIBLE_TIMES = "<mo>&#8290;</mo>";
  function xmlEscape(string) {
    return string.replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function makeID(id, options) {
    if (!id || !options.generateID)
      return "";
    return ` extid="${id}"`;
  }
  function scanIdentifier(stream, final, options) {
    var _a3, _b3, _c2, _d2, _e, _f, _g, _h;
    let result = false;
    final = final != null ? final : stream.atoms.length;
    let mathML = "";
    let body = "";
    let atom = stream.atoms[stream.index];
    if (atom.command === "\\operatorname") {
      body = toString2(atom.body);
      stream.index += 1;
    } else {
      const variant = (_b3 = (_a3 = atom.style) == null ? void 0 : _a3.variant) != null ? _b3 : "";
      const variantStyle = (_d2 = (_c2 = atom.style) == null ? void 0 : _c2.variantStyle) != null ? _d2 : "";
      while (stream.index < final && (atom.type === "mord" || atom.type === "macro") && !atom.isDigit() && variant === ((_f = (_e = atom.style) == null ? void 0 : _e.variant) != null ? _f : "") && variantStyle === ((_h = (_g = atom.style) == null ? void 0 : _g.variantStyle) != null ? _h : "")) {
        body += toString2([atom]);
        stream.index += 1;
        atom = stream.atoms[stream.index];
      }
    }
    if (body.length > 0) {
      result = true;
      mathML = `<mi>${body}</mi>`;
      if ((stream.lastType === "mi" || stream.lastType === "mn" || stream.lastType === "mtext" || stream.lastType === "fence") && !/^<mo>(.*)<\/mo>$/.test(mathML))
        mathML = INVISIBLE_TIMES + mathML;
      if (body.endsWith(">f</mi>") || body.endsWith(">g</mi>")) {
        mathML += APPLY_FUNCTION;
        stream.lastType = "applyfunction";
      } else
        stream.lastType = /^<mo>(.*)<\/mo>$/.test(mathML) ? "mo" : "mi";
      if (!parseSubsup(body, stream, options))
        stream.mathML += mathML;
    }
    return result;
  }
  function isSuperscriptAtom(stream) {
    return stream.index < stream.atoms.length && stream.atoms[stream.index].superscript && stream.atoms[stream.index].type === "msubsup";
  }
  function indexOfSuperscriptInNumber(stream) {
    let result = -1;
    let i = stream.index;
    let done = false;
    let found = false;
    while (i < stream.atoms.length && !done && !found) {
      const atom = stream.atoms[i];
      done = !atom.isDigit();
      found = !done && atom.superscript !== void 0;
      i++;
    }
    if (found)
      result = i - 1;
    return result;
  }
  function parseSubsup(base, stream, options) {
    var _a3;
    let atom = stream.atoms[stream.index - 1];
    if (!atom)
      return false;
    if (!atom.superscript && !atom.subscript) {
      if (((_a3 = stream.atoms[stream.index]) == null ? void 0 : _a3.type) === "msubsup") {
        atom = stream.atoms[stream.index];
        stream.index += 1;
      } else
        return false;
    }
    const superscript = toMathML(atom.superscript, options);
    const subscript = toMathML(atom.subscript, options);
    if (!superscript && !subscript)
      return false;
    let mathML = "";
    if (superscript && subscript)
      mathML = `<msubsup>${base}${subscript}${superscript}</msubsup>`;
    else if (superscript)
      mathML = `<msup>${base}${superscript}</msup>`;
    else if (subscript)
      mathML = `<msub>${base}${subscript}</msub>`;
    stream.mathML += mathML;
    stream.lastType = "";
    return true;
  }
  function scanText(stream, final, options) {
    final = final != null ? final : stream.atoms.length;
    const initial = stream.index;
    let mathML = "";
    while (stream.index < final && stream.atoms[stream.index].mode === "text") {
      mathML += stream.atoms[stream.index].value ? stream.atoms[stream.index].value : " ";
      stream.index += 1;
    }
    if (mathML.length > 0) {
      stream.mathML += `<mtext ${makeID(stream.atoms[initial].id, options)}
      >${mathML}</mtext>`;
      stream.lastType = "mtext";
      return true;
    }
    return false;
  }
  function scanNumber(stream, final, options) {
    final = final != null ? final : stream.atoms.length;
    const initial = stream.index;
    let mathML = "";
    let superscript = indexOfSuperscriptInNumber(stream);
    if (superscript >= 0 && superscript < final)
      final = superscript;
    while (stream.index < final && stream.atoms[stream.index].isDigit()) {
      mathML += stream.atoms[stream.index].asDigit();
      stream.index += 1;
    }
    if (mathML.length <= 0)
      return false;
    mathML = "<mn" + makeID(stream.atoms[initial].id, options) + ">" + mathML + "</mn>";
    if (superscript < 0 && isSuperscriptAtom(stream)) {
      superscript = stream.index;
      stream.index += 1;
    }
    if (!parseSubsup(mathML, stream, options)) {
      stream.mathML += mathML;
      stream.lastType = "mn";
    }
    return true;
  }
  function scanFence(stream, final, options) {
    let result = false;
    final = final != null ? final : stream.atoms.length;
    let mathML = "";
    let lastType = "";
    if (stream.index < final && stream.atoms[stream.index].type === "mopen") {
      let found = false;
      let depth = 0;
      const openIndex = stream.index;
      let closeIndex = -1;
      let index = openIndex + 1;
      while (index < final && !found) {
        if (stream.atoms[index].type === "mopen")
          depth += 1;
        else if (stream.atoms[index].type === "mclose")
          depth -= 1;
        if (depth === -1) {
          found = true;
          closeIndex = index;
        }
        index += 1;
      }
      if (found) {
        mathML = "<mrow>";
        mathML += toMo(stream.atoms[openIndex], options);
        mathML += toMathML(stream.atoms, options, openIndex + 1, closeIndex);
        mathML += toMo(stream.atoms[closeIndex], options);
        mathML += "</mrow>";
        stream.index = closeIndex + 1;
        if (stream.lastType === "mi" || stream.lastType === "mn" || stream.lastType === "mfrac" || stream.lastType === "fence")
          stream.mathML += INVISIBLE_TIMES;
        if (parseSubsup(mathML, stream, options)) {
          result = true;
          stream.lastType = "";
          mathML = "";
        }
        lastType = "fence";
      }
    }
    if (mathML.length > 0) {
      result = true;
      stream.mathML += mathML;
      stream.lastType = lastType;
    }
    return result;
  }
  function scanOperator(stream, final, options) {
    let result = false;
    final = final != null ? final : stream.atoms.length;
    let mathML = "";
    let lastType = "";
    const atom = stream.atoms[stream.index];
    if (stream.index < final && (atom.type === "mbin" || atom.type === "mrel")) {
      mathML += atomToMathML(stream.atoms[stream.index], options);
      stream.index += 1;
      lastType = "mo";
    } else if (stream.index < final && atom.type === "mop") {
      if (atom.subsupPlacement === "over-under" && (atom.superscript || atom.subscript)) {
        const op = toMo(atom, options);
        if (atom.superscript && atom.subscript) {
          mathML += "<munderover>" + op;
          mathML += toMathML(atom.subscript, options);
          mathML += toMathML(atom.superscript, options);
          mathML += "</munderover>";
        } else if (atom.superscript) {
          mathML += "<mover>" + op;
          mathML += toMathML(atom.superscript, options);
          mathML += "</mover>";
        } else if (atom.subscript) {
          mathML += "<munder>" + op;
          mathML += toMathML(atom.subscript, options);
          mathML += "</munder>";
        }
        lastType = "mo";
      } else {
        const atom2 = stream.atoms[stream.index];
        const isUnit = atom2.value === "\\operatorname";
        const op = isUnit ? '<mi class="MathML-Unit"' + makeID(atom2.id, options) + ">" + toString2(atom2.value) + "</mi>" : toMo(atom2, options);
        mathML += op;
        if (!isUnit && !/^<mo>(.*)<\/mo>$/.test(op)) {
          mathML += APPLY_FUNCTION;
          lastType = "applyfunction";
        } else
          lastType = isUnit ? "mi" : "mo";
      }
      if ((stream.lastType === "mi" || stream.lastType === "mn") && !/^<mo>(.*)<\/mo>$/.test(mathML))
        mathML = INVISIBLE_TIMES + mathML;
      stream.index += 1;
    }
    if (mathML.length > 0) {
      result = true;
      if (!parseSubsup(mathML, stream, options)) {
        stream.mathML += mathML;
        stream.lastType = lastType;
      }
    }
    return result;
  }
  function toMathML(input, options, initial, final) {
    options != null ? options : options = {};
    const result = {
      atoms: [],
      index: initial != null ? initial : 0,
      mathML: "",
      lastType: ""
    };
    if (typeof input === "number" || typeof input === "boolean")
      result.mathML = input.toString();
    else if (typeof input === "string")
      result.mathML = input;
    else if (input instanceof Atom)
      result.mathML = atomToMathML(input, options);
    else if (Array.isArray(input)) {
      result.atoms = input;
      let count = 0;
      final = final ? final : input ? input.length : 0;
      while (result.index < final) {
        if (scanText(result, final, options) || scanNumber(result, final, options) || scanIdentifier(result, final, options) || scanOperator(result, final, options) || scanFence(result, final, options))
          count += 1;
        else if (result.index < final) {
          let mathML = atomToMathML(result.atoms[result.index], options);
          if (result.lastType === "mn" && mathML.length > 0 && result.atoms[result.index].type === "genfrac") {
            mathML = "<mo>&#x2064;</mo>" + mathML;
          }
          if (result.atoms[result.index].type === "genfrac")
            result.lastType = "mfrac";
          else
            result.lastType = "";
          result.index += 1;
          if (parseSubsup(mathML, result, options))
            count += 1;
          else {
            if (mathML.length > 0) {
              result.mathML += mathML;
              count += 1;
            }
          }
        }
      }
      if (count > 1)
        result.mathML = "<mrow>" + result.mathML + "</mrow>";
    }
    return result.mathML;
  }
  function toMo(atom, options) {
    let result = "";
    const body = toString2(atom.value);
    if (body)
      result = "<mo" + makeID(atom.id, options) + ">" + body + "</mo>";
    return result;
  }
  function toString2(atoms) {
    if (!atoms)
      return "";
    if (typeof atoms === "string")
      return xmlEscape(atoms);
    if (!Array.isArray(atoms) && typeof atoms.body === "string")
      return xmlEscape(atoms.body);
    let result = "";
    for (const atom of atoms)
      if (typeof atom.value === "string")
        result += atom.value;
    return xmlEscape(result);
  }
  function atomToMathML(atom, options) {
    var _a3, _b3, _c2, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    const SVG_CODE_POINTS = {
      widehat: "^",
      widecheck: "\u02C7",
      widetilde: "~",
      utilde: "~",
      overleftarrow: "\u2190",
      underleftarrow: "\u2190",
      xleftarrow: "\u2190",
      overrightarrow: "\u2192",
      underrightarrow: "\u2192",
      xrightarrow: "\u2192",
      underbrace: "\u23DF",
      overbrace: "\u23DE",
      overgroup: "\u23E0",
      undergroup: "\u23E1",
      overleftrightarrow: "\u2194",
      underleftrightarrow: "\u2194",
      xleftrightarrow: "\u2194",
      Overrightarrow: "\u21D2",
      xRightarrow: "\u21D2",
      overleftharpoon: "\u21BC",
      xleftharpoonup: "\u21BC",
      overrightharpoon: "\u21C0",
      xrightharpoonup: "\u21C0",
      xLeftarrow: "\u21D0",
      xLeftrightarrow: "\u21D4",
      xhookleftarrow: "\u21A9",
      xhookrightarrow: "\u21AA",
      xmapsto: "\u21A6",
      xrightharpoondown: "\u21C1",
      xleftharpoondown: "\u21BD",
      xrightleftharpoons: "\u21CC",
      xleftrightharpoons: "\u21CB",
      xtwoheadleftarrow: "\u219E",
      xtwoheadrightarrow: "\u21A0",
      xlongequal: "=",
      xtofrom: "\u21C4",
      xrightleftarrows: "\u21C4",
      xrightequilibrium: "\u21CC",
      // Not a perfect match.
      xleftequilibrium: "\u21CB"
      // None better available.
    };
    const SPECIAL_IDENTIFIERS2 = {
      "\\exponentialE": "&#x02147;",
      "\\imaginaryI": "&#x2148;",
      "\\differentialD": "&#x2146;",
      "\\capitalDifferentialD": "&#x2145;",
      "\\alpha": "&#x03b1;",
      "\\pi": "&#x03c0;",
      "\\infty": "&#x221e;",
      "\\forall": "&#x2200;",
      "\\nexists": "&#x2204;",
      "\\exists": "&#x2203;",
      "\\hbar": "\u210F",
      "\\cdotp": "\u22C5",
      "\\ldots": "\u2026",
      "\\cdots": "\u22EF",
      "\\ddots": "\u22F1",
      "\\vdots": "\u22EE",
      "\\ldotp": "."
    };
    const MATH_VARIANTS = {
      cal: "script",
      frak: "fraktur",
      bb: "double-struck",
      scr: "script",
      cmtt: "monospace",
      cmss: "sans-serif"
    };
    const SPACING = {
      "\\!": -3 / 18,
      "\\ ": 6 / 18,
      "\\,": 3 / 18,
      "\\:": 4 / 18,
      "\\;": 5 / 18,
      "\\enspace": 0.5,
      "\\quad": 1,
      "\\qquad": 2,
      "\\enskip": 0.5
    };
    let result = "";
    let sep = "";
    let col;
    let row;
    let i;
    let underscript;
    let overscript;
    let body;
    let variant = (_b3 = MATH_VARIANTS[(_a3 = atom.fontFamily) != null ? _a3 : atom.font]) != null ? _b3 : "";
    if (variant)
      variant = ` mathvariant="${variant}"`;
    const { command } = atom;
    if (atom.mode === "text")
      result = `<mi${makeID(atom.id, options)}>${atom.value}</mi>`;
    else {
      switch (atom.type) {
        case "first":
          break;
        case "group":
        case "root":
          if (SPECIAL_OPERATORS[atom.command])
            result = SPECIAL_OPERATORS[atom.command];
          else
            result = toMathML(atom.body, options);
          break;
        case "array":
          if (atom.leftDelim && atom.leftDelim !== "." || atom.rightDelim && atom.rightDelim !== ".") {
            result += "<mrow>";
            if (atom.leftDelim && atom.leftDelim !== ".") {
              result += "<mo>" + (SPECIAL_OPERATORS[atom.leftDelim] || atom.leftDelim) + "</mo>";
            }
          }
          result += "<mtable";
          if (atom.colFormat) {
            result += ' columnalign="';
            for (i = 0; i < atom.colFormat.length; i++) {
              if (atom.colFormat[i].align) {
                result += { l: "left", c: "center", r: "right" }[atom.colFormat[i].align] + " ";
              }
            }
            result += '"';
          }
          result += ">";
          for (row = 0; row < atom.array.length; row++) {
            result += "<mtr>";
            for (col = 0; col < atom.array[row].length; col++) {
              result += "<mtd>" + toMathML(atom.array[row][col], options) + "</mtd>";
            }
            result += "</mtr>";
          }
          result += "</mtable>";
          if (atom.leftDelim && atom.leftDelim !== "." || atom.rightDelim && atom.rightDelim !== ".") {
            if (atom.rightDelim && atom.rightDelim !== ".") {
              result += "<mo>" + (SPECIAL_OPERATORS[atom.leftDelim] || atom.rightDelim) + "</mo>";
            }
            result += "</mrow>";
          }
          break;
        case "genfrac":
          if (atom.leftDelim || atom.rightDelim)
            result += "<mrow>";
          if (atom.leftDelim && atom.leftDelim !== ".") {
            result += "<mo" + makeID(atom.id, options) + ">" + (SPECIAL_OPERATORS[atom.leftDelim] || atom.leftDelim) + "</mo>";
          }
          if (atom.hasBarLine) {
            result += "<mfrac>";
            result += toMathML(atom.above, options) || "<mi>&nbsp;</mi>";
            result += toMathML(atom.below, options) || "<mi>&nbsp;</mi>";
            result += "</mfrac>";
          } else {
            result += "<mtable" + makeID(atom.id, options) + ">";
            result += "<mtr>" + toMathML(atom.above, options) + "</mtr>";
            result += "<mtr>" + toMathML(atom.below, options) + "</mtr>";
            result += "</mtable>";
          }
          if (atom.rightDelim && atom.rightDelim !== ".") {
            result += "<mo" + makeID(atom.id, options) + ">" + (SPECIAL_OPERATORS[atom.rightDelim] || atom.rightDelim) + "</mo>";
          }
          if (atom.leftDelim || atom.rightDelim)
            result += "</mrow>";
          break;
        case "surd":
          if (!atom.hasEmptyBranch("above")) {
            result += "<mroot" + makeID(atom.id, options) + ">";
            result += toMathML(atom.body, options);
            result += toMathML(atom.above, options);
            result += "</mroot>";
          } else {
            result += "<msqrt" + makeID(atom.id, options) + ">";
            result += toMathML(atom.body, options);
            result += "</msqrt>";
          }
          break;
        case "leftright":
          result = "<mrow>";
          if (atom.leftDelim && atom.leftDelim !== ".") {
            result += "<mo" + makeID(atom.id, options) + ">" + ((_c2 = SPECIAL_OPERATORS[atom.leftDelim]) != null ? _c2 : atom.leftDelim) + "</mo>";
          }
          if (atom.body)
            result += toMathML(atom.body, options);
          if (atom.rightDelim && atom.rightDelim !== ".") {
            result += "<mo" + makeID(atom.id, options) + ">" + ((_d2 = SPECIAL_OPERATORS[atom.rightDelim]) != null ? _d2 : atom.rightDelim) + "</mo>";
          }
          result += "</mrow>";
          break;
        case "sizeddelim":
        case "delim":
          result += '<mo separator="true"' + makeID(atom.id, options) + ">" + (SPECIAL_OPERATORS[atom.delim] || atom.delim) + "</mo>";
          break;
        case "accent":
          result += '<mover accent="true"' + makeID(atom.id, options) + ">";
          result += toMathML(atom.body, options);
          result += "<mo>" + (SPECIAL_OPERATORS[command] || atom.accent) + "</mo>";
          result += "</mover>";
          break;
        case "line":
        case "overlap":
          break;
        case "overunder":
          overscript = atom.above;
          underscript = atom.below;
          if ((atom.svgAbove || overscript) && (atom.svgBelow || underscript))
            body = atom.body;
          else if (overscript && overscript.length > 0) {
            body = atom.body;
            if ((_f = (_e = atom.body) == null ? void 0 : _e[0]) == null ? void 0 : _f.below) {
              underscript = atom.body[0].below;
              body = atom.body[0].body;
            } else if (((_h = (_g = atom.body) == null ? void 0 : _g[0]) == null ? void 0 : _h.type) === "first" && ((_j = (_i = atom.body) == null ? void 0 : _i[1]) == null ? void 0 : _j.below)) {
              underscript = atom.body[1].below;
              body = atom.body[1].body;
            }
          } else if (underscript && underscript.length > 0) {
            body = atom.body;
            if ((_l = (_k = atom.body) == null ? void 0 : _k[0]) == null ? void 0 : _l.above) {
              overscript = atom.body[0].above;
              body = atom.body[0].body;
            } else if (((_n = (_m = atom.body) == null ? void 0 : _m[0]) == null ? void 0 : _n.type) === "first" && ((_p = (_o = atom.body) == null ? void 0 : _o[1]) == null ? void 0 : _p.above)) {
              overscript = atom.body[1].overscript;
              body = atom.body[1].body;
            }
          }
          if ((atom.svgAbove || overscript) && (atom.svgBelow || underscript)) {
            result += `<munderover ${variant} ${makeID(atom.id, options)}>`;
            result += (_q = SVG_CODE_POINTS[atom.svgBody]) != null ? _q : toMathML(body, options);
            result += (_r = SVG_CODE_POINTS[atom.svgBelow]) != null ? _r : toMathML(underscript, options);
            result += (_s = SVG_CODE_POINTS[atom.svgAbove]) != null ? _s : toMathML(overscript, options);
            result += "</munderover>";
          } else if (atom.svgAbove || overscript) {
            result += `<mover ${variant} ${makeID(atom.id, options)}>` + ((_t = SVG_CODE_POINTS[atom.svgBody]) != null ? _t : toMathML(body, options));
            result += (_u = SVG_CODE_POINTS[atom.svgAbove]) != null ? _u : toMathML(overscript, options);
            result += "</mover>";
          } else if (atom.svgBelow || underscript) {
            result += `<munder ${variant} ${makeID(atom.id, options)}>` + ((_v = SVG_CODE_POINTS[atom.svgBody]) != null ? _v : toMathML(body, options));
            result += (_w = SVG_CODE_POINTS[atom.svgBelow]) != null ? _w : toMathML(underscript, options);
            result += "</munder>";
          }
          break;
        case "placeholder":
        case "mord": {
          result = SPECIAL_IDENTIFIERS2[command] || command || (typeof atom.value === "string" ? atom.value : "");
          const m = command ? command.match(/{?\\char"([\dabcdefABCDEF]*)}?/) : null;
          if (m) {
            result = "&#x" + m[1] + ";";
          } else if (result.length > 0 && result.startsWith("\\")) {
            if (typeof atom.value === "string" && atom.value.charCodeAt(0) > 255) {
              result = "&#x" + ("000000" + atom.value.charCodeAt(0).toString(16)).slice(-4) + ";";
            } else if (typeof atom.value === "string")
              result = atom.value.charAt(0);
            else {
              console.log("Did not expect this");
              result = "";
            }
          }
          const tag = /\d/.test(result) ? "mn" : "mi";
          result = `<${tag}${variant}${makeID(atom.id, options)}>${xmlEscape(
            result
          )}</${tag}>`;
          break;
        }
        case "mbin":
        case "mrel":
        case "minner":
          if (command && SPECIAL_IDENTIFIERS2[command]) {
            result = "<mi" + makeID(atom.id, options) + ">" + SPECIAL_IDENTIFIERS2[command] + "</mi>";
          } else if (command && SPECIAL_OPERATORS[command]) {
            result = "<mo" + makeID(atom.id, options) + ">" + SPECIAL_OPERATORS[command] + "</mo>";
          } else
            result = toMo(atom, options);
          break;
        case "mpunct":
          result = '<mo separator="true"' + makeID(atom.id, options) + ">" + ((_x = SPECIAL_OPERATORS[command]) != null ? _x : command) + "</mo>";
          break;
        case "mop":
          if (atom.body !== "\u200B") {
            result = "<mo" + makeID(atom.id, options) + ">";
            result += command === "\\operatorname" ? atom.body : command || atom.body;
            result += "</mo>";
          }
          break;
        case "box":
          result = '<menclose notation="box"';
          if (atom.backgroundcolor)
            result += ' mathbackground="' + atom.backgroundcolor + '"';
          result += makeID(atom.id, options) + ">" + toMathML(atom.body, options) + "</menclose>";
          break;
        case "spacing":
          result += '<mspace width="' + ((_y = SPACING[command]) != null ? _y : 0) + 'em"/>';
          break;
        case "enclose":
          result = '<menclose notation="';
          for (const notation in atom.notation) {
            if (Object.prototype.hasOwnProperty.call(atom.notation, notation) && atom.notation[notation]) {
              result += sep + notation;
              sep = " ";
            }
          }
          result += makeID(atom.id, options) + '">' + toMathML(atom.body, options) + "</menclose>";
          break;
        case "prompt":
          result = '<menclose notation="roundexbox""">' + toMathML(atom.body, options) + "</menclose>";
          break;
        case "space":
          result += "&nbsp;";
          break;
        case "msubsup":
          break;
        case "phantom":
          break;
        case "composition":
          break;
        case "rule":
          console.log("In conversion to MathML, unknown type : " + atom.type);
          break;
        case "chem":
          break;
        case "mopen":
          result += toMo(atom, options);
          break;
        case "mclose":
          result += toMo(atom, options);
          break;
        case "macro":
          {
            const body2 = atom.command + toString2(atom.macroArgs);
            if (body2)
              result += `<mo ${makeID(atom.id, options)}>${body2}</mo>`;
          }
          break;
        case "error":
          console.log("In conversion to MathML, unknown type : " + atom.type);
          break;
        case "latexgroup":
          result += toMathML(atom.body, options);
          break;
        case "latex":
          result += "<mtext" + makeID(atom.id, options) + ">" + atom.value + "</mtext>";
          break;
        case "tooltip":
          result += toMathML(atom.body, options);
          break;
        default:
          console.log("In conversion to MathML, unknown type : " + atom.type);
      }
    }
    return result;
  }

  // src/editor/atom-to-ascii-math.ts
  var SPECIAL_IDENTIFIERS = {
    "\\ne": "\u2260",
    "\\neq": "\u2260",
    "\u2212": "-",
    // MINUS SIGN
    "-": "-",
    "\\alpha": "alpha",
    "\\beta": "beta",
    "\\gamma": "gamma",
    "\\delta": "delta",
    "\\epsilon": "epsilon",
    "\\varepsilon": "varepsilon",
    "\\zeta": "zeta",
    "\\eta": "eta",
    "\\theta": "theta",
    "\\vartheta": "vartheta",
    "\\iota": "iota",
    "\\kappa": "kappa",
    "\\lambda": "lambda",
    "\\mu": "mu",
    "\\nu": "nu",
    "\\xi": "xi",
    "\\pi": "pi",
    "\\rho": "rho",
    "\\sigma": "sigma",
    "\\tau": "tau",
    "\\upsilon": "upsilon",
    "\\phi": "phi",
    "\\varphi": "varphi",
    "\\chi": "chi",
    "\\psi": "psi",
    "\\omega": "omega",
    "\\Gamma": "Gamma",
    "\\Delta": "Delta",
    "\\Theta": "Theta",
    "\\Lambda": "Lambda",
    "\\Xi": "Xi",
    "\\Pi": "Pi",
    "\\Sigma": "Sigma",
    "\\Phi": "Phi",
    "\\Psi": "Psi",
    "\\Omega": "Omega",
    "\\exponentialE": "e",
    "\\imaginaryI": "i",
    "\\imaginaryJ": "j",
    "\\!": " ",
    "\\,": " ",
    "\\:": " ",
    "\\;": " ",
    "\\enskip": " ",
    "\\enspace": " ",
    "\\qquad": " ",
    "\\quad": " "
  };
  var SPECIAL_OPERATORS2 = {
    "\\pm": "+-",
    "\\times": "xx",
    "\\colon": ":",
    "\\vert": "|",
    "\\Vert": "||",
    "\\mid": "|",
    "\\lbrace": "{",
    "\\rbrace": "}",
    "\\lparen": "(",
    "\\rparen": ")",
    "\\langle": "(:",
    "\\rangle": ":)"
    // '\\lfloor': '\u230a',
    // '\\rfloor': '\u230b',
    // '\\lceil': '\u2308',
    // '\\rceil': '\u2309',
    // '\\vec': '&#x20d7;',
    // '\\acute': '&#x00b4;',
    // '\\grave': '&#x0060;',
    // '\\dot': '&#x02d9;',
    // '\\ddot': '&#x00a8;',
    // '\\tilde': '&#x007e;',
    // '\\bar': '&#x00af;',
    // '\\breve': '&#x02d8;',
    // '\\check': '&#x02c7;',
    // '\\hat': '&#x005e;'
  };
  function atomToAsciiMath(atom) {
    var _a3, _b3, _c2, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    if (!atom)
      return "";
    if (isArray(atom)) {
      if (atom.length === 0)
        return "";
      if (atom[0].type === "first")
        atom = atom.slice(1);
      if (atom.length === 0)
        return "";
      let result2 = "";
      if (atom[0].mode === "latex")
        for (const x of atom)
          result2 += atomToAsciiMath(x);
      else if (atom[0].mode === "text") {
        let i = 0;
        result2 = '"';
        while (((_a3 = atom[i]) == null ? void 0 : _a3.mode) === "text") {
          result2 += atom[i].body ? atomToAsciiMath(atom[i].body) : atom[i].value;
          i++;
        }
        result2 += '"' + atomToAsciiMath(atom.slice(i));
      } else if (atom[0].mode === "math") {
        let i = 0;
        while (atom[i] && atom[i].mode === "math") {
          result2 += atomToAsciiMath(atom[i]);
          i++;
        }
        result2 += atomToAsciiMath(atom.slice(i));
      } else
        console.warn("toASCIIMath: Unexpected mode");
      return result2.trim();
    }
    if (atom.mode === "text")
      return '"' + atom.value + '"';
    let result = "";
    const { command } = atom;
    let m;
    switch (atom.type) {
      case "first":
        return "";
      case "group":
      case "root":
        result = (_b3 = SPECIAL_IDENTIFIERS[command]) != null ? _b3 : atomToAsciiMath(atom.body);
        break;
      case "genfrac":
        {
          const genfracAtom = atom;
          if (genfracAtom.leftDelim || genfracAtom.rightDelim) {
            result += genfracAtom.leftDelim === "." || !genfracAtom.leftDelim ? "{:" : genfracAtom.leftDelim;
          }
          if (genfracAtom.hasBarLine) {
            result += "(";
            result += atomToAsciiMath(genfracAtom.above);
            result += ")/(";
            result += atomToAsciiMath(genfracAtom.below);
            result += ")";
          } else {
            result += "(" + atomToAsciiMath(genfracAtom.above) + "),";
            result += "(" + atomToAsciiMath(genfracAtom.below) + ")";
          }
          if (genfracAtom.leftDelim || genfracAtom.rightDelim) {
            result += genfracAtom.rightDelim === "." || !genfracAtom.rightDelim ? "{:" : genfracAtom.rightDelim;
          }
        }
        break;
      case "surd":
        result += !atom.hasEmptyBranch("above") ? "root(" + atomToAsciiMath(atom.above) + ")(" + atomToAsciiMath(atom.body) + ")" : "sqrt(" + atomToAsciiMath(atom.body) + ")";
        break;
      case "latex":
        result = atom.value;
        break;
      case "leftright":
        {
          const leftrightAtom = atom;
          result += leftrightAtom.leftDelim === "." || !leftrightAtom.leftDelim ? "{:" : leftrightAtom.leftDelim;
          result += atomToAsciiMath(leftrightAtom.body);
          result += leftrightAtom.rightDelim === "." || !leftrightAtom.rightDelim ? ":}" : leftrightAtom.rightDelim;
        }
        break;
      case "sizeddelim":
      case "delim":
        break;
      case "overlap":
        break;
      case "overunder":
        break;
      case "mord":
        result = (_d2 = (_c2 = SPECIAL_IDENTIFIERS[command]) != null ? _c2 : command) != null ? _d2 : typeof atom.value === "string" ? atom.value : "";
        if (result.startsWith("\\"))
          result += " ";
        m = command ? command.match(/{?\\char"([\dabcdefABCDEF]*)}?/) : null;
        if (m) {
          result = String.fromCodePoint(Number.parseInt("0x" + m[1]));
        } else if (result.length > 0 && result.startsWith("\\")) {
          result = typeof atom.value === "string" ? atom.value.charAt(0) : atom.command;
        }
        break;
      case "mbin":
      case "mrel":
      case "minner":
        result = (_f = (_e = SPECIAL_IDENTIFIERS[command]) != null ? _e : SPECIAL_OPERATORS2[command]) != null ? _f : atom.value;
        break;
      case "mopen":
      case "mclose":
        result += atom.value;
        break;
      case "mpunct":
        result = (_g = SPECIAL_OPERATORS2[command]) != null ? _g : command;
        break;
      case "mop":
        if (atom.value !== "\u200B") {
          result = "";
          result += command === "\\operatorname" ? atomToAsciiMath(atom.body) : (_h = atom.value) != null ? _h : command;
          result += " ";
        }
        break;
      case "array":
        const array = atom.array;
        const environment = atom.environmentName;
        const rowDelim = (_i = {
          "bmatrix": ["[", "]"],
          "bmatrix*": ["[", "]"]
        }[environment]) != null ? _i : ["(", ")"];
        const rows = [];
        for (const row of array) {
          const cells = [];
          for (const cell of row)
            cells.push(rowDelim[0] + atomToAsciiMath(cell) + rowDelim[1]);
          rows.push(cells.join(","));
        }
        const delim = (_j = {
          "bmatrix": ["[", "]"],
          "bmatrix*": ["[", "]"],
          "cases": ["{", ":}"]
        }[environment]) != null ? _j : ["(", ")"];
        result = delim[0] + rows.join(",") + delim[1];
        break;
      case "box":
        break;
      case "spacing":
        result = (_k = SPECIAL_IDENTIFIERS[command]) != null ? _k : " ";
        break;
      case "enclose":
        result = "(" + atomToAsciiMath(atom.body) + ")";
        break;
      case "space":
        result = " ";
        break;
      case "msubsup":
        result = "";
        break;
      case "macro":
        result = (_m = (_l = SPECIAL_IDENTIFIERS[command]) != null ? _l : SPECIAL_OPERATORS2[command]) != null ? _m : atomToAsciiMath(atom.body);
        break;
    }
    if (!atom.hasEmptyBranch("subscript")) {
      result += "_";
      const arg = atomToAsciiMath(atom.subscript);
      result += arg.length > 1 ? "(" + arg + ")" : arg;
    }
    if (!atom.hasEmptyBranch("superscript")) {
      result += "^";
      const arg = atomToAsciiMath(atom.superscript);
      result += arg.length > 1 ? "(" + arg + ")" : arg;
    }
    return result;
  }

  // src/editor/atom-to-speakable-text.ts
  var PRONUNCIATION = {
    "\\alpha": "alpha ",
    "\\mu": "mew ",
    "\\sigma": "sigma ",
    "\\pi": "pie ",
    "\\imaginaryI": "eye ",
    "\\sum": "Summation ",
    "\\prod": "Product ",
    "+": "plus ",
    "-": "minus ",
    ";": '<break time="150ms"/> semi-colon <break time="150ms"/>',
    ",": '<break time="150ms"/> comma  <break time="150ms"/>',
    "|": '<break time="150ms"/>Vertical bar<break time="150ms"/>',
    "(": '<break time="150ms"/>Open paren. <break time="150ms"/>',
    ")": '<break time="150ms"/> Close paren. <break time="150ms"/>',
    "=": "equals ",
    "<": "is less than ",
    "\\lt": "is less than ",
    "<=": "is less than or equal to ",
    "\\le": "is less than or equal to ",
    "\\gt": "is greater than ",
    ">": "is greater than ",
    "\\pm": "plus or minus",
    "\\mp": "minus or plus",
    "\\ge": "is greater than or equal to ",
    "\\geq": "is greater than or equal to ",
    "\\leq": "is less than or equal to ",
    "!": "factorial ",
    "\\sin": "sine ",
    "\\cos": "cosine ",
    "\u200B": "",
    "\u2212": "minus ",
    ":": '<break time="150ms"/> such that <break time="200ms"/> ',
    "\\colon": '<break time="150ms"/> such that <break time="200ms"/> ',
    "\\hbar": "etch bar ",
    "\\iff": '<break time="200ms"/>if, and only if, <break time="200ms"/>',
    "\\Longleftrightarrow": '<break time="200ms"/>if, and only if, <break time="200ms"/>',
    "\\land": "and ",
    "\\lor": "or ",
    "\\neg": "not ",
    "\\div": "divided by ",
    "\\forall": "for all ",
    "\\exists": "there exists ",
    "\\nexists": "there does not exists ",
    "\\in": "element of ",
    "\\N": 'the set <break time="150ms"/><say-as interpret-as="character">n</say-as>',
    "\\C": 'the set <break time="150ms"/><say-as interpret-as="character">c</say-as>',
    "\\Z": 'the set <break time="150ms"/><say-as interpret-as="character">z</say-as>',
    "\\Q": 'the set <break time="150ms"/><say-as interpret-as="character">q</say-as>',
    "\\infty": "infinity ",
    "\\nabla": "nabla ",
    "\\partial": "partial derivative of ",
    "\\cdot": "times ",
    "\\cdots": "dot dot dot ",
    "\\Rightarrow": "implies ",
    "\\lparen": '<break time="150ms"/>open paren<break time="150ms"/>',
    "\\rparen": '<break time="150ms"/>close paren<break time="150ms"/>',
    "\\lbrace": '<break time="150ms"/>open brace<break time="150ms"/>',
    "\\{": '<break time="150ms"/>open brace<break time="150ms"/>',
    "\\rbrace": '<break time="150ms"/>close brace<break time="150ms"/>',
    "\\}": '<break time="150ms"/>close brace<break time="150ms"/>',
    "\\langle": '<break time="150ms"/>left angle bracket<break time="150ms"/>',
    "\\rangle": '<break time="150ms"/>right angle bracket<break time="150ms"/>',
    "\\lfloor": '<break time="150ms"/>open floor<break time="150ms"/>',
    "\\rfloor": '<break time="150ms"/>close floor<break time="150ms"/>',
    "\\lceil": '<break time="150ms"/>open ceiling<break time="150ms"/>',
    "\\rceil": '<break time="150ms"/>close ceiling<break time="150ms"/>',
    "\\vert": '<break time="150ms"/>vertical bar<break time="150ms"/>',
    "\\mvert": '<break time="150ms"/>divides<break time="150ms"/>',
    "\\lvert": '<break time="150ms"/>left vertical bar<break time="150ms"/>',
    "\\rvert": '<break time="150ms"/>right vertical bar<break time="150ms"/>',
    // '\\lbrack':		'left bracket',
    // '\\rbrack':		'right bracket',
    "\\lbrack": '<break time="150ms"/> open square bracket <break time="150ms"/>',
    "\\rbrack": '<break time="150ms"/> close square bracket <break time="150ms"/>',
    // Need to add code to detect singluar/plural. Until then spoken as plural since that is vastly more common
    // note: need to worry about intervening &InvisibleTimes;.
    // note: need to also do this when in numerator of fraction and number preceeds fraction
    // note: need to do this for <msup>
    "mm": "millimeters",
    "cm": "centimeters",
    "km": "kilometers",
    "kg": "kilograms"
  };
  var ENVIRONMENTS_NAMES = {
    "array": "array",
    "matrix": "matrix",
    "pmatrix": "parenthesis matrix",
    "bmatrix": "square brackets matrix",
    "Bmatrix": "braces matrix",
    "vmatrix": "bars matrix",
    "Vmatrix": "double bars matrix",
    "matrix*": "matrix",
    "smallmatrix": "small matrix"
  };
  function getSpokenName(latex) {
    let result = "";
    if (latex.startsWith("\\"))
      result = " " + latex.replace("\\", "") + " ";
    return result;
  }
  function isAtomic(atoms) {
    let count = 0;
    if (isArray(atoms)) {
      for (const atom of atoms)
        if (atom.type !== "first")
          count += 1;
    }
    return count === 1;
  }
  function atomicID(atoms) {
    if (isArray(atoms)) {
      for (const atom of atoms)
        if (atom.type !== "first" && atom.id)
          return atom.id.toString();
    }
    return "";
  }
  function atomicValue(atoms) {
    let result = "";
    if (isArray(atoms)) {
      for (const atom of atoms) {
        if (atom.type !== "first" && typeof atom.value === "string")
          result += atom.value;
      }
    }
    return result;
  }
  function atomsAsText(atoms) {
    if (!atoms)
      return "";
    return atoms.map((atom) => atom.value).join("");
  }
  function atomToSpeakableFragment(mode, atom) {
    var _a3, _b3, _c2, _d2, _e;
    function letter(c) {
      if (!window.MathfieldElement.textToSpeechMarkup) {
        if (/[a-z]/.test(c))
          return " '" + c.toUpperCase() + "'";
        if (/[A-Z]/.test(c))
          return " 'capital " + c.toUpperCase() + "'";
        return c;
      }
      if (/[a-z]/.test(c))
        return ` <say-as interpret-as="character">${c}</say-as>`;
      if (/[A-Z]/.test(c))
        return `capital <say-as interpret-as="character">${c.toLowerCase()}</say-as>`;
      return c;
    }
    function emph(s) {
      return "<emphasis>" + s + "</emphasis>";
    }
    if (!atom)
      return "";
    let result = "";
    if (isArray(atom)) {
      let isInDigitRun = false;
      let isInTextRun = false;
      for (let i = 0; i < atom.length; i++) {
        if (atom[i].type === "first")
          continue;
        if (atom[i].mode !== "text")
          isInTextRun = false;
        if (i < atom.length - 2 && atom[i].type === "mopen" && atom[i + 2].type === "mclose" && atom[i + 1].type === "mord") {
          result += " of ";
          result += emph(atomToSpeakableFragment(mode, atom[i + 1]));
          i += 2;
        } else if (atom[i].mode === "text") {
          if (isInTextRun)
            result += (_a3 = atom[i].value) != null ? _a3 : " ";
          else {
            isInTextRun = true;
            result += atomToSpeakableFragment("text", atom[i]);
          }
        } else if (atom[i].isDigit()) {
          if (isInDigitRun)
            result += atom[i].asDigit();
          else {
            isInDigitRun = true;
            result += atomToSpeakableFragment(mode, atom[i]);
          }
        } else {
          isInDigitRun = false;
          result += atomToSpeakableFragment(mode, atom[i]);
        }
      }
    } else if (atom.mode === "text") {
      if (atom.id && mode === "math")
        result += '<mark name="' + atom.id.toString() + '"/>';
      result += atom.value;
    } else {
      if (atom.id && mode === "math")
        result += '<mark name="' + atom.id.toString() + '"/>';
      let numer = "";
      let denom = "";
      let body = "";
      let supsubHandled = false;
      const { command } = atom;
      switch (atom.type) {
        case "prompt":
          const input = atom.body.length > 1 ? 'start input . <break time="500ms"/> ' + atomToSpeakableFragment(mode, atom.body) + '. <break time="500ms"/> end input' : "blank";
          result += ' <break time="300ms"/> ' + input + '. <break time="700ms"/>' + ((_b3 = atom.correctness) != null ? _b3 : "") + ' . <break time="700ms"/> ';
          break;
        case "accent":
          if (command === "\\vec")
            result += "vector " + atomToSpeakableFragment(mode, atom.body);
          break;
        case "array":
          const array = atom.array;
          const environment = atom.environmentName;
          if (Object.keys(ENVIRONMENTS_NAMES).includes(environment)) {
            result += ` begin ${ENVIRONMENTS_NAMES[environment]} `;
            for (let i = 0; i < array.length; i++) {
              if (i > 0)
                result += ",";
              result += ` row ${i + 1} `;
              for (let j = 0; j < array[i].length; j++) {
                if (j > 0)
                  result += ",";
                result += ` column ${j + 1}: `;
                result += atomToSpeakableFragment("math", array[i][j]);
              }
            }
            result += ` end ${ENVIRONMENTS_NAMES[environment]} `;
          }
          break;
        case "group":
          if (command === "\\ne")
            result += " not equal ";
          else if (command === "\\not") {
            result += " not ";
            result += atomToSpeakableFragment("math", atom.body);
          } else {
            result += atomToSpeakableFragment("math", atom.body);
          }
          break;
        case "root":
          result += atomToSpeakableFragment("math", atom.body);
          break;
        case "genfrac":
          numer = atomToSpeakableFragment("math", atom.above);
          denom = atomToSpeakableFragment("math", atom.below);
          if (isAtomic(atom.above) && isAtomic(atom.below)) {
            const COMMON_FRACTIONS = {
              "1/2": " half ",
              "1/3": " one third ",
              "2/3": " two third",
              "1/4": " one quarter ",
              "3/4": " three quarter ",
              "1/5": " one fifth ",
              "2/5": " two fifths ",
              "3/5": " three fifths ",
              "4/5": " four fifths ",
              "1/6": " one sixth ",
              "5/6": " five sixths ",
              "1/8": " one eight ",
              "3/8": " three eights ",
              "5/8": " five eights ",
              "7/8": " seven eights ",
              "1/9": " one ninth ",
              "2/9": " two ninths ",
              "4/9": " four ninths ",
              "5/9": " five ninths ",
              "7/9": " seven ninths ",
              "8/9": " eight ninths "
              // '1/10':     ' one tenth ',
              // '1/12':     ' one twelfth ',
              // 'x/2':     ' <say-as interpret-as="character">X</say-as> over 2',
            };
            const commonFraction = COMMON_FRACTIONS[atomicValue(atom.above) + "/" + atomicValue(atom.below)];
            if (commonFraction)
              result = commonFraction;
            else
              result += numer + " over " + denom;
          } else {
            result += ' the fraction <break time="150ms"/>' + numer + ' over <break time="150ms"/>' + denom + '.<break time="150ms"/> End fraction.<break time="150ms"/>';
          }
          break;
        case "surd":
          body = atomToSpeakableFragment("math", atom.body);
          if (atom.hasEmptyBranch("above")) {
            result += isAtomic(atom.body) ? " the square root of " + body + " , " : ' the square root of <break time="200ms"/>' + body + '. <break time="200ms"/> End square root';
          } else {
            let index = atomToSpeakableFragment("math", atom.above);
            index = index.trim();
            const index2 = index.replace(/<mark([^/]*)\/>/g, "");
            if (index2 === "3") {
              result += ' the cube root of <break time="200ms"/>' + body + '. <break time="200ms"/> End cube root';
            } else if (index2 === "n") {
              result += ' the nth root of <break time="200ms"/>' + body + '. <break time="200ms"/> End root';
            } else {
              result += ' the root with index: <break time="200ms"/>' + index + ', of <break time="200ms"/>' + body + '. <break time="200ms"/> End root';
            }
          }
          break;
        case "leftright":
          {
            const delimAtom = atom;
            result += (_c2 = delimAtom.leftDelim ? PRONUNCIATION[delimAtom.leftDelim] : void 0) != null ? _c2 : delimAtom.leftDelim;
            result += atomToSpeakableFragment("math", atom.body);
            result += (_d2 = delimAtom.rightDelim ? PRONUNCIATION[delimAtom.rightDelim] : void 0) != null ? _d2 : delimAtom.rightDelim;
          }
          break;
        case "rule":
          break;
        case "overunder":
          break;
        case "overlap":
          break;
        case "line":
          const position = atom.position;
          result += `${position} `;
          result += atomToSpeakableFragment("math", atom.body);
          result += ` end ${position} `;
          break;
        case "macro":
          const macroName = command.replace(/^\\/g, "");
          const macro = getMacros()[macroName];
          if (macro) {
            if (macro == null ? void 0 : macro.expand)
              result += atomToSpeakableFragment("math", atom.body);
            else
              result += `${macroName} `;
          }
          break;
        case "placeholder":
          result += "placeholder ";
          break;
        case "delim":
        case "sizeddelim":
        case "mord":
        case "minner":
        case "mbin":
        case "mrel":
        case "mpunct":
        case "mopen":
        case "mclose": {
          if (command === "\\mathbin" || command === "\\mathrel" || command === "\\mathopen" || command === "\\mathclose" || command === "\\mathpunct" || command === "\\mathord" || command === "\\mathinner") {
            result = atomToSpeakableFragment(mode, atom.body);
            break;
          }
          let atomValue = atom.isDigit() ? atom.asDigit() : atom.value;
          let latexValue = atom.command;
          if (atom.type === "delim" || atom.type === "sizeddelim") {
            latexValue = atom.value;
            atomValue = latexValue;
          }
          if (mode === "text")
            result += atomValue;
          else {
            if (atom.type === "mbin")
              result += '<break time="150ms"/>';
            if (atomValue) {
              const value = PRONUNCIATION[atomValue] || (latexValue ? PRONUNCIATION[latexValue.trim()] : "");
              if (value)
                result += " " + value;
              else {
                const spokenName = latexValue ? getSpokenName(latexValue.trim()) : "";
                result += spokenName ? spokenName : letter(atomValue);
              }
            } else
              result += atomToSpeakableFragment("math", atom.body);
            if (atom.type === "mbin")
              result += '<break time="150ms"/>';
          }
          break;
        }
        case "mop":
          if (atom.value !== "\u200B") {
            const trimLatex = atom.command;
            if (trimLatex === "\\sum") {
              if (!atom.hasEmptyBranch("superscript") && !atom.hasEmptyBranch("subscript")) {
                let sup = atomToSpeakableFragment("math", atom.superscript);
                sup = sup.trim();
                let sub = atomToSpeakableFragment("math", atom.subscript);
                sub = sub.trim();
                result += ' the summation from <break time="200ms"/>' + sub + '<break time="200ms"/> to  <break time="200ms"/>' + sup + '<break time="200ms"/> of <break time="150ms"/>';
                supsubHandled = true;
              } else if (!atom.hasEmptyBranch("subscript")) {
                let sub = atomToSpeakableFragment("math", atom.subscript);
                sub = sub.trim();
                result += ' the summation from <break time="200ms"/>' + sub + '<break time="200ms"/> of <break time="150ms"/>';
                supsubHandled = true;
              } else
                result += " the summation of";
            } else if (trimLatex === "\\prod") {
              if (!atom.hasEmptyBranch("superscript") && !atom.hasEmptyBranch("subscript")) {
                let sup = atomToSpeakableFragment("math", atom.superscript);
                sup = sup.trim();
                let sub = atomToSpeakableFragment("math", atom.subscript);
                sub = sub.trim();
                result += ' the product from <break time="200ms"/>' + sub + '<break time="200ms"/> to <break time="200ms"/>' + sup + '<break time="200ms"/> of <break time="150ms"/>';
                supsubHandled = true;
              } else if (!atom.hasEmptyBranch("subscript")) {
                let sub = atomToSpeakableFragment("math", atom.subscript);
                sub = sub.trim();
                result += ' the product from <break time="200ms"/>' + sub + '<break time="200ms"/> of <break time="150ms"/>';
                supsubHandled = true;
              } else
                result += " the product  of ";
            } else if (trimLatex === "\\int") {
              if (!atom.hasEmptyBranch("superscript") && !atom.hasEmptyBranch("subscript")) {
                let sup = atomToSpeakableFragment("math", atom.superscript);
                sup = sup.trim();
                let sub = atomToSpeakableFragment("math", atom.subscript);
                sub = sub.trim();
                result += ' the integral from <break time="200ms"/>' + emph(sub) + '<break time="200ms"/> to <break time="200ms"/>' + emph(sup) + ' <break time="200ms"/> of ';
                supsubHandled = true;
              } else
                result += ' the integral of <break time="200ms"/> ';
            } else if (typeof atom.value === "string") {
              const value = (_e = PRONUNCIATION[atom.value]) != null ? _e : atom.command ? PRONUNCIATION[atom.command] : void 0;
              result += value ? value : " " + atom.value;
            } else if (atom.command) {
              if (atom.command === "\\mathop")
                result += atomToSpeakableFragment("math", atom.body);
              else if (atom.command === "\\operatorname")
                result += atomsAsText(atom.body);
              else {
                result += atom.command.startsWith("\\") ? " " + atom.command.slice(1) : " " + atom.command;
              }
            }
          }
          break;
        case "enclose":
          body = atomToSpeakableFragment("math", atom.body);
          result += " crossed out " + body + ". End crossed out.";
          break;
        case "space":
        case "spacing":
          break;
      }
      if (!supsubHandled && !atom.hasEmptyBranch("superscript")) {
        let sup = atomToSpeakableFragment(mode, atom.superscript);
        sup = sup.trim();
        const sup2 = sup.replace(/<[^>]*>/g, "");
        if (isAtomic(atom.superscript)) {
          if (mode === "math") {
            const id = atomicID(atom.superscript);
            if (id)
              result += '<mark name="' + id + '"/>';
          }
          if (sup2 === "\u2032")
            result += " prime ";
          else if (sup2 === "2")
            result += " squared ";
          else if (sup2 === "3")
            result += " cubed ";
          else if (Number.isNaN(Number.parseInt(sup2)))
            result += " to the " + sup + "; ";
          else {
            result += ' to the <say-as interpret-as="ordinal">' + sup2 + "</say-as> power; ";
          }
        } else if (Number.isNaN(Number.parseInt(sup2)))
          result += " raised to the " + sup + "; ";
        else {
          result += ' raised to the <say-as interpret-as="ordinal">' + sup2 + "</say-as> power; ";
        }
      }
      if (!supsubHandled && !atom.hasEmptyBranch("subscript")) {
        let sub = atomToSpeakableFragment("math", atom.subscript);
        sub = sub.trim();
        result += isAtomic(atom.subscript) ? " sub " + sub : " subscript " + sub + ". End subscript. ";
      }
    }
    return result;
  }
  function atomToSpeakableText(atoms) {
    var _a3, _b3;
    if (window.MathfieldElement.textToSpeechRules === "sre" && ("sre" in window || "SRE" in window)) {
      const mathML = toMathML(atoms);
      if (mathML) {
        if (window.MathfieldElement.textToSpeechMarkup) {
          window.MathfieldElement.textToSpeechRulesOptions = (_a3 = window.MathfieldElement.textToSpeechRulesOptions) != null ? _a3 : {};
          window.MathfieldElement.textToSpeechRulesOptions.markup = window.MathfieldElement.textToSpeechMarkup;
          if (window.MathfieldElement.textToSpeechRulesOptions.markup === "ssml")
            window.MathfieldElement.textToSpeechRulesOptions.markup = "ssml_step";
          window.MathfieldElement.textToSpeechRulesOptions.rate = window.MathfieldElement.speechEngineRate;
        }
        const SRE = (_b3 = window["SRE"]) != null ? _b3 : window.sre.System.getInstance();
        if (window.MathfieldElement.textToSpeechRulesOptions)
          SRE.setupEngine(window.MathfieldElement.textToSpeechRulesOptions);
        let result2 = "";
        try {
          result2 = SRE.toSpeech(mathML);
        } catch (e) {
          console.error(
            `MathLive 0.91.2: \`SRE.toSpeech()\` runtime error`,
            e
          );
        }
        return result2;
      }
      return "";
    }
    let result = atomToSpeakableFragment("math", atoms);
    if (window.MathfieldElement.textToSpeechMarkup === "ssml") {
      let prosody = "";
      if (window.MathfieldElement.speechEngineRate) {
        prosody = '<prosody rate="' + window.MathfieldElement.speechEngineRate + '">';
      }
      result = `<?xml version="1.0"?><speak version="1.1" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US"><amazon:auto-breaths>` + prosody + "<p><s>" + result + "</s></p>" + (prosody ? "</prosody>" : "") + "</amazon:auto-breaths></speak>";
    } else if (window.MathfieldElement.textToSpeechMarkup === "mac" && osPlatform() === "macos") {
      result = result.replace(/<mark([^/]*)\/>/g, "").replace(/<emphasis>/g, "[[emph+]]").replace(/<\/emphasis>/g, "").replace(/<break time="(\d*)ms"\/>/g, "[[slc $1]]").replace(/<say-as[^>]*>/g, "").replace(/<\/say-as>/g, "");
    } else {
      result = result.replace(/<[^>]*>/g, "").replace(/\s{2,}/g, " ");
    }
    return result;
  }

  // src/editor/speech.ts
  function speakableText(prefix, atoms) {
    return prefix + atomToSpeakableText(atoms);
  }
  register2(
    {
      speak: (mathfield, scope, options) => {
        return speak(mathfield, scope, options);
      }
    },
    { target: "mathfield", category: "speech" }
  );
  function speak(mathfield, scope, speakOptions) {
    var _a3, _b3;
    speakOptions = speakOptions != null ? speakOptions : { withHighlighting: false };
    const { model } = mathfield;
    function getAtoms(scope2) {
      let result = null;
      switch (scope2) {
        case "all":
          result = model.root;
          break;
        case "selection":
          result = model.getAtoms(model.selection);
          break;
        case "left": {
          result = model.getAtoms(
            model.offsetOf(model.at(model.position).leftSibling),
            model.position
          );
          break;
        }
        case "right": {
          result = model.getAtoms(
            model.position,
            model.offsetOf(model.at(model.position).rightSibling)
          );
          break;
        }
        case "group":
          result = model.getAtoms(model.getSiblingsRange(model.position));
          break;
        case "parent": {
          const { parent } = model.at(model.position);
          if (parent && parent.type !== "root")
            result = parent;
          else
            result = model.root;
          break;
        }
        default:
          result = model.root;
      }
      return result;
    }
    function getFailedSpeech(scope2) {
      let result = "";
      switch (scope2) {
        case "all":
          console.log("Internal failure: speak all failed");
          break;
        case "selection":
          result = "no selection";
          break;
        case "left":
          result = "at start";
          break;
        case "right":
          result = "at end";
          break;
        case "group":
          console.log("Internal failure: speak group failed");
          break;
        case "parent":
          result = "no parent";
          break;
        default:
          console.log('unknown speak_ param value: "' + scope2 + '"');
          break;
      }
      return result;
    }
    const atoms = getAtoms(scope);
    if (atoms === null) {
      (_b3 = (_a3 = window.MathfieldElement).speakHook) == null ? void 0 : _b3.call(_a3, getFailedSpeech(scope));
      return false;
    }
    if (speakOptions.withHighlighting || window.MathfieldElement.speechEngine === "amazon") {
      window.MathfieldElement.textToSpeechMarkup = window.sre && window.MathfieldElement.textToSpeechRules === "sre" ? "ssml_step" : "ssml";
    }
    const text = atomToSpeakableText(atoms);
    if (isBrowser() && speakOptions.withHighlighting) {
      globalMathLive().readAloudMathField = mathfield;
      render(mathfield, { forHighlighting: true });
      if (window.MathfieldElement.readAloudHook)
        window.MathfieldElement.readAloudHook(mathfield.field, text);
    } else if (window.MathfieldElement.speakHook)
      window.MathfieldElement.speakHook(text);
    return false;
  }
  function defaultSpeakHook(text) {
    var _a3, _b3;
    if (!isBrowser()) {
      console.log("Speak:", text);
      return;
    }
    if (!window.MathfieldElement.speechEngine || window.MathfieldElement.speechEngine === "local") {
      const utterance = new SpeechSynthesisUtterance(text);
      window.speechSynthesis.speak(utterance);
    } else if (window.MathfieldElement.speechEngine === "amazon") {
      if (!("AWS" in window)) {
        console.error(
          `MathLive 0.91.2: AWS SDK not loaded. See https://www.npmjs.com/package/aws-sdk`
        );
      } else {
        const polly = new window.AWS.Polly({ apiVersion: "2016-06-10" });
        const parameters = {
          OutputFormat: "mp3",
          VoiceId: (_a3 = window.MathfieldElement.speechEngineVoice) != null ? _a3 : "Joanna",
          Engine: [
            "Amy",
            "Emma",
            "Brian",
            "Ivy",
            "Joanna",
            "Kendra",
            "Kimberly",
            "Salli",
            "Joey",
            "Justin",
            "Matthew"
          ].includes((_b3 = window.MathfieldElement.speechEngineVoice) != null ? _b3 : "Joanna") ? "neural" : "standard",
          // SampleRate: '24000',
          Text: text,
          TextType: "ssml"
          // SpeechMarkTypes: ['ssml]'
        };
        polly.synthesizeSpeech(parameters, (err, data) => {
          if (err) {
            console.trace(
              `MathLive 0.91.2: \`polly.synthesizeSpeech()\` error: ${err}`
            );
          } else if (data == null ? void 0 : data.AudioStream) {
            const uInt8Array = new Uint8Array(data.AudioStream);
            const blob = new Blob([uInt8Array.buffer], { type: "audio/mpeg" });
            const url = URL.createObjectURL(blob);
            const audioElement = new Audio(url);
            audioElement.play().catch((error) => console.log(error));
          } else
            console.log("polly.synthesizeSpeech():", data);
        });
      }
    } else if (window.MathfieldElement.speechEngine === "google") {
      console.error(
        `MathLive 0.91.2: The Google speech engine is not supported yet. Please come again.`
      );
    }
  }

  // src/editor/a11y.ts
  function relationName(atom) {
    let result = void 0;
    if (atom.parent.type === "prompt") {
      if (atom.treeBranch === "body")
        result = "prompt";
    } else if (atom.treeBranch === "body") {
      result = {
        enclose: "cross out",
        leftright: "delimiter",
        surd: "square root",
        root: "math field",
        mop: "operator",
        // E.g. `\operatorname`, a `mop` with a body
        first: "first"
      }[atom.type];
    } else if (atom.parent.type === "genfrac") {
      if (atom.treeBranch === "above")
        return "numerator";
      if (atom.treeBranch === "below")
        return "denominator";
    } else if (atom.parent.type === "surd") {
      if (atom.treeBranch === "above")
        result = "index";
    } else if (atom.treeBranch === "superscript")
      result = "superscript";
    else if (atom.treeBranch === "subscript")
      result = "subscript";
    if (!result)
      console.log("unknown relationship");
    return result != null ? result : "parent";
  }
  function defaultAnnounceHook(mathfield, action, previousPosition, atoms) {
    let liveText = "";
    if (action === "plonk") {
      window.MathfieldElement.playSound("plonk");
      mathfield.flushInlineShortcutBuffer();
    } else if (action === "delete")
      liveText = speakableText("deleted: ", atoms);
    else if (action === "focus" || action.includes("move")) {
      liveText = getRelationshipAsSpokenText(mathfield.model, previousPosition) + (mathfield.model.selectionIsCollapsed ? "" : "selected: ") + getNextAtomAsSpokenText(mathfield.model);
    } else if (action === "replacement") {
      liveText = speakableText("", mathfield.model.at(mathfield.model.position));
    } else if (action === "line") {
      const label = speakableText("", mathfield.model.root);
      mathfield.keyboardDelegate.setAriaLabel(label);
    } else
      liveText = atoms ? speakableText(action + " ", atoms) : action;
    if (liveText) {
      const ariaLiveChangeHack = mathfield.ariaLiveText.textContent.includes(
        "\xA0"
      ) ? " \u202F " : " \xA0 ";
      mathfield.ariaLiveText.textContent = liveText + ariaLiveChangeHack;
    }
  }
  function getRelationshipAsSpokenText(model, previousOffset) {
    if (Number.isNaN(previousOffset))
      return "";
    const previous = model.at(previousOffset);
    if (!previous)
      return "";
    if (previous.treeDepth <= model.at(model.position).treeDepth)
      return "";
    let result = "";
    let ancestor = previous.parent;
    const newParent = model.at(model.position).parent;
    while (ancestor !== model.root && ancestor !== newParent) {
      result += `out of ${relationName(ancestor)};`;
      ancestor = ancestor.parent;
    }
    return result;
  }
  function getNextAtomAsSpokenText(model) {
    if (!model.selectionIsCollapsed)
      return speakableText("", model.getAtoms(model.selection));
    let result = "";
    const cursor = model.at(model.position);
    const relation = relationName(cursor);
    if (cursor.isFirstSibling)
      result = (relation ? "start of " + relation : "unknown") + ": ";
    if (cursor.isLastSibling) {
      if (!cursor.isFirstSibling)
        result += relation ? "end of " + relation : "unknown";
    } else
      result += speakableText("", cursor);
    return result;
  }

  // src/editor-model/model-private.ts
  var ModelPrivate = class {
    constructor(options, listeners, target) {
      this.options = options;
      this._selection = { ranges: [[0, 0]], direction: "none" };
      this._anchor = 0;
      this._position = 0;
      this.mathfield = target;
      this.suppressChangeNotifications = false;
      this.root = new Atom("root", target, {
        mode: options.mode
      });
      this.root.body = [];
      this.setListeners(listeners);
    }
    get atoms() {
      return this.root.children;
    }
    /**
     * The selection, accounting for the common ancestors
     */
    get selection() {
      return this._selection;
    }
    set selection(value) {
      this.setSelection(value);
    }
    setSelection(arg1, arg2) {
      if (!this.mathfield.contentEditable && this.mathfield.userSelect === "none")
        return false;
      return this.deferNotifications({ selection: true }, () => {
        var _a3, _b3, _c2;
        const value = this.normalizeSelection(arg1, arg2);
        if (value === void 0)
          throw new TypeError("Invalid selection");
        if (value.ranges.length === 1 && value.ranges[0][0] === value.ranges[0][1]) {
          const pos = value.ranges[0][0];
          if (!this.mathfield.dirty && !((_a3 = this.at(pos)) == null ? void 0 : _a3.parentPrompt) && this.mathfield.hasEditablePrompts) {
            if ((_b3 = this.at(pos - 1)) == null ? void 0 : _b3.parentPrompt) {
              this._anchor = this.normalizeOffset(pos - 1);
              this._position = this._anchor;
              this._selection = this.normalizeSelection(this._anchor);
              return true;
            }
            if ((_c2 = this.at(pos + 1)) == null ? void 0 : _c2.parentPrompt) {
              this._anchor = this.normalizeOffset(pos + 1);
              this._position = this._anchor;
              this._selection = this.normalizeSelection(this._anchor);
              return true;
            }
            this._anchor = 0;
            this._position = 0;
            this._selection = { ranges: [[0, 0]] };
            return false;
          }
          this._anchor = pos;
          this._position = pos;
          this._selection = value;
          return false;
        }
        const selRange = range(value);
        if (value.direction === "backward")
          [this._position, this._anchor] = selRange;
        else
          [this._anchor, this._position] = selRange;
        const first = this.at(selRange[0] + 1);
        const last = this.at(selRange[1]);
        const commonAncestor = Atom.commonAncestor(first, last);
        if ((commonAncestor == null ? void 0 : commonAncestor.type) === "array" && first.parent === commonAncestor && last.parent === commonAncestor) {
          this._selection = { ranges: [selRange], direction: value.direction };
        } else
          this._selection = { ranges: [selRange], direction: value.direction };
        console.assert(this._position >= 0 && this._position <= this.lastOffset);
        return false;
      });
    }
    setPositionHandlingPlaceholder(pos) {
      var _a3, _b3, _c2;
      if (((_a3 = this.at(pos)) == null ? void 0 : _a3.type) === "placeholder") {
        this.setSelection(pos - 1, pos);
      } else if (((_c2 = (_b3 = this.at(pos)) == null ? void 0 : _b3.rightSibling) == null ? void 0 : _c2.type) === "placeholder") {
        this.setSelection(pos, pos + 1);
      } else
        this.position = pos;
    }
    getState() {
      return {
        content: this.root.toJson(),
        selection: this.selection
      };
    }
    setState(state, options) {
      var _a3;
      const wasSuppressing = this.suppressChangeNotifications;
      this.suppressChangeNotifications = (_a3 = options == null ? void 0 : options.suppressChangeNotifications) != null ? _a3 : true;
      let changeOption = {};
      if ((options == null ? void 0 : options.type) === "undo")
        changeOption = { inputType: "historyUndo" };
      if ((options == null ? void 0 : options.type) === "redo")
        changeOption = { inputType: "historyRedo" };
      if (contentWillChange(this, changeOption)) {
        this.root = fromJson(state.content, this.mathfield);
        this.selection = state.selection;
        contentDidChange(this, changeOption);
      }
      this.suppressChangeNotifications = wasSuppressing;
    }
    /**
     * The "focus" or "cursor" (i.e. not the anchor) a.k.a the insertion point
     * or caret: where things are going to be inserted next.
     *
     */
    get position() {
      return this._position;
    }
    set position(value) {
      this.setSelection(value, value);
    }
    /**
     * The offset from which the selection is extended
     */
    get anchor() {
      return this._anchor;
    }
    get selectionIsCollapsed() {
      return this._anchor === this._position;
    }
    get selectionIsPlaceholder() {
      if (Math.abs(this._anchor - this._position) === 1) {
        return this.at(Math.max(this._anchor, this._position)).type === "placeholder";
      }
      return false;
    }
    collapseSelection(direction = "forward") {
      if (this._anchor === this._position)
        return false;
      if (direction === "backward")
        this.position = Math.min(this._anchor, this._position);
      else
        this.position = Math.max(this._anchor, this._position);
      return true;
    }
    get lastOffset() {
      return this.atoms.length - 1;
    }
    at(index) {
      return this.atoms[index];
    }
    offsetOf(atom) {
      return this.atoms.indexOf(atom);
    }
    getSiblingsRange(offset) {
      const atom = this.at(offset);
      const { parent } = atom;
      if (!parent)
        return [0, this.lastOffset];
      const branch = atom.parent.branch(atom.treeBranch);
      return [this.offsetOf(branch[0]), this.offsetOf(branch[branch.length - 1])];
    }
    getBranchRange(offset, branchName) {
      const branch = this.at(offset).branch(branchName);
      return [this.offsetOf(branch[0]), this.offsetOf(branch[branch.length - 1])];
    }
    getAtoms(arg1, arg2, arg3) {
      let options = arg3 != null ? arg3 : {};
      if (isSelection(arg1)) {
        options = arg2 != null ? arg2 : {};
        if (arg1.ranges.length > 1) {
          return arg1.ranges.reduce(
            (acc, range2) => [...acc, ...this.getAtoms(range2, options)],
            []
          );
        }
        arg1 = arg1.ranges[0];
      }
      let start;
      let end;
      if (isOffset(arg1)) {
        start = arg1;
        if (!isOffset(arg2))
          return [];
        end = arg2;
      } else {
        [start, end] = arg1;
        options = arg2 != null ? arg2 : {};
      }
      if (!Number.isFinite(start))
        return [];
      if (options.includeChildren === void 0)
        options.includeChildren = false;
      if (start < 0)
        start = this.lastOffset - start + 1;
      if (end < 0)
        end = this.lastOffset - end + 1;
      const first = Math.min(start, end) + 1;
      const last = Math.max(start, end);
      if (first === 1 && last === this.lastOffset) {
        return [this.root];
      }
      let result = [];
      for (let i = first; i <= last; i++) {
        const atom = this.atoms[i];
        if (atomIsInRange(this, atom, first, last))
          result.push(atom);
      }
      if (!options.includeChildren) {
        result = result.filter((atom) => {
          let ancestorIncluded = false;
          let { parent } = atom;
          while (parent && !ancestorIncluded) {
            ancestorIncluded = atomIsInRange(this, parent, first, last);
            parent = parent.parent;
          }
          return !ancestorIncluded;
        });
      }
      return result;
    }
    /**
     * Unlike `getAtoms()`, the argument here is an index
     * Return all the atoms, in order, starting at startingIndex
     * then looping back at the beginning
     */
    getAllAtoms(startingIndex = 0) {
      const result = [];
      const last = this.lastOffset;
      for (let i = startingIndex; i <= last; i++)
        result.push(this.atoms[i]);
      for (let i = 0; i < startingIndex; i++)
        result.push(this.atoms[i]);
      return result;
    }
    findAtom(filter, startingIndex = 0, direction = "forward") {
      if (direction === "forward") {
        const last = this.lastOffset;
        for (let i = startingIndex; i <= last; i++)
          if (filter(this.atoms[i]))
            return this.atoms[i];
        for (let i = 0; i < startingIndex; i++)
          if (filter(this.atoms[i]))
            return this.atoms[i];
        return void 0;
      }
      for (let i = startingIndex; i >= 0; i--)
        if (filter(this.atoms[i]))
          return this.atoms[i];
      for (let i = this.lastOffset; i < startingIndex; i--)
        if (filter(this.atoms[i]))
          return this.atoms[i];
      return void 0;
    }
    /** Remove the specified atoms from the tree.
     * **WARNING** upon return the selection may now be invalid
     */
    extractAtoms(range2) {
      let result = this.getAtoms(range2);
      if (result.length === 1 && result[0].type === "root") {
        result = result[0].children;
      }
      for (const child of result)
        child.parent.removeChild(child);
      return result;
    }
    deleteAtoms(range2) {
      this.extractAtoms(range2);
      this.position = range2[0];
    }
    atomToString(atom, inFormat) {
      const format = inFormat != null ? inFormat : "latex";
      if (format.startsWith("latex")) {
        return Mode.serialize([atom], {
          expandMacro: format === "latex-expanded",
          skipStyles: format === "latex-unstyled",
          defaultMode: this.mathfield.options.defaultMode
        });
      }
      if (format === "math-ml")
        return toMathML(atom);
      if (format === "spoken")
        return atomToSpeakableText(atom);
      if (format === "spoken-text") {
        const saveTextToSpeechMarkup = window.MathfieldElement.textToSpeechMarkup;
        window.MathfieldElement.textToSpeechMarkup = "";
        const result = atomToSpeakableText(atom);
        window.MathfieldElement.textToSpeechMarkup = saveTextToSpeechMarkup;
        return result;
      }
      if (format === "spoken-ssml" || format === "spoken-ssml-with-highlighting") {
        const saveTextToSpeechMarkup = window.MathfieldElement.textToSpeechMarkup;
        window.MathfieldElement.textToSpeechMarkup = "ssml";
        const result = atomToSpeakableText(atom);
        window.MathfieldElement.textToSpeechMarkup = saveTextToSpeechMarkup;
        return result;
      }
      if (format === "math-json") {
        if (!window.MathfieldElement.computeEngine) {
          if (!window[Symbol.for("io.cortexjs.compute-engine")]) {
            console.error(
              'The CortexJS Compute Engine library is not available.\nLoad the library, for example with:\nimport "https://unpkg.com/@cortex-js/compute-engine?module"'
            );
          }
          return '["Error", "compute-engine-not-available"]';
        }
        try {
          const expr = window.MathfieldElement.computeEngine.parse(
            Atom.serialize(atom, { expandMacro: false, defaultMode: "math" })
          );
          return JSON.stringify(expr.json);
        } catch (e) {
          return JSON.stringify(["Error", `'${e.toString()}'`]);
        }
      }
      if (format === "ascii-math")
        return atomToAsciiMath(atom);
      console.error(`MathLive 0.91.2: Unknown format "${format}`);
      return "";
    }
    getValue(arg1, arg2, arg3) {
      if (arg1 === void 0)
        return this.atomToString(this.root, "latex");
      if (typeof arg1 === "string")
        return this.atomToString(this.root, arg1);
      let ranges;
      let format;
      if (isOffset(arg1) && isOffset(arg2)) {
        ranges = [this.normalizeRange([arg1, arg2])];
        format = arg3 != null ? arg3 : "latex";
      } else if (isRange(arg1)) {
        ranges = [this.normalizeRange(arg1)];
        format = arg2;
      } else if (isSelection(arg1)) {
        ranges = arg1.ranges;
        format = arg2;
      } else {
        ranges = [];
        format = "latex";
      }
      if (format.startsWith("latex")) {
        const options = {
          expandMacro: format === "latex-expanded",
          skipStyles: format === "latex-unstyled",
          defaultMode: this.mathfield.options.defaultMode
        };
        return joinLatex(
          ranges.map((range2) => Atom.serialize(this.getAtoms(range2), options))
        );
      }
      return ranges.map(
        (range2) => this.getAtoms(range2).map((atom) => this.atomToString(atom, format)).join("")
      ).join("");
    }
    /**
     * Method called in response to a user interaction
     */
    extendSelection(direction) {
      let anchor = this._anchor;
      if (direction === "forward") {
        let pos2 = this._position;
        do {
          let atom = this.at(pos2 + 1);
          if (atom == null ? void 0 : atom.inCaptureSelection) {
            while (!atom.captureSelection)
              atom = atom.parent;
            pos2 = this.offsetOf(atom == null ? void 0 : atom.lastChild) + 1;
          } else
            pos2 += 1;
        } while (pos2 <= this.lastOffset && this.at(pos2).isFirstSibling);
        if (pos2 === anchor - 1 && this.at(anchor).type === "first")
          pos2 = anchor;
        return this.extendSelectionTo(anchor, pos2);
      }
      let pos = this._position - 1;
      if (pos < 0)
        return false;
      while (pos >= 0 && this.at(pos).isLastSibling) {
        let atom = this.at(pos);
        if (atom == null ? void 0 : atom.inCaptureSelection) {
          while (!atom.captureSelection)
            atom = atom.parent;
          pos = this.offsetOf(atom.firstChild) - 1;
        } else
          pos -= 1;
      }
      if (pos < 0)
        pos = 0;
      if (pos === anchor + 1 && this.at(pos).type === "first")
        anchor = pos;
      return this.extendSelectionTo(anchor, pos);
    }
    /**
     * Unlike `setSelection`, this method is intended to be used in response
     * to a user action, and it performs various adjustments to result
     * in a more intuitive selection.
     * For example:
     * - when all the children of an atom are selected, the atom
     * become selected.
     * - this method will *not* change the anchor, but may result
     * in a selection whose boundary is outside the anchor
     */
    extendSelectionTo(anchor, position) {
      if (!this.mathfield.contentEditable && this.mathfield.userSelect === "none")
        return false;
      return this.deferNotifications({ selection: true }, () => {
        const range2 = this.normalizeRange([anchor, position]);
        let [start, end] = range2;
        let { parent } = this.at(end);
        if (parent) {
          if (parent.type === "genfrac" || parent.type === "msubsup") {
            while (parent !== this.root && childrenInRange(this, parent, [start, end])) {
              end = this.offsetOf(parent);
              parent = parent.parent;
            }
          }
        }
        parent = this.at(start).parent;
        while (parent !== this.root && childrenInRange(this, parent, [start, end])) {
          start = this.offsetOf(parent.leftSibling);
          parent = parent.parent;
        }
        parent = this.at(end).parent;
        if ((parent == null ? void 0 : parent.type) === "genfrac") {
          while (parent !== this.root && childrenInRange(this, parent, [start, end])) {
            end = this.offsetOf(parent);
            console.assert(end >= 0);
            parent = parent.parent;
          }
        }
        this._position = this.normalizeOffset(position);
        this._selection = {
          ranges: [[start, end]],
          direction: "none"
        };
      });
    }
    setListeners(listeners) {
      this.listeners = listeners;
    }
    /**
     * This method is called to provide feedback when using a screen reader
     * or other assistive device, for example when changing the selection or
     * moving the insertion point.
     *
     * It can also be used with the 'plonk' command to provide an audible
     * feedback when a command is not possible.
     *
     * This method should not be called from other methods of the model
     * (such as `setSelection`) as these methods can also be called
     * programmatically and a feedback in these case would be innapropriate,
     * however they should be called from functions called as a result of a user
     * action, such as the functions in `commands.ts`
     */
    announce(command, previousPosition, atoms = []) {
      var _a3, _b3;
      const result = (_b3 = (_a3 = this.mathfield.host) == null ? void 0 : _a3.dispatchEvent(
        new CustomEvent("announce", {
          detail: { command, previousPosition, atoms },
          cancelable: true,
          bubbles: true,
          composed: true
        })
      )) != null ? _b3 : true;
      if (result)
        defaultAnnounceHook(this.mathfield, command, previousPosition, atoms);
    }
    // Suppress notification while scope is executed,
    // then notify of content change, and selection change (if actual change)
    deferNotifications(options, f) {
      const oldSelection = this._selection;
      const oldAnchor = this._anchor;
      const oldPosition = this._position;
      const saved = this.suppressChangeNotifications;
      this.suppressChangeNotifications = true;
      const previousCounter = this.root.changeCounter;
      f();
      const contentChanged = this.root.changeCounter !== previousCounter;
      const selectionChanged = oldAnchor !== this._anchor || oldPosition !== this._position || compareSelection(this._selection, oldSelection) === "different";
      this.suppressChangeNotifications = saved;
      if (options.content && contentChanged)
        contentDidChange(this, { inputType: options.type });
      if (options.selection && selectionChanged)
        selectionDidChange(this);
      return contentChanged || selectionChanged;
    }
    normalizeOffset(value) {
      if (value > 0)
        value = Math.min(value, this.lastOffset);
      else if (value < 0)
        value = this.lastOffset + value + 1;
      return value;
    }
    /**
     * Ensure that the range is valid and canonical, i.e.
     * - start <= end
     * - collapsed = start === end
     * - start >= 0, end >=0
     */
    normalizeRange(range2) {
      let [start, end] = range2;
      start = this.normalizeOffset(start);
      end = this.normalizeOffset(end);
      return start < end ? [start, end] : [end, start];
    }
    normalizeSelection(value, value2) {
      var _a3;
      let result = void 0;
      if (isOffset(value)) {
        const offset = this.normalizeOffset(value);
        if (isOffset(value2)) {
          const offset2 = this.normalizeOffset(value2);
          result = offset <= offset2 ? { ranges: [[offset, offset2]], direction: "none" } : {
            ranges: [[offset2, offset]],
            direction: "backward"
          };
        } else
          result = { ranges: [[offset, offset]], direction: "none" };
      } else if (isRange(value)) {
        const start = this.normalizeOffset(value[0]);
        const end = this.normalizeOffset(value[1]);
        result = start <= end ? { ranges: [[start, end]], direction: "none" } : { ranges: [[end, start]], direction: "backward" };
      } else if (isSelection(value)) {
        result = {
          ranges: value.ranges.map((x) => this.normalizeRange(x)),
          direction: (_a3 = value.direction) != null ? _a3 : "none"
        };
      }
      console.assert(result !== void 0);
      return result;
    }
  };
  function atomIsInRange(model, atom, first, last) {
    const offset = model.offsetOf(atom);
    if (offset < first || offset > last)
      return false;
    if (!atom.hasChildren)
      return true;
    const firstOffset = model.offsetOf(atom.firstChild);
    if (firstOffset >= first && firstOffset <= last) {
      const lastOffset = model.offsetOf(atom.lastChild);
      if (lastOffset >= first && lastOffset <= last)
        return true;
    }
    return false;
  }
  function childrenInRange(model, atom, range2) {
    if (!(atom == null ? void 0 : atom.hasChildren))
      return false;
    const [start, end] = range2;
    const first = model.offsetOf(atom.firstChild);
    const last = model.offsetOf(atom.lastChild);
    if (first >= start && first <= end && last >= first && last <= end)
      return true;
    return false;
  }

  // src/editor-model/array.ts
  function addCell(model, where) {
    let atom = model.at(model.position);
    while (atom && !(Array.isArray(atom.treeBranch) && atom.parent instanceof ArrayAtom))
      atom = atom.parent;
    if (Array.isArray(atom == null ? void 0 : atom.treeBranch) && (atom == null ? void 0 : atom.parent) instanceof ArrayAtom) {
      const arrayAtom = atom.parent;
      let pos;
      switch (where) {
        case "after row":
          arrayAtom.addRowAfter(atom.treeBranch[0]);
          pos = model.offsetOf(arrayAtom.getCell(atom.treeBranch[0] + 1, 0)[0]);
          break;
        case "after column":
          if (arrayAtom.maxColumns <= arrayAtom.colCount) {
            model.announce("plonk");
            return;
          }
          arrayAtom.addColumnAfter(atom.treeBranch[1]);
          pos = model.offsetOf(
            arrayAtom.getCell(atom.treeBranch[0], atom.treeBranch[1] + 1)[0]
          );
          break;
        case "before row":
          arrayAtom.addRowBefore(atom.treeBranch[0]);
          pos = model.offsetOf(arrayAtom.getCell(atom.treeBranch[0] - 1, 0)[0]);
          break;
        case "before column":
          if (arrayAtom.maxColumns <= arrayAtom.colCount) {
            model.announce("plonk");
            return;
          }
          arrayAtom.addColumnBefore(atom.treeBranch[1]);
          pos = model.offsetOf(
            arrayAtom.getCell(atom.treeBranch[0], atom.treeBranch[1] - 1)[0]
          );
          break;
      }
      model.setSelection(pos, pos + 1);
    }
  }
  function addRowAfter(model) {
    if (!contentWillChange(model, { inputType: "insertText" }))
      return false;
    addCell(model, "after row");
    contentDidChange(model, { inputType: "insertText" });
    return true;
  }
  function addRowBefore(model) {
    if (!contentWillChange(model, { inputType: "insertText" }))
      return false;
    addCell(model, "before row");
    contentDidChange(model, { inputType: "insertText" });
    return true;
  }
  function addColumnAfter(model) {
    if (!contentWillChange(model, { inputType: "insertText" }))
      return false;
    addCell(model, "after column");
    contentDidChange(model, { inputType: "insertText" });
    return true;
  }
  function addColumnBefore(model) {
    if (!contentWillChange(model, { inputType: "insertText" }))
      return false;
    addCell(model, "before column");
    contentDidChange(model, { inputType: "insertText" });
    return true;
  }
  function removeCell(model, where) {
    let atom = model.at(model.position);
    while (atom && !(Array.isArray(atom.treeBranch) && atom.parent instanceof ArrayAtom))
      atom = atom.parent;
    if (Array.isArray(atom == null ? void 0 : atom.treeBranch) && (atom == null ? void 0 : atom.parent) instanceof ArrayAtom) {
      const arrayAtom = atom.parent;
      const treeBranch = atom.treeBranch;
      let pos;
      switch (where) {
        case "row":
          if (arrayAtom.rowCount > 1) {
            arrayAtom.removeRow(treeBranch[0]);
            const cell = arrayAtom.getCell(
              Math.max(0, treeBranch[0] - 1),
              treeBranch[1]
            );
            pos = model.offsetOf(cell[cell.length - 1]);
          }
          break;
        case "column":
          if (arrayAtom.colCount > arrayAtom.minColumns) {
            arrayAtom.removeColumn(treeBranch[1]);
            const cell = arrayAtom.getCell(
              treeBranch[0],
              Math.max(0, treeBranch[1] - 1)
            );
            pos = model.offsetOf(cell[cell.length - 1]);
          }
          break;
      }
      if (pos)
        model.setPositionHandlingPlaceholder(pos);
    }
  }
  function removeRow(model) {
    if (!contentWillChange(model, { inputType: "deleteContent" }))
      return false;
    removeCell(model, "row");
    contentDidChange(model, { inputType: "deleteContent" });
    return true;
  }
  function removeColumn(model) {
    if (!contentWillChange(model, { inputType: "deleteContent" }))
      return false;
    removeCell(model, "column");
    contentDidChange(model, { inputType: "deleteContent" });
    return true;
  }
  register2(
    {
      addRowAfter,
      addColumnAfter,
      addRowBefore,
      addColumnBefore,
      removeRow,
      removeColumn
    },
    { target: "model", category: "array-edit" }
  );

  // src/editor-model/delete.ts
  function onDelete(model, direction, atom, branch) {
    var _a3, _b3, _c2, _d2, _e, _f;
    const parent = atom.parent;
    if (parent && atom instanceof LeftRightAtom) {
      const atStart = !branch && direction === "forward" || branch === "body" && direction === "backward";
      let pos = atStart ? model.offsetOf(atom.firstChild) : model.offsetOf(atom.lastChild);
      if (atStart) {
        if (atom.rightDelim !== "?" && atom.rightDelim !== ".") {
          atom.leftDelim = ".";
          atom.isDirty = true;
        } else {
          parent.addChildrenAfter(atom.removeBranch("body"), atom);
          parent.removeChild(atom);
          pos--;
        }
      } else {
        if (atom.leftDelim !== "?" && atom.leftDelim !== ".") {
          atom.rightDelim = ".";
          atom.isDirty = true;
        } else {
          parent.addChildrenAfter(atom.removeBranch("body"), atom);
          parent.removeChild(atom);
          pos--;
        }
      }
      model.position = pos;
      return true;
    }
    if (parent && atom.type === "surd") {
      if (direction === "forward" && !branch || direction === "backward" && branch === "body") {
        const pos = atom.leftSibling;
        if (atom.hasChildren)
          parent.addChildrenAfter(atom.removeBranch("body"), atom);
        parent.removeChild(atom);
        model.position = model.offsetOf(pos);
      } else if (direction === "forward" && branch === "body") {
        model.position = model.offsetOf(atom);
      } else if (!branch && direction === "backward") {
        if (atom.hasChildren)
          model.position = model.offsetOf(atom.lastChild);
        else {
          model.position = Math.max(0, model.offsetOf(atom) - 1);
          parent.removeChild(atom);
        }
      } else if (branch === "above") {
        if (atom.hasEmptyBranch("above"))
          atom.removeBranch("above");
        if (direction === "backward") {
          model.position = model.offsetOf(atom.leftSibling);
        } else {
          model.position = model.offsetOf(atom.body[0]);
        }
      }
      return true;
    }
    if (parent && (atom.type === "box" || atom.type === "enclose")) {
      const pos = branch && direction === "backward" || !branch && direction === "forward" ? atom.leftSibling : atom.lastChild;
      parent.addChildrenAfter(atom.removeBranch("body"), atom);
      parent.removeChild(atom);
      model.position = model.offsetOf(pos);
      return true;
    }
    if (atom.type === "genfrac" || atom.type === "overunder") {
      if (!branch) {
        if (atom.type === "overunder" && atom.hasEmptyBranch("body"))
          return false;
        if (atom.type === "genfrac" && atom.hasEmptyBranch("below") && atom.hasEmptyBranch("above"))
          return false;
        model.position = model.offsetOf(
          direction === "forward" ? atom.firstChild : atom.lastChild
        );
        return true;
      }
      const firstBranch = atom.context.fractionNavigationOrder === "numerator-denominator" ? "above" : "below";
      const secondBranch = firstBranch === "above" ? "below" : "above";
      if (parent && (direction === "forward" && branch === firstBranch || direction === "backward" && branch === secondBranch)) {
        const first = atom.removeBranch(firstBranch);
        const second = atom.removeBranch(secondBranch);
        parent.addChildrenAfter([...first, ...second], atom);
        parent.removeChild(atom);
        model.position = model.offsetOf(
          first.length > 0 ? first[first.length - 1] : second[0]
        );
        return true;
      }
      if (direction === "backward")
        model.position = model.offsetOf(atom.leftSibling);
      else
        model.position = model.offsetOf(atom);
      return true;
    }
    if (atom.isExtensibleSymbol || atom.type === "msubsup") {
      if (!branch && direction === "forward")
        return false;
      if (!branch) {
        if (atom.subscript || atom.superscript) {
          const pos = direction === "forward" ? (_c2 = (_a3 = atom.superscript) == null ? void 0 : _a3[0]) != null ? _c2 : (_b3 = atom.subscript) == null ? void 0 : _b3[0] : (_f = (_d2 = atom.subscript) == null ? void 0 : _d2[0].lastSibling) != null ? _f : (_e = atom.superscript) == null ? void 0 : _e[0].lastSibling;
          if (pos)
            model.position = model.offsetOf(pos);
          return true;
        }
        return false;
      }
      if (branch && atom.hasEmptyBranch(branch))
        atom.removeBranch(branch);
      if (!atom.hasChildren) {
        const pos = direction === "forward" ? model.offsetOf(atom) : Math.max(0, model.offsetOf(atom) - 1);
        atom.parent.removeChild(atom);
        model.position = pos;
        return true;
      }
      if (branch === "superscript") {
        if (direction === "backward") {
          const pos = model.offsetOf(atom.firstChild) - 1;
          console.assert(pos >= 0);
          model.position = pos;
        } else if (atom.subscript)
          model.position = model.offsetOf(atom.subscript[0]);
        else
          model.position = model.offsetOf(atom);
      } else if (branch === "subscript") {
        if (direction === "backward" && atom.superscript) {
          model.position = model.offsetOf(atom.superscript[0].lastSibling);
        } else if (direction === "backward") {
          model.position = model.offsetOf(atom.firstChild) - 1;
        } else {
          model.position = model.offsetOf(atom);
        }
      }
      return true;
    }
    if ((parent == null ? void 0 : parent.type) === "genfrac" && !branch && atom.type !== "first") {
      let pos = model.offsetOf(atom.leftSibling);
      parent.removeChild(atom);
      if (parent.hasEmptyBranch("above") && parent.hasEmptyBranch("below")) {
        pos = model.offsetOf(parent.leftSibling);
        parent.parent.removeChild(parent);
        model.announce("delete", void 0, [parent]);
        model.position = pos;
        return true;
      }
      model.announce("delete", void 0, [atom]);
      model.position = pos;
      return true;
    }
    return false;
  }
  function deleteBackward(model) {
    if (!model.mathfield.isSelectionEditable)
      return false;
    if (!contentWillChange(model, { inputType: "deleteContentBackward" }))
      return false;
    if (!model.selectionIsCollapsed)
      return deleteRange(model, range(model.selection), "deleteContentBackward");
    return model.deferNotifications(
      { content: true, selection: true, type: "deleteContentBackward" },
      () => {
        let target = model.at(model.position);
        if (target && onDelete(model, "backward", target))
          return;
        if (target == null ? void 0 : target.isFirstSibling) {
          if (onDelete(model, "backward", target.parent, target.treeBranch))
            return;
          target = null;
        }
        if (!target) {
          model.announce("plonk");
          return;
        }
        model.position = model.offsetOf(target.leftSibling);
        target.parent.removeChild(target);
        model.announce("delete", void 0, [target]);
      }
    );
  }
  function deleteForward(model) {
    if (!model.mathfield.isSelectionEditable)
      return false;
    if (!contentWillChange(model, { inputType: "deleteContentForward" }))
      return false;
    if (!model.selectionIsCollapsed)
      return deleteRange(model, range(model.selection), "deleteContentForward");
    return model.deferNotifications(
      { content: true, selection: true, type: "deleteContentForward" },
      () => {
        var _a3, _b3;
        let target = model.at(model.position).rightSibling;
        if (target && onDelete(model, "forward", target))
          return;
        if (!target) {
          target = model.at(model.position);
          if (target.isLastSibling && onDelete(model, "forward", target.parent, target.treeBranch))
            return;
          target = void 0;
        } else if (model.at(model.position).isLastSibling && onDelete(model, "forward", target.parent, target.treeBranch))
          return;
        if (model.position === model.lastOffset || !target) {
          model.announce("plonk");
          return;
        }
        target.parent.removeChild(target);
        let sibling = (_a3 = model.at(model.position)) == null ? void 0 : _a3.rightSibling;
        while ((sibling == null ? void 0 : sibling.type) === "msubsup") {
          sibling.parent.removeChild(sibling);
          sibling = (_b3 = model.at(model.position)) == null ? void 0 : _b3.rightSibling;
        }
        model.announce("delete", void 0, [target]);
      }
    );
  }
  function deleteRange(model, range2, type) {
    const result = model.getAtoms(range2);
    if (result.length > 0 && result[0].parent) {
      let firstChild = result[0].parent.firstChild;
      if (firstChild.type === "first")
        firstChild = firstChild.rightSibling;
      const lastChild = result[result.length - 1].parent.lastChild;
      let firstSelected = result[0];
      if (firstSelected.type === "first")
        firstSelected = firstSelected.rightSibling;
      const lastSelected = result[result.length - 1];
      if (firstSelected === firstChild && lastSelected === lastChild) {
        const parent = result[0].parent;
        if (parent.type !== "root" && parent.type !== "prompt")
          range2 = [model.offsetOf(parent.leftSibling), model.offsetOf(parent)];
      }
      if (result.length === 1 && result[0].type === "placeholder" && result[0].parent.type === "genfrac") {
        const genfrac = result[0].parent;
        const branch = result[0].treeBranch === "below" ? "above" : "below";
        const pos = model.offsetOf(genfrac.leftSibling);
        return model.deferNotifications(
          { content: true, selection: true, type },
          () => {
            var _a3, _b3;
            const numer = genfrac.removeBranch(branch);
            if (!(numer.length === 1 && numer[0].type === "placeholder")) {
              const lastAtom = genfrac.parent.addChildrenAfter(numer, genfrac);
              (_a3 = genfrac.parent) == null ? void 0 : _a3.removeChild(genfrac);
              model.position = model.offsetOf(lastAtom);
            } else {
              (_b3 = genfrac.parent) == null ? void 0 : _b3.removeChild(genfrac);
              model.position = Math.max(0, pos);
            }
          }
        );
      }
    }
    return model.deferNotifications(
      { content: true, selection: true, type },
      () => model.deleteAtoms(range2)
    );
  }

  // src/editor-model/composition.ts
  function updateComposition(model, s) {
    const cursor = model.at(model.position);
    if (cursor.type === "composition") {
      cursor.value = s;
    } else {
      const { caret } = cursor;
      cursor.caret = "";
      const atom = new CompositionAtom(s, model.mathfield, { mode: cursor.mode });
      atom.caret = caret;
      cursor.parent.addChildAfter(atom, cursor);
      model.position += 1;
    }
  }
  function removeComposition(model) {
    const cursor = model.at(model.position);
    if (cursor.type === "composition") {
      cursor.parent.removeChild(cursor);
      model.position -= 1;
    }
  }

  // src/editor-model/selection.ts
  function getMode(model, offset) {
    const atom = model.at(offset);
    let result;
    if (atom) {
      result = atom.mode;
      let ancestor = atom.parent;
      while (!result && ancestor) {
        if (ancestor)
          result = ancestor.mode;
        ancestor = ancestor.parent;
      }
    }
    return result;
  }

  // src/editor-model/styling.ts
  function applyStyleToUnstyledAtoms(atom, style) {
    if (!atom || !style)
      return;
    if (isArray(atom)) {
      atom.forEach((x) => applyStyleToUnstyledAtoms(x, style));
    } else if (typeof atom === "object") {
      if (!atom.style.color && !atom.style.backgroundColor && !atom.style.fontFamily && !atom.style.fontShape && !atom.style.fontSeries && !atom.style.fontSize && !atom.style.variant && !atom.style.variantStyle) {
        atom.applyStyle(style);
        applyStyleToUnstyledAtoms(atom.body, style);
        applyStyleToUnstyledAtoms(atom.above, style);
        applyStyleToUnstyledAtoms(atom.below, style);
        applyStyleToUnstyledAtoms(atom.subscript, style);
        applyStyleToUnstyledAtoms(atom.superscript, style);
      }
    }
  }
  function applyStyle(model, range2, style, options) {
    function everyStyle(property, value) {
      for (const atom of atoms)
        if (atom.style[property] !== value)
          return false;
      return true;
    }
    range2 = model.normalizeRange(range2);
    if (range2[0] === range2[1])
      return false;
    const atoms = model.getAtoms(range2, { includeChildren: true });
    if (options.operation === "toggle") {
      if (style.color && everyStyle("color", style.color)) {
        style.color = "none";
        style.verbatimColor = void 0;
      }
      if (style.backgroundColor && everyStyle("backgroundColor", style.backgroundColor)) {
        style.backgroundColor = "none";
        style.verbatimBackgroundColor = void 0;
      }
      if (style.fontFamily && everyStyle("fontFamily", style.fontFamily)) {
        style.fontFamily = "none";
      }
      if (style.fontSeries && everyStyle("fontSeries", style.fontSeries)) {
        style.fontSeries = "auto";
      }
      if (style.fontShape && everyStyle("fontShape", style.fontShape)) {
        style.fontShape = "auto";
      }
      if (style.fontSize && everyStyle("fontSize", style.fontSize)) {
        style.fontSize = DEFAULT_FONT_SIZE;
      }
    }
    for (const atom of atoms)
      atom.applyStyle(style);
    return true;
  }

  // css/mathfield.less
  var mathfield_default = "@keyframes ML__caret-blink {\n  0%,\n  100% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0;\n  }\n}\n.ML__caret:after {\n  content: '';\n  border: none;\n  border-radius: 2px;\n  border-right: 2px solid var(--caret-color, var(--ML__caret-color));\n  margin-right: -2px;\n  position: relative;\n  left: -1px;\n  animation: ML__caret-blink 1.05s step-end forwards infinite;\n}\n.ML__text-caret:after {\n  content: '';\n  border: none;\n  border-radius: 1px;\n  border-right: 1px solid var(--caret-color, var(--ML__caret-color));\n  margin-right: -1px;\n  position: relative;\n  left: 0;\n  animation: ML__caret-blink 1.05s step-end forwards infinite;\n}\n.ML__latex-caret:after {\n  content: '_';\n  border: none;\n  margin-right: 0;\n  margin-right: calc(-1ex - 2px);\n  position: relative;\n  color: var(--caret-color, var(--ML__caret-color));\n  animation: ML__caret-blink 1.05s step-end forwards infinite;\n}\n.ML__container {\n  display: inline-flex;\n  flex-flow: row;\n  justify-content: space-between;\n  align-items: flex-end;\n  min-height: 39px;\n  /* Need some room for the virtual keyboard toggle */\n  width: 100%;\n  /* Encourage browsers to consider allocating a hardware accelerated\n   layer for this element. */\n  isolation: isolate;\n  /* Prevent the browser from trying to interpret touch gestures in the field */\n  /* \"Disabling double-tap to zoom removes the need for browsers to\n        delay the generation of click events when the user taps the screen.\" */\n  touch-action: none;\n  --ML__selection-background-color: hsl(var(--hue, 212), 97%, 85%);\n  --ML__text-highlight-background-color: hsla(var(--hue, 212), 40%, 50%, 0.1);\n  --ML__contains-highlight-background-color: hsl(var(--hue, 212), 40%, 95%);\n  --ML__selection-color: currentColor;\n  --ML__caret-color: hsl(var(--hue, 212), 40%, 49%);\n  --ML__smart-fence-color: currentColor;\n  --ML__latex-color: var(--primary, hsl(var(--hue, 212), 40%, 50%));\n  --ML__correct-color: #10a000;\n  --ML__incorrect-color: #a01b00;\n  --ML__placeholder-color: hsl(var(--hue, 212), 40%, 49%);\n}\n/* This is the actual field content (formula) */\n.ML__content {\n  display: flex;\n  align-items: center;\n  align-self: center;\n  position: relative;\n  overflow: hidden;\n  padding: 2px 0 2px 1px;\n  width: 100%;\n}\n.ML__virtual-keyboard-toggle {\n  box-sizing: border-box;\n  display: flex;\n  align-self: center;\n  align-items: center;\n  flex-shrink: 0;\n  flex-direction: column;\n  justify-content: center;\n  width: 34px;\n  height: 34px;\n  padding: 0;\n  margin-right: 4px;\n  cursor: pointer;\n  /* Avoid some weird blinking with :hover */\n  border-radius: 8px;\n  border: 1px solid transparent;\n  transition: background 0.2s cubic-bezier(0.64, 0.09, 0.08, 1);\n  color: var(--primary, hsl(var(--hue, 212), 40%, 50%));\n  fill: currentColor;\n  background: transparent;\n}\n.ML__virtual-keyboard-toggle:hover {\n  background: hsla(0, 0%, 70%, 0.3);\n  color: #333;\n  fill: currentColor;\n}\n.ML__virtual-keyboard-toggle > span {\n  display: flex;\n  align-self: center;\n  align-items: center;\n}\n/* The invisible element used to capture keyboard events. We're just trying\n really hard to make sure it doesn't show. */\n.ML__keyboard-sink {\n  display: inline-block;\n  resize: none;\n  outline: none;\n  border: none;\n  /* Need these for Microsoft Edge */\n  position: fixed;\n  clip: rect(0 0 0 0);\n  /* Need this to prevent iOS Safari from auto-zooming */\n  font-size: 1em;\n  font-family: KaTeX_Main;\n}\n.ML__focused .ML__text {\n  background: var(--highlight-text, var(--ML__text-highlight-background-color));\n}\n/* When using smartFence, the anticipated closing fence is displayed\nwith this style */\n.ML__smart-fence__close {\n  opacity: var(--smart-fence-opacity, 0.5);\n  color: var(--smart-fence-color, var(--ML__smart-fence-color));\n}\n.ML__focused .ML__selection {\n  background: var(--selection-background-color-focused, var(--selection-background-color, var(--ML__selection-background-color))) !important;\n}\n.ML__focused .ML__selected,\n.ML__focused .ML__selected .ML__contains-caret,\n.ML__focused .ML__selected .ML__smart-fence__close,\n.ML__focused .ML__selected .ML__placeholder {\n  color: var(--selection-color-focused, var(--selection-color, var(--ML__selection-color))) !important;\n}\n.ML__selection {\n  box-sizing: border-box;\n  background: var(--selection-background-color, var(--ML__selection-background-color)) !important;\n}\n.ML__selected,\n.ML__selected .ML__contains-caret,\n.ML__selected .ML__smart-fence__close,\n.ML__selected .ML__placeholder {\n  color: var(--selection-color, var(--ML__selection-color));\n  opacity: 1;\n}\n.ML__contains-caret.ML__close,\n.ML__contains-caret.ML__open,\n.ML__contains-caret > .ML__close,\n.ML__contains-caret > .ML__open,\n.ML__contains-caret .ML__sqrt-sign,\n.ML__contains-caret .ML__sqrt-line {\n  color: var(--caret-color, var(--ML__caret-color));\n}\n.ML__contains-highlight {\n  background: var(--contains-highlight-backround-color, var(--ML__contains-highlight));\n  box-sizing: border-box;\n}\n.ML__latex {\n  font-family: 'IBM Plex Mono', 'Source Code Pro', Consolas, 'Roboto Mono', Menlo, 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Monaco, Courier, monospace;\n  font-weight: 400;\n  color: var(--latex-color, var(--ML__latex-color));\n}\n.ML__suggestion {\n  opacity: 0.5;\n}\n.ML__virtual-keyboard-toggle.is-visible.is-pressed:hover {\n  background: hsl(var(--hue, 212), 25%, 35%);\n  color: #fafafa;\n  fill: currentColor;\n}\n.ML__virtual-keyboard-toggle:focus {\n  outline: none;\n  border-radius: 8px;\n  border: 2px solid var(--primary, hsl(var(--hue, 212), 40%, 50%));\n}\n.ML__virtual-keyboard-toggle.is-pressed,\n.ML__virtual-keyboard-toggle.is-active:hover,\n.ML__virtual-keyboard-toggle.is-active {\n  background: hsl(var(--hue, 212), 25%, 35%);\n  color: #fafafa;\n  fill: currentColor;\n}\n/* This class is used to implement the `\\mathtip` and `\\texttip` commands\n   For UI elements, see `[data-ML__tooltip]`\n*/\n.ML__tooltip-container {\n  position: relative;\n  transform: scale(0);\n}\n.ML__tooltip-container .ML__tooltip-content {\n  position: fixed;\n  display: inline-table;\n  visibility: hidden;\n  z-index: 2;\n  width: max-content;\n  max-width: 400px;\n  padding: 12px 12px;\n  border-radius: 8px;\n  background: #616161;\n  color: #fff;\n  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);\n  opacity: 0;\n  transition: opacity 0.15s cubic-bezier(0.4, 0, 1, 1);\n}\n.ML__tooltip-container .ML__tooltip-content .ML__text {\n  white-space: normal;\n}\n.ML__tooltip-container .ML__tooltip-content .ML__base {\n  display: contents;\n}\n.ML__tooltip-container:hover .ML__tooltip-content {\n  visibility: visible;\n  opacity: 1;\n  font-size: 0.75em;\n  transform: scale(1) translate(0, 3em);\n}\n/* Add an attribute 'data-ML__tooltip' to automatically show a\n   tooltip over a element on hover.\n   Use 'data-position=\"top\"' to place the tooltip above the\n   element rather than below.\n   Use 'data-delay' to delay the triggering of the tooltip.\n*/\n[data-ML__tooltip] {\n  position: relative;\n}\n[data-ML__tooltip][data-placement='top']::after {\n  top: inherit;\n  bottom: 100%;\n}\n[data-ML__tooltip]::after {\n  content: attr(data-ML__tooltip);\n  position: absolute;\n  display: none;\n  z-index: 2;\n  right: 110%;\n  left: calc(100% + 8px);\n  width: max-content;\n  max-width: 200px;\n  padding: 8px 8px;\n  border-radius: 2px;\n  background: #616161;\n  color: #fff;\n  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);\n  text-align: center;\n  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n  font-style: normal;\n  font-weight: 400;\n  font-size: 12px;\n  /* Phone */\n  opacity: 0;\n  transform: scale(0.5);\n  transition: all 0.15s cubic-bezier(0.4, 0, 1, 1);\n}\n@media only screen and (max-width: 767px) {\n  [data-ML__tooltip]::after {\n    padding: 8px 16px;\n    font-size: 16px;\n  }\n}\n:not(.tracking) [data-ML__tooltip]:hover {\n  position: relative;\n}\n:not(.tracking) [data-ML__tooltip]:hover::after {\n  visibility: visible;\n  display: inline-table;\n  opacity: 1;\n  transform: scale(1);\n}\n[data-ML__tooltip][data-delay]::after {\n  transition-delay: 0s;\n}\n[data-ML__tooltip][data-delay]:hover::after {\n  transition-delay: 1s;\n  /* attr(data-delay); Should work. But doesn't. */\n}\n";

  // src/editor/keyboard.ts
  var PRINTABLE_KEYCODE = /* @__PURE__ */ new Set([
    "Backquote",
    // Japanese keyboard: hankaku/zenkaku/kanji key, which is non-printable
    "Digit0",
    "Digit1",
    "Digit2",
    "Digit3",
    "Digit4",
    "Digit5",
    "Digit6",
    "Digit7",
    "Digit8",
    "Digit9",
    "Minus",
    "Equal",
    "IntlYen",
    // Japanese Keyboard. Russian keyboard: \/
    "KeyQ",
    // AZERTY keyboard: labeled 'a'
    "KeyW",
    // AZERTY keyboard: labeled 'z'
    "KeyE",
    "KeyR",
    "KeyT",
    "KeyY",
    // QWERTZ keyboard: labeled 'z'
    "KeyU",
    "KeyI",
    "KeyO",
    "KeyP",
    "BracketLeft",
    "BracketRight",
    // On the Windows Swedish keyboard, this is the `` key, which is a dead key
    "Backslash",
    // May be labeled #~ on UK 102 keyboard
    "KeyA",
    // AZERTY keyboard: labeled 'q'
    "KeyS",
    "KeyD",
    "KeyF",
    "KeyG",
    "KeyH",
    "KeyJ",
    "KeyK",
    "KeyL",
    "Semicolon",
    "Quote",
    "IntlBackslash",
    // QWERTZ keyboard '><'
    "KeyZ",
    // AZERTY: 'w', QWERTZ: 'y'
    "KeyX",
    "KeyC",
    "KeyV",
    "KeyB",
    "KeyN",
    "KeyM",
    "Comma",
    "Period",
    "Slash",
    "IntlRo",
    // Japanese keyboard '\'
    "Space",
    "Numpad0",
    "Numpad1",
    "Numpad2",
    "Numpad3",
    "Numpad4",
    "Numpad5",
    "Numpad6",
    "Numpad7",
    "Numpad8",
    "Numpad9",
    "NumpadAdd",
    "NumpadComma",
    "NumpadDecimal",
    "NumpadDivide",
    "NumpadEqual",
    "NumpadHash",
    "NumpadMultiply",
    "NumpadParenLeft",
    "NumpadParenRight",
    "NumpadStar",
    "NumpadSubstract"
  ]);
  function mightProducePrintableCharacter(evt) {
    if (evt.ctrlKey || evt.metaKey)
      return false;
    if (["Dead", "Process"].includes(evt.key))
      return false;
    if (evt.code === "")
      return true;
    return PRINTABLE_KEYCODE.has(evt.code);
  }
  function keyboardEventToString(evt) {
    evt = normalizeKeyboardEvent(evt);
    const modifiers = [];
    if (evt.ctrlKey)
      modifiers.push("ctrl");
    if (evt.metaKey)
      modifiers.push("meta");
    if (evt.altKey)
      modifiers.push("alt");
    if (evt.shiftKey)
      modifiers.push("shift");
    if (modifiers.length === 0)
      return "[" + evt.code + "]";
    modifiers.push("[" + evt.code + "]");
    return modifiers.join("+");
  }
  function delegateKeyboardEvents(keyboardSink, element, handlers) {
    let keydownEvent = null;
    let keypressEvent = null;
    let compositionInProgress = false;
    let focusInProgress = false;
    let blurInProgress = false;
    keyboardSink.addEventListener(
      "keydown",
      (event) => {
        if (compositionInProgress || event.key === "Process" || event.code === "CapsLock" || /(Control|Meta|Alt|Shift)(Left|Right)/.test(event.code)) {
          keydownEvent = null;
          return;
        }
        keydownEvent = event;
        keypressEvent = null;
        if (!handlers.onKeystroke(keyboardEventToString(event), event))
          keydownEvent = null;
        else
          keyboardSink.textContent = "";
      },
      true
    );
    keyboardSink.addEventListener(
      "keypress",
      (event) => {
        if (compositionInProgress)
          return;
        if (keydownEvent && keypressEvent)
          handlers.onKeystroke(keyboardEventToString(keydownEvent), keydownEvent);
        keypressEvent = event;
      },
      true
    );
    keyboardSink.addEventListener(
      "compositionstart",
      (event) => {
        keyboardSink.textContent = "";
        compositionInProgress = true;
        handlers.onCompositionStart(event.data);
      },
      true
    );
    keyboardSink.addEventListener(
      "compositionupdate",
      (ev) => {
        if (!compositionInProgress)
          return;
        handlers.onCompositionUpdate(ev.data);
      },
      true
    );
    keyboardSink.addEventListener(
      "compositionend",
      (ev) => {
        keyboardSink.textContent = "";
        if (!compositionInProgress)
          return;
        compositionInProgress = false;
        handlers.onCompositionEnd(ev.data);
      },
      true
    );
    keyboardSink.addEventListener(
      "beforeinput",
      (ev) => ev.stopImmediatePropagation()
    );
    keyboardSink.addEventListener("input", (ev) => {
      var _a3;
      if (compositionInProgress)
        return;
      keyboardSink.textContent = "";
      if (ev.inputType === "insertCompositionText")
        return;
      if (ev.inputType === "insertFromPaste") {
        ev.preventDefault();
        ev.stopPropagation();
        return;
      }
      handlers.onInput((_a3 = ev.data) != null ? _a3 : "");
      ev.preventDefault();
      ev.stopPropagation();
    });
    keyboardSink.addEventListener(
      "paste",
      (event) => {
        keyboardSink.focus();
        keyboardSink.textContent = "";
        if (!handlers.onPaste(event))
          event.preventDefault();
        event.stopImmediatePropagation();
      },
      true
    );
    keyboardSink.addEventListener("cut", (ev) => handlers.onCut(ev), true);
    keyboardSink.addEventListener("copy", (ev) => handlers.onCopy(ev), true);
    keyboardSink.addEventListener(
      "blur",
      (event) => {
        var _a3, _b3, _c2, _d2;
        if (((_b3 = (_a3 = event["relatedTarget"]) == null ? void 0 : _a3["_mathfield"]) == null ? void 0 : _b3["element"]) === element) {
          keyboardSink.focus();
          event.preventDefault();
          event.stopPropagation();
          return;
        }
        const scrimState = (_c2 = Scrim.scrim) == null ? void 0 : _c2.state;
        if (scrimState === "open" || scrimState === "opening") {
          event.preventDefault();
          event.stopPropagation();
          return;
        }
        if (event.relatedTarget === event.target.getRootNode().host) {
          event.preventDefault();
          event.stopPropagation();
          return;
        }
        if (blurInProgress || focusInProgress)
          return;
        blurInProgress = true;
        keydownEvent = null;
        keypressEvent = null;
        (_d2 = handlers.onBlur) == null ? void 0 : _d2.call(handlers);
        blurInProgress = false;
      },
      true
    );
    keyboardSink.addEventListener(
      "focus",
      (_evt) => {
        var _a3;
        if (blurInProgress || focusInProgress)
          return;
        focusInProgress = true;
        (_a3 = handlers.onFocus) == null ? void 0 : _a3.call(handlers);
        focusInProgress = false;
      },
      true
    );
    return {
      cancelComposition: () => {
        var _a3;
        const sel = window.getSelection();
        const range2 = sel == null ? void 0 : sel.getRangeAt(0);
        keyboardSink.blur();
        (_a3 = window.getSelection()) == null ? void 0 : _a3.removeAllRanges();
        setTimeout(() => sel == null ? void 0 : sel.addRange(range2), 20);
      },
      blur: () => {
        if (typeof keyboardSink.blur === "function")
          keyboardSink.blur();
      },
      focus: () => {
        if (!focusInProgress && typeof keyboardSink.focus === "function")
          keyboardSink.focus();
      },
      hasFocus: () => {
        return deepActiveElement2() === keyboardSink;
      },
      setAriaLabel: (value) => keyboardSink.setAttribute("aria-label", value),
      setValue: (value) => {
        var _a3;
        keyboardSink.textContent = value;
        keyboardSink.style.top = `-1000px`;
        (_a3 = window.getSelection()) == null ? void 0 : _a3.selectAllChildren(keyboardSink);
      },
      moveTo: (x, y) => {
        keyboardSink.style.top = `${y}px`;
        keyboardSink.style.left = `${x}px`;
      }
    };
  }
  function deepActiveElement2() {
    var _a3;
    let a = document.activeElement;
    while ((_a3 = a == null ? void 0 : a.shadowRoot) == null ? void 0 : _a3.activeElement)
      a = a.shadowRoot.activeElement;
    return a;
  }
  function eventToChar(evt) {
    var _a3;
    if (!evt)
      return "";
    let result;
    if (evt.key === "Unidentified") {
      if (evt.target)
        result = evt.target.value;
    }
    result = (_a3 = result != null ? result : evt.key) != null ? _a3 : evt.code;
    if (/^(Dead|Return|Enter|Tab|Escape|Delete|PageUp|PageDown|Home|End|Help|ArrowLeft|ArrowRight|ArrowUp|ArrowDown)$/.test(
      result
    ))
      result = "";
    return result;
  }

  // src/editor/undo.ts
  var UndoManager = class {
    // Index pointing to the current record in the undo/redo stack
    constructor(model) {
      this.recording = false;
      this.canCoalesce = false;
      this.model = model;
      this.reset();
    }
    // Maximum number of undo/redo states
    get maximumDepth() {
      return 1e3;
    }
    reset() {
      this.stack = [];
      this.index = -1;
    }
    startRecording() {
      this.recording = true;
    }
    canUndo() {
      return this.index > 0;
    }
    canRedo() {
      return this.index !== this.stack.length - 1;
    }
    undo() {
      if (!this.canUndo())
        return false;
      this.model.setState(this.stack[this.index - 1], {
        suppressChangeNotifications: false,
        type: "undo"
      });
      this.index -= 1;
      this.canCoalesce = false;
      return true;
    }
    redo() {
      if (!this.canRedo())
        return false;
      this.index += 1;
      this.model.setState(this.stack[this.index], {
        suppressChangeNotifications: false,
        type: "redo"
      });
      this.canCoalesce = false;
      return true;
    }
    pop() {
      if (!this.canUndo())
        return;
      this.index -= 1;
      this.stack.pop();
    }
    /**
     * Push a snapshot of the content and selection of the mathfield onto the
     * undo stack so that it can potentially be reverted to later.
     *
     * **Return** `true` if the undo state changed
     */
    snapshot() {
      if (!this.recording)
        return false;
      this.stack.splice(this.index + 1, this.stack.length - this.index - 1);
      this.stack.push(this.model.getState());
      this.index++;
      if (this.stack.length > this.maximumDepth)
        this.stack.shift();
      this.canCoalesce = false;
      return true;
    }
    snapshotAndCoalesce() {
      if (!this.recording)
        return false;
      if (this.canCoalesce)
        this.pop();
      const result = this.snapshot();
      this.canCoalesce = true;
      return result;
    }
  };

  // src/editor-model/commands-move.ts
  function moveAfterParent(model) {
    const previousPosition = model.position;
    const parent = model.at(previousPosition).parent;
    if (!parent || parent.type === "root") {
      model.announce("plonk");
      return false;
    }
    model.position = model.offsetOf(parent);
    model.announce("move", previousPosition);
    return true;
  }
  function superscriptDepth(model) {
    let result = 0;
    let atom = model.at(model.position);
    let wasSuperscript = false;
    while (atom) {
      if (!atom.hasEmptyBranch("superscript") || !atom.hasEmptyBranch("subscript"))
        result += 1;
      if (!atom.hasEmptyBranch("superscript"))
        wasSuperscript = true;
      else if (!atom.hasEmptyBranch("subscript"))
        wasSuperscript = false;
      atom = atom.parent;
    }
    return wasSuperscript ? result : 0;
  }
  function subscriptDepth(model) {
    let result = 0;
    let atom = model.at(model.position);
    let wasSubscript = false;
    while (atom) {
      if (!atom.hasEmptyBranch("superscript") || !atom.hasEmptyBranch("subscript"))
        result += 1;
      if (!atom.hasEmptyBranch("superscript"))
        wasSubscript = false;
      else if (!atom.hasEmptyBranch("subscript"))
        wasSubscript = true;
      atom = atom.parent;
    }
    return wasSubscript ? result : 0;
  }
  function moveToSuperscript(model) {
    var _a3;
    model.collapseSelection();
    if (superscriptDepth(model) >= model.mathfield.options.scriptDepth[1]) {
      model.announce("plonk");
      return false;
    }
    let target = model.at(model.position);
    if (target.subsupPlacement === void 0) {
      if (((_a3 = target.rightSibling) == null ? void 0 : _a3.type) !== "msubsup") {
        target.parent.addChildAfter(
          new SubsupAtom(model.mathfield, { style: target.computedStyle }),
          target
        );
      }
      target = target.rightSibling;
    }
    target.createBranch("superscript");
    model.setSelection(
      model.getSiblingsRange(model.offsetOf(target.superscript[0]))
    );
    return true;
  }
  function moveToSubscript(model) {
    var _a3;
    model.collapseSelection();
    if (subscriptDepth(model) >= model.mathfield.options.scriptDepth[0]) {
      model.announce("plonk");
      return false;
    }
    let target = model.at(model.position);
    if (target.subsupPlacement === void 0) {
      if (((_a3 = model.at(model.position + 1)) == null ? void 0 : _a3.type) !== "msubsup") {
        target.parent.addChildAfter(
          new SubsupAtom(model.mathfield, {
            style: model.at(model.position).computedStyle
          }),
          target
        );
      }
      target = model.at(model.position + 1);
    }
    target.createBranch("subscript");
    model.setSelection(
      model.getSiblingsRange(model.offsetOf(target.subscript[0]))
    );
    return true;
  }
  function getTabbableElements() {
    function tabbable(element) {
      const regularTabbables = [];
      const orderedTabbables = [];
      const candidates = [
        ...element.querySelectorAll(`input, select, textarea, a[href], button,
        [tabindex], audio[controls], video[controls],
        [contenteditable]:not([contenteditable="false"]), details>summary`)
      ].filter(isNodeMatchingSelectorTabbable);
      candidates.forEach((candidate, i) => {
        const candidateTabindex = getTabindex(candidate);
        if (candidateTabindex === 0)
          regularTabbables.push(candidate);
        else {
          orderedTabbables.push({
            documentOrder: i,
            tabIndex: candidateTabindex,
            node: candidate
          });
        }
      });
      return orderedTabbables.sort(
        (a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex
      ).map((a) => a.node).concat(regularTabbables);
    }
    function isNodeMatchingSelectorTabbable(element) {
      if (!isNodeMatchingSelectorFocusable(element) || isNonTabbableRadio(element) || getTabindex(element) < 0)
        return false;
      return true;
    }
    function isNodeMatchingSelectorFocusable(node) {
      if (node.disabled || node.type === "hidden" && node.tagName.toUpperCase() === "INPUT" || isHidden(node))
        return false;
      return true;
    }
    function getTabindex(node) {
      var _a3;
      const tabindexAttr = Number.parseInt(
        (_a3 = node.getAttribute("tabindex")) != null ? _a3 : "NaN",
        10
      );
      if (!Number.isNaN(tabindexAttr))
        return tabindexAttr;
      if (node.contentEditable === "true")
        return 0;
      if ((node.nodeName === "AUDIO" || node.nodeName === "VIDEO") && node.getAttribute("tabindex") === null)
        return 0;
      return node.tabIndex;
    }
    function isNonTabbableRadio(node) {
      return node.tagName.toUpperCase() === "INPUT" && node.type === "radio" && !isTabbableRadio(node);
    }
    function getCheckedRadio(nodes, form) {
      for (const node of nodes)
        if (node.checked && node.form === form)
          return node;
      return null;
    }
    function isTabbableRadio(node) {
      var _a3;
      if (!node.name)
        return true;
      const radioScope = (_a3 = node.form) != null ? _a3 : node.ownerDocument;
      const radioSet = radioScope.querySelectorAll(
        'input[type="radio"][name="' + node.name + '"]'
      );
      const checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    }
    function isHidden(element) {
      if (!isBrowser() || element === document.activeElement || element.contains(document.activeElement))
        return false;
      if (getComputedStyle(element).visibility === "hidden")
        return true;
      const bounds = element.getBoundingClientRect();
      if (bounds.width === 0 || bounds.height === 0)
        return true;
      while (element) {
        if (getComputedStyle(element).display === "none")
          return true;
        element = element.parentElement;
      }
      return false;
    }
    if (!isBrowser())
      return [];
    return tabbable(document.body);
  }
  function leap(model, dir, callHooks = true) {
    var _a3, _b3;
    const dist = dir === "forward" ? 1 : -1;
    if (model.at(model.anchor).type === "placeholder")
      move(model, dir);
    let origin;
    const parentPrompt = model.at(model.anchor).parentPrompt;
    if (parentPrompt) {
      if (dir === "forward")
        origin = model.offsetOf(parentPrompt) + 1;
      else
        origin = model.offsetOf(parentPrompt.leftSibling);
    } else
      origin = Math.max(model.position + dist, 0);
    const target = model.findAtom(
      (atom) => atom.type === "placeholder" || atom.type === "prompt" || !model.mathfield.readOnly && atom.treeDepth > 2 && atom.isFirstSibling && atom.isLastSibling,
      origin,
      dir
    );
    if (!target || dir === "forward" && model.offsetOf(target) < origin || dir === "backward" && model.offsetOf(target) > origin) {
      const handled = !callHooks || !((_b3 = (_a3 = model.mathfield.host) == null ? void 0 : _a3.dispatchEvent(
        new CustomEvent("move-out", {
          detail: { direction: dir },
          cancelable: true,
          bubbles: true,
          composed: true
        })
      )) != null ? _b3 : true);
      if (handled) {
        model.announce("plonk");
        return false;
      }
      const tabbable = getTabbableElements();
      if (!document.activeElement || tabbable.length <= 1) {
        model.announce("plonk");
        return false;
      }
      let index = tabbable.indexOf(document.activeElement) + dist;
      if (index < 0)
        index = tabbable.length - 1;
      if (index >= tabbable.length)
        index = 0;
      tabbable[index].focus();
      return true;
    }
    const previousPosition = model.position;
    if (target.type === "prompt") {
      model.setSelection(
        model.offsetOf(target.firstChild),
        model.offsetOf(target.lastChild)
      );
    } else {
      const newPosition = model.offsetOf(target);
      if (target.type === "placeholder")
        model.setSelection(newPosition - 1, newPosition);
      else
        model.position = newPosition;
    }
    model.announce("move", previousPosition);
    return true;
  }
  register2(
    {
      moveToOpposite: (model) => {
        const OPPOSITE_RELATIONS = {
          superscript: "subscript",
          subscript: "superscript",
          above: "below",
          below: "above"
        };
        const cursor = model.at(model.position);
        const { parent } = cursor;
        if (!parent) {
          model.announce("plonk");
          return false;
        }
        const relation = cursor.treeBranch;
        let oppositeRelation;
        if (typeof relation === "string")
          oppositeRelation = OPPOSITE_RELATIONS[relation];
        if (!oppositeRelation) {
          if (!cursor.subsupPlacement)
            return moveToSuperscript(model);
          return moveToSubscript(model);
        }
        if (!parent.branch(oppositeRelation)) {
          parent.createBranch(oppositeRelation);
        }
        return model.setSelection(
          model.getBranchRange(model.offsetOf(parent), oppositeRelation)
        );
      },
      moveBeforeParent: (model) => {
        const { parent } = model.at(model.position);
        if (!parent) {
          model.announce("plonk");
          return false;
        }
        model.position = model.offsetOf(parent);
        return true;
      },
      moveAfterParent: (model) => moveAfterParent(model),
      moveToNextPlaceholder: (model) => leap(model, "forward"),
      moveToPreviousPlaceholder: (model) => leap(model, "backward"),
      moveToNextChar: (model) => move(model, "forward"),
      moveToPreviousChar: (model) => move(model, "backward"),
      moveUp: (model) => move(model, "upward"),
      moveDown: (model) => move(model, "downward"),
      moveToNextWord: (model) => skip(model, "forward"),
      moveToPreviousWord: (model) => skip(model, "backward"),
      moveToGroupStart: (model) => {
        const pos = model.offsetOf(model.at(model.position).firstSibling);
        if (pos === model.position) {
          model.announce("plonk");
          return false;
        }
        model.position = pos;
        return true;
      },
      moveToGroupEnd: (model) => {
        const pos = model.offsetOf(model.at(model.position).lastSibling);
        if (pos === model.position) {
          model.announce("plonk");
          return false;
        }
        model.position = pos;
        return true;
      },
      moveToMathfieldStart: (model) => {
        if (model.position === 0) {
          model.announce("plonk");
          return false;
        }
        model.position = 0;
        return true;
      },
      moveToMathfieldEnd: (model) => {
        if (model.position === model.lastOffset) {
          model.announce("plonk");
          return false;
        }
        model.position = model.lastOffset;
        return true;
      },
      moveToSuperscript: (model) => moveToSuperscript(model),
      moveToSubscript: (model) => moveToSubscript(model)
    },
    { target: "model", category: "selection-anchor" }
  );

  // src/editor-mathfield/smartmode.ts
  function convertLastAtomsToText(model, count, until) {
    if (typeof count === "function") {
      until = count;
      count = Infinity;
    }
    if (count === void 0)
      count = Infinity;
    let i = model.position;
    let done = false;
    let text = "";
    while (!done) {
      const atom = model.at(i);
      done = count === 0 || atom === void 0 || atom.mode !== "math" || !(/mord|textord|mpunct/.test(atom.type) || atom.type === "mop" && /[a-zA-Z]+/.test(atom.value)) || !atom.hasEmptyBranch("superscript") || !atom.hasEmptyBranch("subscript") || typeof until === "function" && !until(atom);
      if (!done) {
        atom.mode = "text";
        atom.command = atom.value;
        atom.verbatimLatex = void 0;
        text += atom.value;
      }
      i -= 1;
      count -= 1;
    }
    contentDidChange(model, { data: text, inputType: "insertText" });
  }
  function convertLastAtomsToMath(model, count, until) {
    if (typeof count === "function") {
      until = count;
      count = Infinity;
    }
    if (count === void 0)
      count = Infinity;
    let i = model.position;
    let done = false;
    const data = [];
    while (!done) {
      const atom = model.at(i);
      done = count === 0 || !atom || atom.isFirstSibling || atom.mode !== "text" || atom.value === " " || until && !until(atom);
      if (!done) {
        data.push(atom.serialize({ defaultMode: "math" }));
        atom.mode = "math";
      }
      i -= 1;
      count -= 1;
    }
    removeIsolatedSpace(model);
    contentDidChange(model, { data: joinLatex(data), inputType: "insertText" });
  }
  function removeIsolatedSpace(model) {
    var _a3;
    let i = model.position - 1;
    while (i >= 0 && ((_a3 = model.at(i)) == null ? void 0 : _a3.mode) === "math")
      i -= 1;
    if (i < 0)
      return;
    if (model.at(i).mode === "text" && model.at(i).value === " " && model.at(i - 1).mode === "math") {
      model.at(i - 1).parent.removeChild(model.at(i - 1));
      const save = model.suppressChangeNotifications;
      model.suppressChangeNotifications = true;
      model.position -= 1;
      model.suppressChangeNotifications = save;
      contentDidChange(model, { inputType: "deleteContent" });
    }
  }
  function getTextBeforePosition(model) {
    let result = "";
    let i = model.position;
    let done = false;
    while (!done) {
      const atom = model.at(i);
      done = !(atom && (atom.mode === "text" || atom.mode === "math" && /mord|textord|mpunct/.test(atom.type)));
      if (!done)
        result = atom.value + result;
      i -= 1;
    }
    return result;
  }
  function smartMode(mathfield, keystroke, evt) {
    if (mathfield.smartModeSuppressed)
      return false;
    const { model } = mathfield;
    if (!model.at(model.position).isLastSibling)
      return false;
    if (!evt || !mightProducePrintableCharacter(evt))
      return false;
    const c = eventToChar(evt);
    if (!model.selectionIsCollapsed) {
      if (mathfield.mode === "text") {
        if (/[/_^]/.test(c))
          return true;
      }
      return false;
    }
    const context = getTextBeforePosition(model) + c;
    if (mathfield.mode === "text") {
      if (keystroke === "Esc" || /[/\\]/.test(c)) {
        return true;
      }
      if (/[\^_]/.test(c)) {
        if (/(^|\s)[a-zA-Z][^_]$/.test(context)) {
          convertLastAtomsToMath(model, 1);
        }
        return true;
      }
      const lFence = { ")": "(", "}": "{", "]": "[" }[c];
      const { parent } = model.at(model.position);
      if (lFence && parent instanceof LeftRightAtom && parent.leftDelim === lFence)
        return true;
      if (/(^|[^a-zA-Z])(a|I) $/.test(context)) {
        return false;
      }
      if (/[$]/u.test(c)) {
        return true;
      }
      if (/(^|[^a-zA-Z'])[a-zA-Z] $/.test(context)) {
        convertLastAtomsToMath(model, 1);
        return false;
      }
      if (/\D\.[^\d\s]$/.test(context)) {
        convertLastAtomsToMath(model, 1);
        const atom = model.at(model.position);
        atom.value = "\u22C5";
        atom.style.variant = "normal";
        atom.command = "\\cdot";
        atom.verbatimLatex = void 0;
        contentDidChange(model, { data: "\\cdot", inputType: "insertText" });
        return true;
      }
      if (/(^|\s)[a-zA-Z][^a-zA-Z]$/.test(context)) {
        convertLastAtomsToMath(model, 1);
        return true;
      }
      if (/\.\d$/.test(context)) {
        convertLastAtomsToMath(model, 1);
        return true;
      }
      if (/\([\d+\-.]$/.test(context)) {
        convertLastAtomsToMath(model, 1);
        return true;
      }
      if (/\([a-z][,;]$/.test(context)) {
        convertLastAtomsToMath(model, 2);
        return true;
      }
      if (/[\d+\-=><*|]$/.test(c)) {
        removeIsolatedSpace(model);
        return true;
      }
    } else {
      if (keystroke === "[Space]") {
        convertLastAtomsToText(
          model,
          void 0,
          (a) => /[a-z][:,;.]$/.test(a.value)
        );
        return true;
      }
      if (/[a-zA-Z]{3,}$/.test(context) && !/(dxd|abc|xyz|uvw)$/.test(context)) {
        convertLastAtomsToText(model, void 0, (a) => /[a-zA-Z]/.test(a.value));
        return true;
      }
      if (/(^|\W)(if)$/i.test(context)) {
        convertLastAtomsToText(model, 1);
        return true;
      }
      if (/(\u0393|\u0394|\u0398|\u039B|\u039E|\u03A0|\u03A3|\u03A5|\u03A6|\u03A8|\u03A9|[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5){3,}$/u.test(
        context
      ) && !/()$/.test(context)) {
        convertLastAtomsToText(
          model,
          void 0,
          (a) => /(:|,|;|.|\u0393|\u0394|\u0398|\u039B|\u039E|\u03A0|\u03A3|\u03A5|\u03A6|\u03A8|\u03A9|[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5)/u.test(
            a.value
          )
        );
        return true;
      }
      if (c === "?") {
        return true;
      }
      if (c === "." && !/[\d-+]\.$/.test(context)) {
        return true;
      }
    }
    return false;
  }

  // css/keystroke-caption.less
  var keystroke_caption_default = "/* The element that displays the keys as the user type them */\n#mathlive-keystroke-caption-panel {\n  visibility: hidden;\n  /*min-width: 160px;*/\n  /*background-color: rgba(97, 97, 200, .95);*/\n  background: var(--secondary, hsl(var(--hue, 212), 19%, 26%));\n  border-color: var(--secondary-border, hsl(0, 0%, 91%));\n  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);\n  text-align: center;\n  border-radius: 6px;\n  padding: 16px;\n  position: absolute;\n  z-index: 1;\n  display: flex;\n  flex-direction: row-reverse;\n  justify-content: center;\n  --keystroke: white;\n  --on-keystroke: #555;\n  --keystroke-border: #f7f7f7;\n}\n@media (prefers-color-scheme: dark) {\n  body:not([theme='light']) #mathlive-keystroke-caption-panel {\n    --keystroke: hsl(var(--hue, 212), 50%, 30%);\n    --on-keystroke: hsl(0, 0%, 98%);\n    --keystroke-border: hsl(var(--hue, 212), 50%, 25%);\n  }\n}\nbody[theme='dark'] #mathlive-keystroke-caption-panel {\n  --keystroke: hsl(var(--hue, 212), 50%, 30%);\n  --on-keystroke: hsl(0, 0%, 98%);\n  --keystroke-border: hsl(var(--hue, 212), 50%, 25%);\n}\n#mathlive-keystroke-caption-panel > span {\n  min-width: 14px;\n  /*height: 8px;*/\n  margin: 0 8px 0 0;\n  padding: 4px;\n  background-color: var(--keystroke);\n  color: var(--on-keystroke);\n  fill: currentColor;\n  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n  font-size: 1em;\n  border-radius: 6px;\n  border: 2px solid var(--keystroke-border);\n  /*box-shadow: 0 7px 14px rgba(0,0,0,0.25), 0 5px 5px rgba(0,0,0,0.22);*/\n}\n";

  // src/editor-mathfield/keystroke-caption.ts
  var KEYSTROKE_CAPTION_STYLESHEET_HASH = void 0;
  var gKeystrokeCaptionStylesheet = null;
  var gCoreStylesheet3 = null;
  function showKeystroke(mathfield, keystroke) {
    if (!mathfield.isSelectionEditable || !mathfield.keystrokeCaptionVisible)
      return;
    const vb = createKeystrokeCaption(mathfield);
    const bounds = mathfield.element.getBoundingClientRect();
    vb.style.left = `${bounds.left}px`;
    vb.style.top = `${bounds.top - 64}px`;
    vb.innerHTML = window.MathfieldElement.createHTML(
      "<span>" + (getKeybindingMarkup(keystroke) || keystroke) + "</span>" + vb.innerHTML
    );
    vb.style.visibility = "visible";
    setTimeout(() => {
      if (vb.childNodes.length > 0)
        vb.childNodes[vb.childNodes.length - 1].remove();
      if (vb.childNodes.length === 0)
        vb.style.visibility = "hidden";
    }, 3e3);
  }
  function toggleKeystrokeCaption(mathfield) {
    mathfield.keystrokeCaptionVisible = !mathfield.keystrokeCaptionVisible;
    if (!mathfield.keystrokeCaptionVisible) {
      if (mathfield.keystrokeCaption)
        mathfield.keystrokeCaption.style.visibility = "hidden";
    } else {
      mathfield.keystrokeCaption = createKeystrokeCaption(mathfield);
      mathfield.keystrokeCaption.innerHTML = "";
    }
    return false;
  }
  function createKeystrokeCaption(mf) {
    if (mf.keystrokeCaption)
      return mf.keystrokeCaption;
    mf.keystrokeCaption = getSharedElement("mathlive-keystroke-caption-panel");
    if (KEYSTROKE_CAPTION_STYLESHEET_HASH === void 0) {
      KEYSTROKE_CAPTION_STYLESHEET_HASH = hashCode(
        keystroke_caption_default
      ).toString(36);
    }
    gKeystrokeCaptionStylesheet = inject(
      null,
      keystroke_caption_default,
      KEYSTROKE_CAPTION_STYLESHEET_HASH
    );
    gCoreStylesheet3 = inject(
      null,
      core_default,
      hashCode(core_default).toString(36)
    );
    return mf.keystrokeCaption;
  }
  function disposeKeystrokeCaption(mf) {
    releaseSharedElement(mf.keystrokeCaption);
    if (gKeystrokeCaptionStylesheet)
      gKeystrokeCaptionStylesheet.release();
    if (gCoreStylesheet3)
      gCoreStylesheet3.release();
    delete mf.keystrokeCaption;
  }

  // src/editor-mathfield/mode-editor-math.ts
  var MathModeEditor = class extends ModeEditor {
    constructor() {
      super("math");
    }
    onPaste(mathfield, data) {
      if (!data)
        return false;
      if (!contentWillChange(mathfield.model, {
        data: typeof data === "string" ? data : null,
        dataTransfer: typeof data === "string" ? null : data,
        inputType: "insertFromPaste"
      }))
        return false;
      let text = "";
      let format = "auto";
      let json = typeof data !== "string" ? data.getData("application/json+mathlive") : "";
      if (json) {
        try {
          const atomJson = JSON.parse(json);
          if (atomJson && Array.isArray(atomJson)) {
            mathfield.snapshot();
            const atoms = fromJson(atomJson, mathfield);
            const { model } = mathfield;
            if (!model.selectionIsCollapsed)
              model.deleteAtoms(range(model.selection));
            const cursor = model.at(model.position);
            if (cursor.parent instanceof ArrayAtom) {
              console.assert(cursor.treeBranch !== void 0);
              const columns = [];
              let buffer = [];
              if (atoms[0].type === "first")
                atoms.shift();
              if (atoms[atoms.length - 1].type === "first")
                atoms.pop();
              for (const atom of atoms) {
                if (atom.type === "first" && buffer.length > 0) {
                  columns.push(buffer);
                  buffer = [atom];
                } else
                  buffer.push(atom);
              }
              if (buffer.length > 0)
                columns.push(buffer);
              let currentRow = Number(cursor.treeBranch[0]);
              let currentColumn = Number(cursor.treeBranch[1]);
              const maxColumns = cursor.parent.maxColumns;
              while (cursor.parent.colCount - currentColumn < columns.length && cursor.parent.colCount < maxColumns)
                cursor.parent.addColumn();
              cursor.parent.addChildrenAfter(columns[0], cursor);
              for (let i = 1; i < columns.length; i++) {
                currentColumn++;
                if (currentColumn >= maxColumns) {
                  currentColumn = 0;
                  cursor.parent.addRowAfter(currentRow);
                  currentRow++;
                }
                cursor.parent.setCell(currentRow, currentColumn, columns[i]);
              }
            } else {
              cursor.parent.addChildrenAfter(
                atoms.filter((a) => a.type !== "first"),
                cursor
              );
            }
            model.position = model.offsetOf(atoms[atoms.length - 1]);
            contentDidChange(model, { inputType: "insertFromPaste" });
            requestUpdate(mathfield);
            return true;
          }
        } catch (e) {
        }
      }
      json = typeof data !== "string" ? data.getData("application/json") : "";
      if (json && window.MathfieldElement.computeEngine) {
        try {
          const expr = JSON.parse(json);
          if (typeof expr === "object" && "latex" in expr && expr.latex)
            text = expr.latex;
          if (!text) {
            const box = window.MathfieldElement.computeEngine.box(expr);
            if (box && !box.has("Error"))
              text = box.latex;
          }
          if (!text)
            format = "latex";
        } catch (e) {
        }
      }
      if (!text && typeof data !== "string") {
        text = data.getData("application/x-latex");
        if (text)
          format = "latex";
      }
      if (!text)
        text = typeof data === "string" ? data : data.getData("text/plain");
      if (text) {
        mathfield.snapshot();
        let wasLatex;
        [wasLatex, text] = trimModeShiftCommand(text);
        if (format === "auto" && wasLatex)
          format = "latex";
        if (this.insert(mathfield.model, text, { format }))
          requestUpdate(mathfield);
        return true;
      }
      return false;
    }
    insert(model, input, options) {
      var _a3, _b3;
      const data = typeof input === "string" ? input : (_b3 = (_a3 = window.MathfieldElement.computeEngine) == null ? void 0 : _a3.box(input).latex) != null ? _b3 : "";
      if (!options.suppressChangeNotifications && !contentWillChange(model, { data, inputType: "insertText" }))
        return false;
      if (!options.insertionMode)
        options.insertionMode = "replaceSelection";
      if (!options.selectionMode)
        options.selectionMode = "placeholder";
      if (!options.format)
        options.format = "auto";
      if (!model.mathfield.smartFence) {
        if (options.insertionMode !== "replaceAll") {
          const { parent: parent2 } = model.at(model.position);
          if (parent2 instanceof LeftRightAtom && parent2.rightDelim === "?" && model.at(model.position).isLastSibling && typeof input === "string" && /^[)}\]|]$/.test(input)) {
            parent2.isDirty = true;
            parent2.rightDelim = input;
            model.position += 1;
            selectionDidChange(model);
            contentDidChange(model, { data, inputType: "insertText" });
            return true;
          }
        }
      } else if (model.selectionIsCollapsed && typeof input === "string" && insertSmartFence(model, input, options.style))
        return true;
      const { suppressChangeNotifications } = model;
      if (options.suppressChangeNotifications)
        model.suppressChangeNotifications = true;
      const contentWasChanging = model.suppressChangeNotifications;
      model.suppressChangeNotifications = true;
      const args = {};
      args[0] = options.insertionMode === "replaceAll" ? "" : model.getValue(model.selection, "latex-unstyled");
      args["?"] = "\\placeholder{}";
      args["@"] = args["?"];
      if (options.insertionMode === "replaceSelection" && !model.selectionIsCollapsed)
        model.deleteAtoms(range(model.selection));
      else if (options.insertionMode === "replaceAll") {
        model.root.setChildren([], "body");
        model.position = 0;
      } else if (options.insertionMode === "insertBefore")
        model.collapseSelection("backward");
      else if (options.insertionMode === "insertAfter")
        model.collapseSelection("forward");
      if (!model.at(model.position).isLastSibling && model.at(model.position + 1).type === "placeholder") {
        model.deleteAtoms([model.position, model.position + 1]);
      } else if (model.at(model.position).type === "placeholder") {
        model.deleteAtoms([model.position - 1, model.position]);
      }
      if (args[0]) {
        args["@"] = args[0];
      } else if (typeof input === "string" && /(^|[^\\])#@/.test(input)) {
        const offset = getImplicitArgOffset(model);
        if (offset >= 0) {
          args["@"] = model.getValue(offset, model.position, "latex-unstyled");
          model.deleteAtoms([offset, model.position]);
        }
      }
      if (!args[0])
        args[0] = args["?"];
      let usedArg = false;
      const argFunction = (arg) => {
        usedArg = true;
        return args[arg];
      };
      const [format, newAtoms] = convertStringToAtoms(
        model,
        input,
        argFunction,
        options
      );
      if (!newAtoms)
        return false;
      const { parent } = model.at(model.position);
      if (format !== "latex" && model.options.removeExtraneousParentheses && parent instanceof LeftRightAtom && parent.leftDelim === "(" && parent.hasEmptyBranch("body") && newAtoms.length === 1 && newAtoms[0].type === "genfrac") {
        const newParent = parent.parent;
        const branch = parent.treeBranch;
        newParent.removeChild(parent);
        newParent.setChildren(newAtoms, branch);
      }
      const hadEmptyBody = parent.hasEmptyBranch("body");
      const cursor = model.at(model.position);
      cursor.parent.addChildrenAfter(newAtoms, cursor);
      if (format === "latex" && typeof input === "string") {
        if (parent.type === "root" && hadEmptyBody && !usedArg)
          parent.verbatimLatex = input;
      }
      model.suppressChangeNotifications = contentWasChanging;
      const lastNewAtom = newAtoms[newAtoms.length - 1];
      if (options.selectionMode === "placeholder") {
        const placeholder = newAtoms.flatMap((x) => [x, ...x.children]).find((x) => x.type === "placeholder");
        if (placeholder) {
          const placeholderOffset = model.offsetOf(placeholder);
          model.setSelection(placeholderOffset - 1, placeholderOffset);
          model.announce("move");
        } else if (lastNewAtom) {
          model.position = model.offsetOf(lastNewAtom);
        }
      } else if (options.selectionMode === "before") {
      } else if (options.selectionMode === "after") {
        if (lastNewAtom)
          model.position = model.offsetOf(lastNewAtom);
      } else if (options.selectionMode === "item")
        model.setSelection(model.anchor, model.offsetOf(lastNewAtom));
      contentDidChange(model, { data, inputType: "insertText" });
      model.suppressChangeNotifications = suppressChangeNotifications;
      return true;
    }
  };
  function convertStringToAtoms(model, s, args, options) {
    var _a3;
    let format = void 0;
    let result = [];
    if (typeof s !== "string" || options.format === "math-json") {
      const ce = window.MathfieldElement.computeEngine;
      if (!ce)
        return ["math-json", []];
      [format, s] = ["latex", ce.box(s).latex];
      result = parseLatex(s, model.mathfield, { parseMode: "math" });
    } else if (typeof s === "string" && options.format === "ascii-math") {
      [format, s] = parseMathString(s, {
        format: "ascii-math",
        inlineShortcuts: model.mathfield.options.inlineShortcuts
      });
      result = parseLatex(s, model.mathfield, { parseMode: "math" });
      if (format !== "latex" && model.options.removeExtraneousParentheses)
        simplifyParen(result);
    } else if (options.format === "auto" || ((_a3 = options.format) == null ? void 0 : _a3.startsWith("latex"))) {
      if (options.format === "auto") {
        [format, s] = parseMathString(s, {
          format: "auto",
          inlineShortcuts: model.mathfield.options.inlineShortcuts
        });
      }
      if (options.format === "latex")
        [, s] = trimModeShiftCommand(s);
      result = parseLatex(s, model.mathfield, { parseMode: "math", args });
      if (options.format !== "latex" && model.options.removeExtraneousParentheses)
        simplifyParen(result);
    }
    applyStyleToUnstyledAtoms(result, options.style);
    return [format != null ? format : "latex", result];
  }
  function removeParen(atoms) {
    if (!atoms)
      return null;
    console.assert(atoms[0].type === "first");
    if (atoms.length > 1)
      return null;
    const atom = atoms[0];
    if (atom instanceof LeftRightAtom && atom.leftDelim === "(" && atom.rightDelim === ")")
      return atom.removeBranch("body");
    return null;
  }
  function simplifyParen(atoms) {
    if (!atoms)
      return;
    for (let i = 0; atoms[i]; i++) {
      const atom = atoms[i];
      if (atom instanceof LeftRightAtom && atom.leftDelim === "(") {
        let genFracCount = 0;
        let genFracIndex = 0;
        let nonGenFracCount = 0;
        for (let j = 0; atom.body[j]; j++) {
          if (atom.body[j].type === "genfrac") {
            genFracCount++;
            genFracIndex = j;
          }
          nonGenFracCount++;
        }
        if (nonGenFracCount === 0 && genFracCount === 1) {
          atoms[i] = atom.body[genFracIndex];
        }
      }
    }
    for (const atom of atoms) {
      for (const branch of atom.branches) {
        if (!atom.hasEmptyBranch(branch)) {
          simplifyParen(atom.branch(branch));
          const newChildren = removeParen(atom.branch(branch));
          if (newChildren)
            atom.setChildren(newChildren, branch);
        }
      }
      if (atom instanceof ArrayAtom)
        for (const x of atom.cells)
          simplifyParen(x);
    }
  }
  function getImplicitArgOffset(model) {
    let atom = model.at(model.position);
    if (atom.mode === "text") {
      while (!atom.isFirstSibling && atom.mode === "text")
        atom = atom.leftSibling;
      return model.offsetOf(atom);
    }
    const atomAtCursor = atom;
    let afterDelim = false;
    if (atom.type === "mclose") {
      const delim = LEFT_DELIM[atom.value];
      while (!atom.isFirstSibling && !(atom.type === "mopen" && atom.value === delim))
        atom = atom.leftSibling;
      if (!atom.isFirstSibling)
        atom = atom.leftSibling;
      afterDelim = true;
    } else if (atom.type === "leftright") {
      atom = atom.leftSibling;
      afterDelim = true;
    }
    if (afterDelim) {
      while (!atom.isFirstSibling && (atom.isFunction || isImplicitArg(atom)))
        atom = atom.leftSibling;
    } else {
      const delimiterStack = [];
      while (!atom.isFirstSibling && (isImplicitArg(atom) || delimiterStack.length > 0)) {
        if (atom.type === "mclose")
          delimiterStack.unshift(atom.value);
        if (atom.type === "mopen" && delimiterStack.length > 0 && atom.value === LEFT_DELIM[delimiterStack[0]])
          delimiterStack.shift();
        atom = atom.leftSibling;
      }
    }
    if (atomAtCursor === atom)
      return -1;
    return model.offsetOf(atom);
  }
  function isImplicitArg(atom) {
    if (/^(mord|surd|msubsup|leftright|mop|mclose)$/.test(atom.type)) {
      if (atom.isExtensibleSymbol)
        return false;
      if (atom.isFunction)
        return false;
      return true;
    }
    return false;
  }
  function isValidClose(open, close) {
    if (!open)
      return true;
    if (["(", "{", "[", "\\lbrace", "\\lparen", "\\{", "\\lbrack"].includes(open)) {
      return [")", "}", "]", "\\rbrace", "\\rparen", "\\}", "\\rbrack"].includes(
        close
      );
    }
    return RIGHT_DELIM[open] === close;
  }
  function insertSmartFence(model, fence, style) {
    console.assert(model.selectionIsCollapsed);
    const atom = model.at(model.position);
    const { parent } = atom;
    if (fence === "{" || fence === "\\{")
      fence = "\\lbrace";
    if (fence === "}" || fence === "\\}")
      fence = "\\rbrace";
    if (fence === "[")
      fence = "\\lbrack";
    if (fence === "]")
      fence = "\\rbrack";
    if (/\||\\vert|\\Vert|\\mvert|\\mid/.test(fence)) {
      let delims = parent instanceof LeftRightAtom ? parent.leftDelim + parent.rightDelim : "";
      if (delims === "\\lbrace\\rbrace")
        delims = "{}";
      if (delims === "\\{\\}")
        delims = "{}";
      if (delims === "\\lparen\\rparen")
        delims = "()";
      if (delims === "{}") {
        ModeEditor.insert("math", model, "\\,\\middle" + fence + "\\, ", {
          format: "latex",
          style
        });
        return true;
      }
    }
    const rDelim = RIGHT_DELIM[fence];
    if (rDelim) {
      if (parent instanceof LeftRightAtom && parent.firstChild === atom && // At first child
      (parent.leftDelim === "?" || parent.leftDelim === ".")) {
        parent.leftDelim = fence;
        parent.isDirty = true;
        return true;
      }
      if (!(parent instanceof LeftRightAtom)) {
        let sibling = atom;
        while (sibling) {
          if (sibling.type === "mclose" && sibling.value === rDelim)
            break;
          sibling = sibling.rightSibling;
        }
        if (sibling) {
          const body = model.extractAtoms([
            model.offsetOf(atom),
            model.offsetOf(sibling)
          ]);
          body.shift();
          body.pop();
          parent.addChildrenAfter(
            [
              new LeftRightAtom("left...right", body, parent.context, {
                leftDelim: fence,
                rightDelim: rDelim
              })
            ],
            atom
          );
          model.position = model.offsetOf(parent.firstChild);
          contentDidChange(model, { data: fence, inputType: "insertText" });
          return true;
        }
      }
      if (!(parent instanceof LeftRightAtom && parent.leftDelim === "|")) {
        ModeEditor.insert("math", model, `\\left${fence}\\right?`, {
          format: "latex",
          style
        });
        if (atom.lastSibling.type !== "first") {
          const lastSiblingOffset = model.offsetOf(atom.lastSibling);
          const content = model.extractAtoms([model.position, lastSiblingOffset]);
          model.at(model.position).body = content;
          model.position -= 1;
        }
        return true;
      }
    }
    let targetLeftDelim = "";
    for (const delim of Object.keys(RIGHT_DELIM))
      if (fence === RIGHT_DELIM[delim])
        targetLeftDelim = delim;
    if (targetLeftDelim) {
      let sibling = atom;
      while (sibling) {
        if (sibling.type === "mopen" && sibling.value === targetLeftDelim) {
          const insertAfter = sibling.leftSibling;
          const body = model.extractAtoms([
            model.offsetOf(sibling.leftSibling),
            model.offsetOf(atom)
          ]);
          body.shift();
          const result = new LeftRightAtom(
            "left...right",
            body,
            parent.context,
            {
              leftDelim: targetLeftDelim,
              rightDelim: fence
            }
          );
          parent.addChildrenAfter([result], insertAfter);
          model.position = model.offsetOf(result);
          contentDidChange(model, { data: fence, inputType: "insertText" });
          return true;
        }
        sibling = sibling.leftSibling;
      }
      if (parent instanceof LeftRightAtom && atom.isLastSibling && isValidClose(parent.leftDelim, fence)) {
        parent.isDirty = true;
        parent.rightDelim = fence;
        model.position += 1;
        contentDidChange(model, { data: fence, inputType: "insertText" });
        return true;
      }
      const firstSibling = model.offsetOf(atom.firstSibling);
      let i;
      for (i = model.position; i >= firstSibling; i--) {
        const atom2 = model.at(i);
        if (atom2 instanceof LeftRightAtom && atom2.rightDelim === "?" && isValidClose(atom2.leftDelim, fence))
          break;
      }
      const match = model.at(i);
      if (i >= firstSibling && match instanceof LeftRightAtom) {
        match.rightDelim = fence;
        match.addChildren(
          model.extractAtoms([i, model.position]),
          atom.treeBranch
        );
        model.position = i;
        contentDidChange(model, { data: fence, inputType: "insertText" });
        return true;
      }
      if (parent instanceof LeftRightAtom && parent.rightDelim === "?" && isValidClose(parent.leftDelim, fence)) {
        parent.isDirty = true;
        parent.rightDelim = fence;
        parent.parent.addChildren(
          model.extractAtoms([model.position, model.offsetOf(atom.lastSibling)]),
          parent.treeBranch
        );
        model.position = model.offsetOf(parent);
        contentDidChange(model, { data: fence, inputType: "insertText" });
        return true;
      }
      const grandparent = parent.parent;
      if (grandparent instanceof LeftRightAtom && grandparent.rightDelim === "?" && model.at(model.position).isLastSibling) {
        model.position = model.offsetOf(grandparent);
        return insertSmartFence(model, fence, style);
      }
      return false;
    }
    return false;
  }
  new MathModeEditor();

  // src/editor-mathfield/keyboard-input.ts
  function onKeystroke(mathfield, keystroke, evt) {
    var _a3, _b3, _c2, _d2;
    const { model } = mathfield;
    validateKeyboardLayout(evt);
    const activeLayout = getActiveKeyboardLayout();
    if (mathfield.keyboardLayout !== activeLayout.id) {
      mathfield.keyboardLayout = activeLayout.id;
      mathfield._keybindings = void 0;
    }
    clearTimeout(mathfield.inlineShortcutBufferFlushTimer);
    mathfield.inlineShortcutBufferFlushTimer = 0;
    showKeystroke(mathfield, keystroke);
    if (evt.defaultPrevented) {
      mathfield.flushInlineShortcutBuffer();
      return false;
    }
    let shortcut;
    let selector = "";
    let stateIndex;
    if (mathfield.isSelectionEditable) {
      if (mathfield.mode === "math") {
        if (keystroke === "[Backspace]") {
          mathfield.inlineShortcutBuffer.pop();
          mathfield.flushInlineShortcutBuffer({ defer: true });
        } else if (!mightProducePrintableCharacter(evt)) {
          mathfield.flushInlineShortcutBuffer();
        } else {
          const c = eventToChar(evt);
          const keystrokes = [
            ...(_b3 = (_a3 = mathfield.inlineShortcutBuffer[mathfield.inlineShortcutBuffer.length - 1]) == null ? void 0 : _a3.keystrokes) != null ? _b3 : [],
            c
          ];
          mathfield.inlineShortcutBuffer.push({
            state: model.getState(),
            keystrokes,
            leftSiblings: getLeftSiblings(mathfield)
          });
          let i = 0;
          let candidate = "";
          while (!shortcut && i < keystrokes.length) {
            stateIndex = mathfield.inlineShortcutBuffer.length - (keystrokes.length - i);
            candidate = keystrokes.slice(i).join("");
            shortcut = getInlineShortcut(
              mathfield.inlineShortcutBuffer[stateIndex].leftSiblings,
              candidate,
              mathfield.options.inlineShortcuts
            );
            if (!shortcut && /^[a-zA-Z][a-zA-Z0-9]+?([_\^][a-zA-Z0-9\*\+\-]+?)?$/.test(candidate))
              shortcut = mathfield.options.onInlineShortcut(mathfield, candidate);
            i += 1;
          }
          mathfield.flushInlineShortcutBuffer({ defer: true });
        }
      }
      if (mathfield.options.smartMode) {
        const previousMode = mathfield.mode;
        if (shortcut) {
          mathfield.mode = "math";
        } else if (smartMode(mathfield, keystroke, evt)) {
          mathfield.mode = { math: "text", text: "math" }[mathfield.mode];
          selector = "";
        }
        if (mathfield.mode !== previousMode) {
          if (!((_c2 = mathfield.host) == null ? void 0 : _c2.dispatchEvent(
            new Event("mode-change", {
              bubbles: true,
              composed: true,
              cancelable: true
            })
          )))
            mathfield.mode = previousMode;
        }
      }
    }
    if (!shortcut) {
      if (!selector) {
        selector = getCommandForKeybinding(
          mathfield.keybindings,
          mathfield.mode,
          keystroke
        );
      }
      if (!selector && (keystroke === "[Enter]" || keystroke === "[Return]")) {
        let result = false;
        if (contentWillChange(model, { inputType: "insertLineBreak" })) {
          if (mathfield.host) {
            result = !mathfield.host.dispatchEvent(
              new Event("change", { bubbles: true, composed: true })
            );
          }
          if (!result) {
            if (evt.preventDefault) {
              evt.preventDefault();
              evt.stopPropagation();
            }
          }
          contentDidChange(model, { inputType: "insertLineBreak" });
        }
        return result;
      }
      if ((!selector || keystroke === "[Space]") && mathfield.mode === "math") {
        if (keystroke === "[Space]") {
          mathfield.adoptStyle = "none";
          mathfield.flushInlineShortcutBuffer();
          if (mathfield.options.mathModeSpace) {
            mathfield.snapshot();
            ModeEditor.insert("math", model, mathfield.options.mathModeSpace, {
              format: "latex"
            });
            selector = "";
            mathfield.dirty = true;
            mathfield.scrollIntoView();
            if (evt.preventDefault) {
              evt.preventDefault();
              evt.stopPropagation();
            }
            return false;
          }
          const nextSibling = model.at(model.position + 1);
          const previousSibling = model.at(model.position - 1);
          if ((nextSibling == null ? void 0 : nextSibling.mode) === "text" || (previousSibling == null ? void 0 : previousSibling.mode) === "text") {
            mathfield.snapshot();
            ModeEditor.insert("text", model, " ");
            mathfield.dirty = true;
            mathfield.scrollIntoView();
            return true;
          }
        }
        if (((_d2 = model.at(model.position)) == null ? void 0 : _d2.isDigit()) && window.MathfieldElement.decimalSeparator === "," && eventToChar(evt) === ",")
          selector = "insertDecimalSeparator";
      }
    }
    if (!shortcut && !selector)
      return true;
    const child = model.at(Math.max(model.position, model.anchor));
    const { parent } = child;
    if (selector === "moveAfterParent" && (parent == null ? void 0 : parent.type) === "leftright" && child.isLastSibling && mathfield.options.smartFence && insertSmartFence(model, ".", mathfield.style)) {
      selector = "";
      requestUpdate(mathfield);
    }
    mathfield.keyboardDelegate.cancelComposition();
    if (selector)
      mathfield.executeCommand(selector);
    else if (shortcut) {
      const style = __spreadValues(__spreadValues({}, model.at(model.position).computedStyle), mathfield.style);
      if (!/^\\({|}|\[|]|@|#|\$|%|&|\^|_|backslash)$/.test(shortcut)) {
        const saveMode = mathfield.mode;
        ModeEditor.insert(mathfield.mode, model, eventToChar(evt), {
          suppressChangeNotifications: true,
          style
        });
        mathfield.snapshot();
        model.setState(mathfield.inlineShortcutBuffer[stateIndex].state);
        mathfield.mode = saveMode;
      }
      model.deferNotifications(
        {
          content: true,
          selection: true,
          data: shortcut != null ? shortcut : null,
          type: "insertText"
        },
        () => {
          ModeEditor.insert(mathfield.mode, model, shortcut, {
            format: "latex",
            style
          });
          removeIsolatedSpace(mathfield.model);
          if (shortcut.endsWith(" ")) {
            mathfield.mode = "text";
            ModeEditor.insert("text", model, " ", { style });
          }
          if (!model.selectionIsCollapsed)
            mathfield.flushInlineShortcutBuffer();
          return true;
        }
      );
      mathfield.snapshot();
      mathfield.dirty = true;
      model.announce("replacement");
    }
    mathfield.scrollIntoView();
    if (evt.preventDefault)
      evt.preventDefault();
    return false;
  }
  function onInput(mathfield, text, options) {
    var _a3;
    const { model } = mathfield;
    if (!mathfield.isSelectionEditable) {
      model.announce("plonk");
      return;
    }
    options = options != null ? options : {};
    if (options.focus)
      mathfield.focus();
    if (options.feedback)
      window.MathfieldElement.playSound("keypress");
    if (typeof options.mode === "string")
      mathfield.switchMode(options.mode);
    if (options.simulateKeystroke) {
      const c = text.charAt(0);
      const ev = new KeyboardEvent("keypress", { key: c });
      if (!onKeystroke(mathfield, c, ev))
        return;
    }
    const atom = model.at(model.position);
    const rightSibling = atom.rightSibling;
    const style = __spreadValues(__spreadValues({}, atom.computedStyle), mathfield.style);
    if (!model.selectionIsCollapsed) {
      model.deleteAtoms(range(model.selection));
      mathfield.snapshot();
    }
    const graphemes = splitGraphemes(text);
    if (mathfield.mode === "latex") {
      model.deferNotifications(
        { content: true, selection: true, data: text, type: "insertText" },
        () => {
          removeSuggestion(mathfield);
          for (const c of graphemes)
            ModeEditor.insert("latex", model, c);
          updateAutocomplete(mathfield);
        }
      );
    } else if (mathfield.mode === "text")
      for (const c of graphemes)
        ModeEditor.insert("text", model, c, { style });
    else if (mathfield.mode === "math") {
      for (const c of graphemes) {
        let selector = {
          "^": "moveToSuperscript",
          "_": "moveToSubscript",
          " ": "moveAfterParent"
        }[c];
        if (c === " " && mathfield.options.mathModeSpace)
          selector = ["insert", mathfield.options.mathModeSpace];
        if (selector)
          mathfield.executeCommand(selector);
        else if (/\d/.test(c) && mathfield.options.smartSuperscript && atom.treeBranch === "superscript" && ((_a3 = atom.parent) == null ? void 0 : _a3.type) !== "mop" && atom.hasNoSiblings) {
          ModeEditor.insert("math", model, c, { style });
          moveAfterParent(model);
        } else {
          if (mathfield.adoptStyle !== "none") {
            const sibling = mathfield.adoptStyle === "left" ? atom : rightSibling;
            if ((sibling == null ? void 0 : sibling.type) === "mord" && /[a-zA-Z]/.test(sibling.value) && /[a-zA-Z]/.test(c)) {
              if (sibling.style.variant)
                style.variant = sibling.style.variant;
              if (sibling.style.variantStyle)
                style.variantStyle = sibling.style.variantStyle;
            }
          }
          ModeEditor.insert("math", model, c, { style });
        }
      }
    }
    mathfield.snapshotAndCoalesce();
    mathfield.dirty = true;
    mathfield.scrollIntoView();
  }
  function getLeftSiblings(mf) {
    const model = mf.model;
    const result = [];
    let atom = model.at(Math.min(model.position, model.anchor));
    while (atom.type !== "first") {
      result.push(atom);
      atom = atom.leftSibling;
    }
    return result;
  }

  // src/editor-mathfield/commands.ts
  register2({
    undo: (mathfield) => {
      complete(mathfield, "accept");
      mathfield.undo();
      return true;
    },
    redo: (mathfield) => {
      complete(mathfield, "accept");
      mathfield.redo();
      return true;
    },
    scrollIntoView: (mathfield) => {
      mathfield.scrollIntoView();
      return true;
    },
    scrollToStart: (mathfield) => {
      mathfield.field.scroll(0, 0);
      return true;
    },
    scrollToEnd: (mathfield) => {
      const fieldBounds = mathfield.field.getBoundingClientRect();
      mathfield.field.scroll(fieldBounds.left - window.scrollX, 0);
      return true;
    },
    toggleKeystrokeCaption,
    plonk: (mathfield) => {
      mathfield.model.announce("plonk");
      return true;
    },
    switchMode: (mathfield, mode, prefix, suffix) => {
      mathfield.switchMode(mode, prefix, suffix);
      return true;
    },
    insert: (mathfield, s, options) => mathfield.insert(s, options),
    typedText: (mathfield, text, options) => {
      onInput(mathfield, text, options);
      return true;
    },
    insertDecimalSeparator: (mathfield) => {
      if (mathfield.mode === "math" && window.MathfieldElement.decimalSeparator === ",") {
        const model = mathfield.model;
        const child = model.at(Math.max(model.position, model.anchor));
        if (child.isDigit()) {
          mathfield.snapshot();
          mathfield.insert("{,}", { format: "latex" });
          return true;
        }
      }
      mathfield.insert(".");
      return true;
    },
    // A 'commit' command is used to simulate pressing the return/enter key,
    // e.g. when using a virtual keyboard
    commit: (mathfield) => {
      var _a3;
      if (contentWillChange(mathfield.model, { inputType: "insertLineBreak" })) {
        (_a3 = mathfield.host) == null ? void 0 : _a3.dispatchEvent(
          new Event("change", { bubbles: true, composed: true })
        );
        contentDidChange(mathfield.model, { inputType: "insertLineBreak" });
      }
      return true;
    },
    insertPrompt: (mathfield, id, options) => {
      const promptIds = mathfield.getPrompts();
      let prosepectiveId = "prompt-" + Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
      let i = 0;
      while (promptIds.includes(prosepectiveId) && i < 100) {
        if (i === 99) {
          console.error("could not find a unique ID after 100 tries");
          return false;
        }
        prosepectiveId = "prompt-" + Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
        i++;
      }
      mathfield.insert(`\\placeholder[${id != null ? id : prosepectiveId}]{}`, options);
      return true;
    }
  });
  register2(
    {
      copyToClipboard: (mathfield) => {
        mathfield.focus();
        if (mathfield.model.selectionIsCollapsed)
          mathfield.select();
        if ("queryCommandSupported" in document && document.queryCommandSupported("copy"))
          document.execCommand("copy");
        else {
          mathfield.element.querySelector(".ML__keyboard-sink").dispatchEvent(
            new ClipboardEvent("copy", {
              bubbles: true,
              composed: true
            })
          );
        }
        return false;
      },
      cutToClipboard: (mathfield) => {
        mathfield.focus();
        if ("queryCommandSupported" in document && document.queryCommandSupported("cut"))
          document.execCommand("cut");
        else {
          mathfield.element.querySelector(".ML__keyboard-sink").dispatchEvent(
            new ClipboardEvent("cut", {
              bubbles: true,
              composed: true
            })
          );
        }
        return true;
      },
      pasteFromClipboard: (mathfield) => {
        mathfield.focus();
        if ("queryCommandSupported" in document && document.queryCommandSupported("paste"))
          document.execCommand("paste");
        else {
          navigator.clipboard.readText().then((text) => {
            if (text && contentWillChange(mathfield.model, {
              inputType: "insertFromPaste",
              data: text
            })) {
              mathfield.snapshot();
              if (mathfield.insert(text)) {
                contentDidChange(mathfield.model, {
                  inputType: "insertFromPaste"
                });
                requestUpdate(mathfield);
              }
            } else
              mathfield.model.announce("plonk");
          });
        }
        return true;
      }
    },
    { target: "mathfield", category: "clipboard" }
  );

  // src/editor-mathfield/styling.ts
  function applyStyle2(mathfield, inStyle) {
    mathfield.flushInlineShortcutBuffer();
    const style = validateStyle(mathfield, inStyle);
    const { model } = mathfield;
    if (model.selectionIsCollapsed) {
      if (mathfield.style.fontSeries && style.fontSeries === mathfield.style.fontSeries)
        style.fontSeries = "auto";
      if (style.fontShape && style.fontShape === mathfield.style.fontShape)
        style.fontShape = "auto";
      if (style.color && style.color === mathfield.style.color)
        style.color = "none";
      if (style.backgroundColor && style.backgroundColor === mathfield.style.backgroundColor)
        style.backgroundColor = "none";
      if (style.fontSize && style.fontSize === mathfield.style.fontSize)
        style.fontSize = "auto";
      mathfield.style = __spreadValues(__spreadValues({}, mathfield.style), style);
    } else {
      mathfield.model.deferNotifications(
        { content: true, type: "insertText" },
        () => {
          model.selection.ranges.forEach(
            (range2) => applyStyle(model, range2, style, { operation: "toggle" })
          );
          mathfield.snapshot();
        }
      );
    }
    return true;
  }
  register2({ applyStyle: applyStyle2 }, { target: "mathfield" });
  function validateStyle(mathfield, style) {
    var _a3, _b3, _c2, _d2, _e, _f;
    const result = {};
    if (typeof style.color === "string") {
      result.verbatimColor = style.color;
      result.color = (_a3 = mathfield.colorMap(style.color)) != null ? _a3 : "none";
    }
    if (typeof style.backgroundColor === "string") {
      result.verbatimBackgroundColor = style.backgroundColor;
      result.backgroundColor = (_b3 = mathfield.backgroundColorMap(style.backgroundColor)) != null ? _b3 : "none";
    }
    if (typeof style.fontFamily === "string")
      result.fontFamily = style.fontFamily;
    if (typeof style.series === "string")
      result.fontSeries = style.series;
    if (typeof style.fontSeries === "string")
      result.fontSeries = style.fontSeries.toLowerCase();
    if (result.fontSeries) {
      result.fontSeries = (_c2 = {
        bold: "b",
        medium: "m",
        normal: "m"
      }[result.fontSeries]) != null ? _c2 : result.fontSeries;
    }
    if (typeof style.shape === "string")
      result.fontShape = style.shape;
    if (typeof style.fontShape === "string")
      result.fontShape = style.fontShape.toLowerCase();
    if (result.fontShape) {
      result.fontShape = (_d2 = {
        italic: "it",
        up: "n",
        upright: "n",
        normal: "n"
      }[result.fontShape]) != null ? _d2 : result.fontShape;
    }
    const size = (_e = style.size) != null ? _e : style.fontSize;
    if (typeof size === "number")
      result.fontSize = Math.max(1, Math.min(10, size));
    else if (typeof size === "string") {
      result.fontSize = (_f = {
        size1: 1,
        size2: 2,
        size3: 3,
        size4: 4,
        size5: 5,
        size6: 6,
        size7: 7,
        size8: 8,
        size9: 9,
        size10: 10
      }[size.toLowerCase()]) != null ? _f : {
        tiny: 1,
        scriptsize: 2,
        footnotesize: 3,
        small: 4,
        normal: 5,
        normalsize: 5,
        large: 6,
        Large: 7,
        LARGE: 8,
        huge: 9,
        Huge: 10
      }[size];
    }
    return result;
  }

  // src/editor-model/commands-select.ts
  function selectGroup(model) {
    var _a3, _b3, _c2, _d2, _e, _f;
    if (getMode(model, model.position) === "text") {
      let start = Math.min(model.anchor, model.position);
      let end = Math.max(model.anchor, model.position);
      let done = false;
      while (!done && start > 0) {
        const atom = model.at(start);
        if (atom.mode === "text" && LETTER_AND_DIGITS.test(atom.value))
          start -= 1;
        else
          done = true;
      }
      done = false;
      while (!done && end <= model.lastOffset) {
        const atom = model.at(end);
        if (atom.mode === "text" && LETTER_AND_DIGITS.test(atom.value))
          end += 1;
        else
          done = true;
      }
      if (done)
        end -= 1;
      if (start >= end) {
        model.setSelection(end - 1, end);
        return true;
      }
      model.setSelection(start, end);
    } else {
      const atom = model.at(model.position);
      if (atom.isDigit()) {
        let start = Math.min(model.anchor, model.position);
        let end = Math.max(model.anchor, model.position);
        while ((_a3 = model.at(start)) == null ? void 0 : _a3.isDigit())
          start -= 1;
        while ((_b3 = model.at(end)) == null ? void 0 : _b3.isDigit())
          end += 1;
        model.setSelection(start, end - 1);
      } else {
        if (atom.style.variant || atom.style.variantStyle) {
          let start = Math.min(model.anchor, model.position);
          let end = Math.max(model.anchor, model.position);
          let x = (_c2 = model.at(start)) == null ? void 0 : _c2.style;
          while (x && x.variant === atom.style.variant && x.variantStyle === atom.style.variantStyle) {
            start -= 1;
            x = (_d2 = model.at(start)) == null ? void 0 : _d2.style;
          }
          x = (_e = model.at(end)) == null ? void 0 : _e.style;
          while (x && x.variant === atom.style.variant && x.variantStyle === atom.style.variantStyle) {
            end += 1;
            x = (_f = model.at(end)) == null ? void 0 : _f.style;
          }
          model.setSelection(start, end - 1);
        } else {
          model.setSelection(
            model.offsetOf(atom.firstSibling),
            model.offsetOf(atom.lastSibling)
          );
        }
      }
    }
    return true;
  }
  register2(
    {
      selectGroup: (model) => {
        const result = selectGroup(model);
        if (!result)
          model.announce("plonk");
        return result;
      },
      selectAll: (model) => model.setSelection(0, model.lastOffset),
      extendSelectionForward: (model) => {
        const result = model.extendSelection("forward");
        if (!result)
          model.announce("plonk");
        return result;
      },
      extendSelectionBackward: (model) => {
        const result = model.extendSelection("backward");
        if (!result)
          model.announce("plonk");
        return result;
      },
      extendToNextWord: (model) => skip(model, "forward", { extend: true }),
      extendToPreviousWord: (model) => skip(model, "backward", { extend: true }),
      extendSelectionUpward: (model) => move(model, "upward", { extend: true }),
      extendSelectionDownward: (model) => move(model, "downward", { extend: true }),
      /**
       * Extend the selection until the next boundary is reached. A boundary
       * is defined by an atom of a different type (mbin, mord, etc...)
       * than the current focus. For example, in "1234+x=y", if the focus is between
       * "1" and "2", invoking `extendToNextBoundary_` would extend the selection
       * to "234".
       */
      extendToNextBoundary: (model) => skip(model, "forward", { extend: true }),
      /**
       * Extend the selection until the previous boundary is reached. A boundary
       * is defined by an atom of a different type (mbin, mord, etc...)
       * than the current focus. For example, in "1+23456", if the focus is between
       * "5" and "6", invoking `extendToPreviousBoundary` would extend the selection
       * to "2345".
       */
      extendToPreviousBoundary: (model) => skip(model, "backward", { extend: true }),
      extendToGroupStart: (model) => {
        const result = model.setSelection(
          model.anchor,
          model.offsetOf(model.at(model.position).firstSibling)
        );
        if (!result)
          model.announce("plonk");
        return result;
      },
      extendToGroupEnd: (model) => {
        const result = model.setSelection(
          model.anchor,
          model.offsetOf(model.at(model.position).lastSibling)
        );
        if (!result)
          model.announce("plonk");
        return result;
      },
      extendToMathFieldStart: (model) => {
        const result = model.setSelection(model.anchor, 0);
        if (!result)
          model.announce("plonk");
        return result;
      },
      extendToMathFieldEnd: (model) => {
        const result = model.setSelection(model.anchor, model.lastOffset);
        if (!result)
          model.announce("plonk");
        return result;
      }
    },
    { target: "model", category: "selection-extend" }
  );

  // src/editor-mathfield/pointer-input.ts
  var gLastTap = null;
  var gTapCount = 0;
  function isPointerEvent(evt) {
    return evt instanceof PointerEvent;
  }
  function onPointerDown(mathfield, evt) {
    var _a3;
    mathfield.atomBoundsCache = /* @__PURE__ */ new Map();
    const that = mathfield;
    let anchor;
    let trackingPointer = false;
    let trackingWords = false;
    let dirty = "none";
    if (evt.buttons > 1)
      return;
    let scrollLeft = false;
    let scrollRight = false;
    const anchorX = evt.clientX;
    const anchorY = evt.clientY;
    const anchorTime = Date.now();
    const field = that.field;
    const scrollInterval = setInterval(() => {
      if (scrollLeft)
        field.scroll({ top: 0, left: field.scrollLeft - 16 });
      else if (scrollRight)
        field.scroll({ top: 0, left: field.scrollLeft + 16 });
    }, 32);
    function endPointerTracking(evt2) {
      if ("PointerEvent" in window) {
        off(field, "pointermove", onPointerMove);
        off(
          field,
          "pointerup pointercancel",
          endPointerTracking
        );
        if (evt2 instanceof PointerEvent)
          field.releasePointerCapture(evt2.pointerId);
      } else {
        off(window, "mousemove", onPointerMove);
        off(window, "mouseup blur", endPointerTracking);
      }
      trackingPointer = false;
      clearInterval(scrollInterval);
      mathfield.element.classList.remove("tracking");
      if (evt2)
        evt2.preventDefault();
    }
    function onPointerMove(evt2) {
      if (!that.hasFocus()) {
        endPointerTracking(null);
        return;
      }
      const x = evt2.clientX;
      const y = evt2.clientY;
      const hysteresis = isPointerEvent(evt2) && evt2.pointerType === "touch" ? 20 : 5;
      if (Date.now() < anchorTime + 500 && Math.abs(anchorX - x) < hysteresis && Math.abs(anchorY - y) < hysteresis) {
        evt2.preventDefault();
        evt2.stopPropagation();
        return;
      }
      const fieldBounds = field.getBoundingClientRect();
      scrollRight = x > fieldBounds.right;
      scrollLeft = x < fieldBounds.left;
      let actualAnchor = anchor;
      if (isPointerEvent(evt2)) {
        if (!evt2.isPrimary) {
          actualAnchor = offsetFromPoint(that, evt2.clientX, evt2.clientY, {
            bias: 0
          });
        }
      }
      const focus = offsetFromPoint(that, x, y, {
        bias: x <= anchorX ? x === anchorX ? 0 : -1 : 1
      });
      if (trackingWords) {
      }
      if (actualAnchor >= 0 && focus >= 0) {
        that.model.extendSelectionTo(actualAnchor, focus);
        requestUpdate(mathfield);
      }
      evt2.preventDefault();
      evt2.stopPropagation();
    }
    if (gLastTap && Math.abs(gLastTap.x - anchorX) < 5 && Math.abs(gLastTap.y - anchorY) < 5 && Date.now() < gLastTap.time + 500) {
      gTapCount += 1;
      gLastTap.time = anchorTime;
    } else {
      gLastTap = {
        x: anchorX,
        y: anchorY,
        time: anchorTime
      };
      gTapCount = 1;
    }
    const bounds = field.getBoundingClientRect();
    if (anchorX >= bounds.left && anchorX <= bounds.right && anchorY >= bounds.top && anchorY <= bounds.bottom) {
      if (!mathfield.hasFocus()) {
        dirty = "none";
        mathfield.focus({ scrollIntoView: false });
      }
      mathfield.flushInlineShortcutBuffer();
      mathfield.smartModeSuppressed = false;
      mathfield.adoptStyle = "left";
      anchor = offsetFromPoint(mathfield, anchorX, anchorY, {
        bias: 0
      });
      if (anchor >= 0) {
        mathfield.element.classList.add("tracking");
        if (evt.shiftKey) {
          const wasCollapsed = mathfield.model.selectionIsCollapsed;
          mathfield.model.extendSelectionTo(mathfield.model.anchor, anchor);
          if (acceptCommandSuggestion(mathfield.model) || wasCollapsed)
            dirty = "all";
          else
            dirty = "selection";
        } else if (mathfield.model.at(anchor).type === "placeholder") {
          mathfield.model.setSelection(anchor - 1, anchor);
          dirty = "selection";
        } else if (((_a3 = mathfield.model.at(anchor).rightSibling) == null ? void 0 : _a3.type) === "placeholder") {
          mathfield.model.setSelection(anchor, anchor + 1);
          dirty = "selection";
        } else {
          mathfield.model.position = anchor;
          if (acceptCommandSuggestion(mathfield.model))
            dirty = "all";
          else
            dirty = "selection";
        }
        mathfield.style = {};
        if (evt.detail === 3 || gTapCount > 2) {
          endPointerTracking(evt);
          if (evt.detail === 3 || gTapCount === 3) {
            mathfield.model.selection = {
              ranges: [[0, mathfield.model.lastOffset]]
            };
            dirty = "all";
          }
        } else if (!trackingPointer) {
          trackingPointer = true;
          if ("PointerEvent" in window) {
            on(field, "pointermove", onPointerMove);
            on(
              field,
              "pointerup pointercancel",
              endPointerTracking
            );
            if (evt instanceof PointerEvent)
              field.setPointerCapture(evt.pointerId);
          } else {
            on(window, "blur", endPointerTracking);
            on(window, "mousemove", onPointerMove);
            on(window, "mouseup", endPointerTracking);
          }
          if (evt.detail === 2 || gTapCount === 2) {
            trackingWords = true;
            selectGroup(mathfield.model);
            dirty = "all";
          }
        }
      }
    } else
      gLastTap = null;
    if (dirty !== "none") {
      if (mathfield.model.selectionIsCollapsed)
        dirty = "all";
      requestUpdate(mathfield);
    }
    evt.preventDefault();
  }
  function distance(x, y, r) {
    if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom)
      return 0;
    const dx = x - (r.left + r.right) / 2;
    const dy = y - (r.top + r.bottom) / 2;
    return dx * dx + dy * dy;
  }
  function nearestAtomFromPointRecursive(mathfield, cache, atom, x, y) {
    if (!atom.id)
      return [Infinity, null];
    if (cache.has(atom.id))
      return cache.get(atom.id);
    const bounds = getAtomBounds(mathfield, atom);
    if (!bounds)
      return [Infinity, null];
    let result = [
      Infinity,
      null
    ];
    if (atom.hasChildren && !atom.captureSelection && x >= bounds.left && x <= bounds.right) {
      for (const child of atom.children) {
        const r = nearestAtomFromPointRecursive(mathfield, cache, child, x, y);
        if (r[0] <= result[0])
          result = r;
      }
    }
    if (!result[1])
      result = [distance(x, y, bounds), atom];
    cache.set(atom.id, result);
    return result;
  }
  function nearestAtomFromPoint(mathfield, x, y) {
    const [, atom] = nearestAtomFromPointRecursive(
      mathfield,
      /* @__PURE__ */ new Map(),
      mathfield.model.root,
      x,
      y
    );
    return atom;
  }
  function offsetFromPoint(mathfield, x, y, options) {
    var _a3, _b3;
    const bounds = (_a3 = mathfield.fieldContent) == null ? void 0 : _a3.getBoundingClientRect();
    if (!bounds)
      return 0;
    if (x > bounds.right || y > bounds.bottom + 8)
      return mathfield.model.lastOffset;
    if (x < bounds.left || y < bounds.top - 8)
      return 0;
    options = options != null ? options : {};
    options.bias = (_b3 = options.bias) != null ? _b3 : 0;
    let atom = nearestAtomFromPoint(mathfield, x, y);
    const parents = [];
    let parent = atom;
    while (parent) {
      parents.unshift(parent);
      parent = parent.parent;
    }
    for (const x2 of parents) {
      if (x2.captureSelection) {
        atom = x2;
        break;
      }
    }
    let result = mathfield.model.offsetOf(atom);
    if (result < 0)
      return -1;
    if (atom.leftSibling) {
      if (options.bias === 0 && atom.type !== "placeholder") {
        const bounds2 = getAtomBounds(mathfield, atom);
        if (bounds2 && x < (bounds2.left + bounds2.right) / 2)
          result = mathfield.model.offsetOf(atom.leftSibling);
      } else if (options.bias < 0)
        result = mathfield.model.offsetOf(atom.leftSibling);
    }
    return result;
  }

  // src/editor-mathfield/mode-editor-text.ts
  var TextModeEditor = class extends ModeEditor {
    constructor() {
      super("text");
    }
    onPaste(mathfield, data) {
      if (!data)
        return false;
      const text = typeof data === "string" ? data : data.getData("text/plain");
      if (text && contentWillChange(mathfield.model, {
        inputType: "insertFromPaste",
        data: text
      })) {
        mathfield.snapshot();
        if (this.insert(mathfield.model, text)) {
          contentDidChange(mathfield.model, { inputType: "insertFromPaste" });
          requestUpdate(mathfield);
        }
        return true;
      }
      return false;
    }
    insert(model, text, options = {}) {
      if (!contentWillChange(model, { data: text, inputType: "insertText" }))
        return false;
      if (!options.insertionMode)
        options.insertionMode = "replaceSelection";
      if (!options.selectionMode)
        options.selectionMode = "placeholder";
      if (!options.format)
        options.format = "auto";
      const { suppressChangeNotifications } = model;
      if (options.suppressChangeNotifications)
        model.suppressChangeNotifications = true;
      const contentWasChanging = model.suppressChangeNotifications;
      model.suppressChangeNotifications = true;
      if (options.insertionMode === "replaceSelection" && !model.selectionIsCollapsed)
        model.deleteAtoms(range(model.selection));
      else if (options.insertionMode === "replaceAll") {
        model.root.setChildren([], "body");
        model.position = 0;
      } else if (options.insertionMode === "insertBefore")
        model.collapseSelection("backward");
      else if (options.insertionMode === "insertAfter")
        model.collapseSelection("forward");
      const newAtoms = convertStringToAtoms2(text, model.mathfield);
      applyStyleToUnstyledAtoms(newAtoms, options.style);
      if (!newAtoms)
        return false;
      const cursor = model.at(model.position);
      const lastNewAtom = cursor.parent.addChildrenAfter(newAtoms, cursor);
      model.suppressChangeNotifications = contentWasChanging;
      if (options.selectionMode === "before") {
      } else if (options.selectionMode === "item")
        model.setSelection(model.anchor, model.offsetOf(lastNewAtom));
      else if (lastNewAtom)
        model.position = model.offsetOf(lastNewAtom);
      contentDidChange(model, { data: text, inputType: "insertText" });
      model.suppressChangeNotifications = suppressChangeNotifications;
      return true;
    }
  };
  function convertStringToAtoms2(s, context) {
    s = s.replace(/\\/g, "\\textbackslash ");
    s = s.replace(/#/g, "\\#");
    s = s.replace(/\$/g, "\\$");
    s = s.replace(/%/g, "\\%");
    s = s.replace(/&/g, "\\&");
    s = s.replace(/_/g, "\\_");
    s = s.replace(/{/g, "\\textbraceleft ");
    s = s.replace(/}/g, "\\textbraceright ");
    s = s.replace(/\^/g, "\\textasciicircum ");
    s = s.replace(/~/g, "\\textasciitilde ");
    s = s.replace(//g, "\\textsterling ");
    return parseLatex(s, context, { parseMode: "text" });
  }
  new TextModeEditor();

  // src/editor-mathfield/mathfield-private.ts
  var CORE_STYLESHEET_HASH = void 0;
  var MATHFIELD_STYLESHEET_HASH = void 0;
  var DEFAULT_KEYBOARD_TOGGLE_GLYPH = `<svg style="width: 21px;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M528 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h480c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm16 336c0 8.823-7.177 16-16 16H48c-8.823 0-16-7.177-16-16V112c0-8.823 7.177-16 16-16h480c8.823 0 16 7.177 16 16v288zM168 268v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-336 80v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm384 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zM120 188v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-96 152v-8c0-6.627-5.373-12-12-12H180c-6.627 0-12 5.373-12 12v8c0 6.627 5.373 12 12 12h216c6.627 0 12-5.373 12-12z"/></svg>`;
  var MathfieldPrivate = class {
    /**
     *
     * - `options.computeEngine`: An instance of a `ComputeEngine`. It is used to parse and serialize
     * LaTeX strings, using the information contained in the dictionaries
     * of the Compute Engine to determine, for example, which symbols are
     * numbers or which are functions, and therefore correctly interpret
     * `bf(x)` as `b \\times f(x)`.
     *
     * If no instance is provided, a new default one is created.
     *
     * @param element - The DOM element that this mathfield is attached to.
     * Note that `element.mathfield` is this object.
     */
    constructor(element, options) {
      this.focusBlurInProgress = false;
      this.stylesheets = [];
      var _a3, _b3;
      this.options = update(
        __spreadProps(__spreadValues({}, getDefault()), { registers: getDefaultRegisters(this) }),
        options
      );
      if (options.eventSink)
        this.host = options.eventSink;
      this.element = element;
      element.mathfield = this;
      if (!CORE_STYLESHEET_HASH)
        CORE_STYLESHEET_HASH = hashCode(core_default).toString(36);
      this.stylesheets.push(
        inject(element, core_default, CORE_STYLESHEET_HASH)
      );
      if (!MATHFIELD_STYLESHEET_HASH)
        MATHFIELD_STYLESHEET_HASH = hashCode(mathfield_default).toString(36);
      this.stylesheets.push(
        inject(element, mathfield_default, MATHFIELD_STYLESHEET_HASH)
      );
      this.blurred = true;
      this.keystrokeCaptionVisible = false;
      this.popoverVisible = false;
      this.suggestionIndex = 0;
      this.inlineShortcutBuffer = [];
      this.inlineShortcutBufferFlushTimer = 0;
      this.mode = effectiveMode(this.options);
      this.smartModeSuppressed = false;
      this.style = {};
      this.adoptStyle = "left";
      if (this.options.defaultMode === "inline-math")
        this.element.classList.add("ML__is-inline");
      else
        this.element.classList.remove("ML__is-inline");
      this.dirty = false;
      this.model = new ModelPrivate(
        {
          mode: effectiveMode(this.options),
          macros: this.options.macros,
          removeExtraneousParentheses: this.options.removeExtraneousParentheses
        },
        {
          onSelectionDidChange: () => this._onSelectionDidChange()
        },
        this
      );
      this.undoManager = new UndoManager(this.model);
      let elementText = (_a3 = options.value) != null ? _a3 : this.element.textContent;
      if (elementText)
        elementText = elementText.trim();
      if (elementText) {
        ModeEditor.insert("math", this.model, elementText, {
          insertionMode: "replaceAll",
          selectionMode: "after",
          format: "latex",
          suppressChangeNotifications: true
        });
      }
      const markup = [];
      markup.push(
        `<span contenteditable=true aria-multiline=false part=keyboard-sink class=ML__keyboard-sink autocapitalize=off autocomplete=off autocorrect=off spellcheck=false inputmode=none tabindex=0></span>`
      );
      markup.push(
        '<span part=container class=ML__container aria-hidden=true  style="visibility:hidden">'
      );
      markup.push("<span part=content class=ML__content>");
      markup.push(contentMarkup(this));
      markup.push("</span>");
      markup.push(
        `<div part=virtual-keyboard-toggle class=ML__virtual-keyboard-toggle role=button ${this.hasEditableContent ? "" : 'style="display:none;"'}data-ML__tooltip="${localize("tooltip.toggle virtual keyboard")}">`
      );
      markup.push(DEFAULT_KEYBOARD_TOGGLE_GLYPH);
      markup.push("</div>");
      markup.push("</span>");
      markup.push("<span class=ML__sr-only>");
      markup.push(
        "<span role=status aria-live=assertive aria-atomic=true></span>"
      );
      markup.push("</span>");
      this.element.innerHTML = window.MathfieldElement.createHTML(
        markup.join("")
      );
      if (!this.element.children) {
        console.error(
          `%cMathLive 0.91.2: Something went wrong and the mathfield could not be created.%c
If you are using Vue, this may be because you are using the runtime-only build of Vue. Make sure to include \`runtimeCompiler: true\` in your Vue configuration. There may a warning from Vue in the log above.`,
          "color:red;font-family:system-ui;font-size:1.2rem;font-weight:bold",
          "color:inherit;font-family:system-ui;font-size:inherit;font-weight:inherit"
        );
        return;
      }
      this.field = this.element.querySelector("[part=content]");
      this.field.addEventListener(
        "click",
        (evt) => evt.stopImmediatePropagation(),
        { capture: false }
      );
      this.field.addEventListener("wheel", this, { passive: false });
      if ("PointerEvent" in window)
        this.field.addEventListener("pointerdown", this);
      else
        this.field.addEventListener("mousedown", this);
      (_b3 = this.element.querySelector("[part=virtual-keyboard-toggle]")) == null ? void 0 : _b3.addEventListener("click", () => {
        if (window.mathVirtualKeyboard.visible)
          window.mathVirtualKeyboard.hide();
        else {
          window.mathVirtualKeyboard.show({ animate: true });
          window.mathVirtualKeyboard.updateToolbar(makeProxy(this));
        }
      });
      this.ariaLiveText = this.element.querySelector("[role=status]");
      this.keyboardDelegate = delegateKeyboardEvents(
        this.element.querySelector(".ML__keyboard-sink"),
        this.element,
        {
          onFocus: () => this.onFocus(),
          onBlur: () => this.onBlur(),
          onInput: (text) => onInput(this, text),
          onKeystroke: (keystroke, event) => onKeystroke(this, keystroke, event),
          onCompositionStart: (composition) => this.onCompositionStart(composition),
          onCompositionUpdate: (composition) => this.onCompositionUpdate(composition),
          onCompositionEnd: (composition) => this.onCompositionEnd(composition),
          onCut: (ev) => {
            if (!this.isSelectionEditable) {
              this.model.announce("plonk");
              return;
            }
            if (contentWillChange(this.model, { inputType: "deleteByCut" })) {
              this.snapshot();
              ModeEditor.onCopy(this, ev);
              deleteRange(this.model, range(this.model.selection), "deleteByCut");
              requestUpdate(this);
            }
          },
          onCopy: (ev) => ModeEditor.onCopy(this, ev),
          onPaste: (ev) => {
            let result = this.isSelectionEditable;
            if (result) {
              result = ModeEditor.onPaste(
                this.model.at(this.model.position).mode,
                this,
                ev.clipboardData
              );
            }
            if (!result)
              this.model.announce("plonk");
            ev.preventDefault();
            ev.stopPropagation();
            return result;
          }
        }
      );
      window.addEventListener("resize", this);
      document.addEventListener("scroll", this);
      if (window === window.top) {
        window.addEventListener(
          "blur",
          () => {
            if (isValidMathfield(this) && this.hasFocus()) {
              window.addEventListener(
                "focus",
                (evt) => {
                  if (evt.target === window && isValidMathfield(this))
                    this.focus({ scrollIntoView: false });
                },
                { once: true }
              );
            }
          },
          { capture: true }
        );
      }
      this.undoManager.startRecording();
      this.undoManager.snapshot();
      if (gKeyboardLayout && !l10n.locale.startsWith(gKeyboardLayout.locale))
        setKeyboardLayoutLocale(l10n.locale);
      if (gFontsState !== "ready")
        document.fonts.ready.then(() => renderSelection(this));
      element.querySelector(".ML__container").style.removeProperty("visibility");
    }
    connectToVirtualKeyboard() {
      if (this.connectedToVirtualKeyboard)
        return;
      this.connectedToVirtualKeyboard = true;
      window.addEventListener("message", this);
      window.mathVirtualKeyboard.connect();
      window.mathVirtualKeyboard.updateToolbar(makeProxy(this));
    }
    disconnectFromVirtualKeyboard() {
      if (!this.connectedToVirtualKeyboard)
        return;
      window.removeEventListener("message", this);
      window.mathVirtualKeyboard.disconnect();
      this.connectedToVirtualKeyboard = false;
    }
    /** Global Context.
     * These properties are accessed by the atom instances for rendering/layout
     */
    get colorMap() {
      return (name) => {
        var _a3;
        let result = void 0;
        if (typeof ((_a3 = this.options) == null ? void 0 : _a3.colorMap) === "function")
          result = this.options.colorMap(name);
        if (!result)
          result = defaultColorMap(name);
        return result;
      };
    }
    get backgroundColorMap() {
      return (name) => {
        var _a3;
        let result = void 0;
        if (typeof ((_a3 = this.options) == null ? void 0 : _a3.backgroundColorMap) === "function")
          result = this.options.backgroundColorMap(name);
        if (!result && typeof this.options.colorMap === "function")
          result = this.options.colorMap(name);
        if (!result)
          result = defaultBackgroundColorMap(name);
        return result;
      };
    }
    get fractionNavigationOrder() {
      return window.MathfieldElement.fractionNavigationOrder;
    }
    get placeholderSymbol() {
      var _a3, _b3;
      return (_b3 = (_a3 = this.options) == null ? void 0 : _a3.placeholderSymbol) != null ? _b3 : "\u25A2";
    }
    get smartFence() {
      var _a3, _b3;
      return (_b3 = (_a3 = this.options) == null ? void 0 : _a3.smartFence) != null ? _b3 : false;
    }
    get readOnly() {
      var _a3, _b3;
      return (_b3 = (_a3 = this.options) == null ? void 0 : _a3.readOnly) != null ? _b3 : false;
    }
    get disabled() {
      var _a3, _b3;
      return (_b3 = (_a3 = this.host) == null ? void 0 : _a3["disabled"]) != null ? _b3 : false;
    }
    // This reflects the contenteditable attribute.
    // Use hasEditableContent instead to take into account readonly and disabled
    // states.
    get contentEditable() {
      var _a3;
      return ((_a3 = this.host) == null ? void 0 : _a3.getAttribute("contenteditable")) !== "false";
    }
    // This reflect the `user-select` CSS property
    get userSelect() {
      if (!this.host)
        return "";
      const style = getComputedStyle(this.host);
      return style.getPropertyValue("user-select") || style.getPropertyValue("-webkit-user-select");
    }
    // Use to hide/show the virtual keyboard toggle. If false, no point in
    // showing  the toggle.
    get hasEditableContent() {
      if (this.disabled || !this.contentEditable)
        return false;
      return !this.readOnly || this.hasEditablePrompts;
    }
    get hasEditablePrompts() {
      return this.readOnly && !this.disabled && this.contentEditable && this.model.findAtom(
        (a) => a.type === "prompt" && !a.locked
      ) !== void 0;
    }
    /** Returns true if the selection is editable:
     * - mathfield is not disabled, and has contentEditable
     * - if mathfield is readonly, the current selection is in a prompt which is editable (not locked)
     */
    get isSelectionEditable() {
      if (this.disabled || !this.contentEditable)
        return false;
      if (!this.readOnly)
        return true;
      const anchor = this.model.at(this.model.anchor);
      const cursor = this.model.at(this.model.position);
      const ancestor = Atom.commonAncestor(anchor, cursor);
      if (ancestor == null ? void 0 : ancestor.parentPrompt)
        return true;
      return false;
    }
    get letterShapeStyle() {
      var _a3, _b3;
      return (_b3 = (_a3 = this.options) == null ? void 0 : _a3.letterShapeStyle) != null ? _b3 : "tex";
    }
    get registers() {
      var _a3, _b3;
      return (_b3 = (_a3 = this.options) == null ? void 0 : _a3.registers) != null ? _b3 : {};
    }
    getDefinition(token, parseMode = "math") {
      return defaultGetDefinition(token, parseMode);
    }
    getMacro(token) {
      return getMacroDefinition(
        token,
        this.options.macros
      );
    }
    get keybindings() {
      var _a3, _b3;
      if (this._keybindings)
        return this._keybindings;
      const [keybindings, errors] = normalizeKeybindings(
        this.options.keybindings,
        (_a3 = getActiveKeyboardLayout()) != null ? _a3 : DEFAULT_KEYBOARD_LAYOUT
      );
      if (((_b3 = getActiveKeyboardLayout()) == null ? void 0 : _b3.score) > 0) {
        this._keybindings = keybindings;
        if (errors.length > 0) {
          console.error(
            `MathLive 0.91.2: Invalid keybindings for current keyboard layout`,
            errors
          );
        }
      }
      return keybindings;
    }
    setOptions(config) {
      this.options = update(this.options, config);
      this.model.setListeners({
        onSelectionDidChange: (_sender) => this._onSelectionDidChange()
      });
      this.model.options.macros = this.options.macros;
      this._keybindings = void 0;
      if (this.options.defaultMode === "inline-math")
        this.element.classList.add("ML__is-inline");
      else
        this.element.classList.remove("ML__is-inline");
      if (this.options.readOnly) {
        if (this.hasFocus() && window.mathVirtualKeyboard.visible)
          this.executeCommand("hideVirtualKeyboard");
      }
      const content = Atom.serialize(this.model.root, {
        expandMacro: false,
        defaultMode: this.options.defaultMode
      });
      if ("macros" in config || this.model.getValue() !== content) {
        ModeEditor.insert("math", this.model, content, {
          insertionMode: "replaceAll",
          selectionMode: "after",
          format: "latex",
          suppressChangeNotifications: true
        });
      }
      requestUpdate(this);
    }
    getOptions(keys) {
      return get(this.options, keys);
    }
    getOption(key) {
      return get(this.options, key);
    }
    /*
     * handleEvent is a function invoked when an event is registered with an
     * object.
     * The name is defined by `addEventListener()` and cannot be changed.
     * This pattern is used to be able to release bound event handlers,
     * (event handlers that need access to `this`) as the `bind()` function
     * would create a new function that would have to be kept track of
     * to be able to properly remove the event handler later.
     */
    handleEvent(evt) {
      var _a3;
      if (!isValidMathfield(this))
        return;
      if (isVirtualKeyboardMessage(evt)) {
        if (!validateOrigin(evt.origin, (_a3 = this.options.originValidator) != null ? _a3 : "none")) {
          throw new DOMException(
            `Message from unknown origin (${evt.origin}) cannot be handled`,
            "SecurityError"
          );
        }
        const { action } = evt.data;
        if (action === "execute-command") {
          const command = evt.data.command;
          if (getCommandTarget(command) === "virtual-keyboard")
            return;
          this.executeCommand(command);
        } else if (action === "update-state") {
        } else if (action === "focus")
          this.focus({ scrollIntoView: false });
        else if (action === "blur")
          this.blur();
        return;
      }
      switch (evt.type) {
        case "focus":
          this.onFocus();
          break;
        case "blur":
          this.onBlur();
          break;
        case "mousedown":
          onPointerDown(this, evt);
          break;
        case "pointerdown":
          onPointerDown(this, evt);
          break;
        case "resize":
          if (this.geometryChangeTimer)
            cancelAnimationFrame(this.geometryChangeTimer);
          this.geometryChangeTimer = requestAnimationFrame(
            () => isValidMathfield(this) && this.onGeometryChange()
          );
          break;
        case "scroll":
          if (this.geometryChangeTimer)
            cancelAnimationFrame(this.geometryChangeTimer);
          this.geometryChangeTimer = requestAnimationFrame(
            () => isValidMathfield(this) && this.onGeometryChange()
          );
          break;
        case "wheel":
          this.onWheel(evt);
          break;
        default:
          console.warn("Unexpected event type", evt.type);
      }
    }
    dispose() {
      if (!isValidMathfield(this))
        return;
      this.disconnectFromVirtualKeyboard();
      const element = this.element;
      delete this.element;
      delete element.mathfield;
      element.innerHTML = this.model.getValue();
      element.removeEventListener("pointerdown", this);
      element.removeEventListener("mousedown", this);
      element.removeEventListener("focus", this);
      element.removeEventListener("blur", this);
      window.removeEventListener("resize", this);
      document.removeEventListener("scroll", this);
      window.removeEventListener("blur", this, { capture: true });
      delete this.ariaLiveText;
      delete this.field;
      delete this.fieldContent;
      disposePopover(this);
      disposeKeystrokeCaption(this);
      this.stylesheets.forEach((x) => x == null ? void 0 : x.release());
    }
    flushInlineShortcutBuffer(options) {
      options != null ? options : options = { defer: false };
      if (!options.defer) {
        this.inlineShortcutBuffer = [];
        clearTimeout(this.inlineShortcutBufferFlushTimer);
        this.inlineShortcutBufferFlushTimer = 0;
        return;
      }
      if (this.options.inlineShortcutTimeout > 0) {
        clearTimeout(this.inlineShortcutBufferFlushTimer);
        this.inlineShortcutBufferFlushTimer = setTimeout(
          () => this.flushInlineShortcutBuffer(),
          this.options.inlineShortcutTimeout
        );
      }
    }
    executeCommand(command) {
      if (getCommandTarget(command) === "virtual-keyboard") {
        this.focus({ scrollIntoView: false });
        window.mathVirtualKeyboard.executeCommand(command);
        requestAnimationFrame(
          () => window.mathVirtualKeyboard.updateToolbar(makeProxy(this))
        );
        return false;
      }
      return perform(this, command);
    }
    get errors() {
      return validateLatex(this.model.getValue(), this);
    }
    getValue(arg1, arg2, arg3) {
      return this.model.getValue(arg1, arg2, arg3);
    }
    setValue(value, options) {
      var _a3;
      options = options != null ? options : { mode: "math" };
      if (options.insertionMode === void 0)
        options.insertionMode = "replaceAll";
      if (options.format === void 0 || options.format === "auto")
        options.format = "latex";
      let mode = "math";
      if (options.mode === void 0 || options.mode === "auto")
        mode = (_a3 = getMode(this.model, this.model.position)) != null ? _a3 : "math";
      if (ModeEditor.insert(mode, this.model, value, options)) {
        this.undoManager.snapshot();
        requestUpdate(this);
      }
    }
    get expression() {
      const ce = window.MathfieldElement.computeEngine;
      if (!ce) {
        console.error(
          `MathLive 0.91.2:  no compute engine available. Make sure the Compute Engine library is loaded.`
        );
        return null;
      }
      return ce.box(ce.parse(this.model.getValue()));
    }
    /** Make sure the caret is visible within the matfield.
     * If using mathfield element, make sure the mathfield element is visible in
     * the page
     */
    scrollIntoView() {
      var _a3;
      if (!this.element)
        return;
      if (this.host) {
        this.host.scrollIntoView({ block: "nearest", inline: "nearest" });
        if (window.mathVirtualKeyboard.visible && window.mathVirtualKeyboard.container === window.document.body) {
          const kbdBounds = window.mathVirtualKeyboard.boundingRect;
          const mathfieldBounds = this.host.getBoundingClientRect();
          if (mathfieldBounds.bottom > kbdBounds.top) {
            (_a3 = window.document.scrollingElement) == null ? void 0 : _a3.scrollBy(
              0,
              mathfieldBounds.bottom - kbdBounds.top + 8
            );
          }
        }
      }
      if (this.dirty)
        render(this, { interactive: true });
      const fieldBounds = this.field.getBoundingClientRect();
      let caretPoint = null;
      if (this.model.selectionIsCollapsed)
        caretPoint = getCaretPoint(this.field);
      else {
        const selectionBounds = getSelectionBounds(this);
        if (selectionBounds.length > 0) {
          let maxRight = -Infinity;
          let minTop = -Infinity;
          for (const r of selectionBounds) {
            if (r.right > maxRight)
              maxRight = r.right;
            if (r.top < minTop)
              minTop = r.top;
          }
          caretPoint = {
            x: maxRight + fieldBounds.left - this.field.scrollLeft,
            y: minTop + fieldBounds.top - this.field.scrollTop,
            height: 0
          };
        }
      }
      if (this.host && caretPoint) {
        const hostBounds = this.host.getBoundingClientRect();
        const y = caretPoint.y;
        let top = this.host.scrollTop;
        if (y < hostBounds.top)
          top = y - hostBounds.top + this.host.scrollTop;
        else if (y > hostBounds.bottom)
          top = y - hostBounds.bottom + this.host.scrollTop + caretPoint.height;
        this.host.scroll({ top, left: 0 });
      }
      if (caretPoint) {
        const x = caretPoint.x - window.scrollX;
        let left = this.field.scrollLeft;
        if (x < fieldBounds.left)
          left = x - fieldBounds.left + this.field.scrollLeft - 20;
        else if (x > fieldBounds.right)
          left = x - fieldBounds.right + this.field.scrollLeft + 20;
        this.field.scroll({
          top: this.field.scrollTop,
          // should always be 0
          left
        });
      }
    }
    insert(s, options) {
      if (typeof s !== "string")
        return false;
      if (s.length === 0 && ((options == null ? void 0 : options.insertionMode) === "insertBefore" || (options == null ? void 0 : options.insertionMode) === "insertAfter"))
        return false;
      if (s.length === 0 && this.model.selectionIsCollapsed)
        return false;
      this.flushInlineShortcutBuffer();
      options = options != null ? options : { mode: "math" };
      if (options.focus)
        this.focus();
      if (options.feedback) {
        if (window.MathfieldElement.keypressVibration && canVibrate())
          navigator.vibrate(HAPTIC_FEEDBACK_DURATION);
        window.MathfieldElement.playSound("keypress");
      }
      if (options.scrollIntoView)
        this.scrollIntoView();
      if (s === "\\\\") {
        addRowAfter(this.model);
      } else if (s === "&")
        addColumnAfter(this.model);
      else {
        const savedStyle = this.style;
        ModeEditor.insert(this.mode, this.model, s, __spreadValues({
          style: this.model.at(this.model.position).computedStyle
        }, options));
        if (options.resetStyle)
          this.style = savedStyle;
      }
      this.undoManager.snapshot();
      requestUpdate(this);
      return true;
    }
    switchMode(mode, prefix = "", suffix = "") {
      var _a3;
      if (this.mode === mode || !this.hasEditableContent || !this.contentEditable || this.disabled)
        return;
      if (!((_a3 = this.host) == null ? void 0 : _a3.dispatchEvent(
        new Event("mode-change", {
          bubbles: true,
          composed: true,
          cancelable: true
        })
      )))
        return;
      const currentMode = this.mode;
      const { model } = this;
      model.deferNotifications(
        {
          content: Boolean(suffix) || Boolean(prefix),
          selection: true,
          type: "insertText"
        },
        () => {
          let contentChanged = false;
          this.flushInlineShortcutBuffer();
          this.smartModeSuppressed = /text|math/.test(this.mode) && /text|math/.test(mode);
          if (prefix && mode !== "latex") {
            const atoms = parseLatex(prefix, this, { parseMode: mode });
            model.collapseSelection("forward");
            const cursor = model.at(model.position);
            model.position = model.offsetOf(
              cursor.parent.addChildrenAfter(atoms, cursor)
            );
            contentChanged = true;
          }
          this.mode = mode;
          if (mode === "latex") {
            let wasCollapsed = model.selectionIsCollapsed;
            complete(this, "accept");
            let latex;
            let cursor = model.at(model.position);
            if (wasCollapsed)
              latex = "\\";
            else {
              const selRange = range(model.selection);
              latex = this.model.getValue(selRange, "latex");
              const extractedAtoms = this.model.extractAtoms(selRange);
              if (extractedAtoms.length === 1 && extractedAtoms[0] instanceof PlaceholderAtom) {
                latex = prefix;
                wasCollapsed = true;
              }
              cursor = model.at(selRange[0]);
            }
            const atom = new LatexGroupAtom(latex, this);
            cursor.parent.addChildAfter(atom, cursor);
            if (wasCollapsed)
              model.position = model.offsetOf(atom.lastChild);
            else {
              model.setSelection(
                model.offsetOf(atom.firstChild),
                model.offsetOf(atom.lastChild)
              );
            }
          } else {
            getLatexGroupBody(model).forEach((x) => {
              x.isError = false;
            });
          }
          if (suffix) {
            const atoms = parseLatex(suffix, this, { parseMode: currentMode });
            model.collapseSelection("forward");
            const cursor = model.at(model.position);
            model.position = model.offsetOf(
              cursor.parent.addChildrenAfter(atoms, cursor)
            );
            contentChanged = true;
          }
          requestUpdate(this);
          return contentChanged;
        }
      );
      this.mode = mode;
    }
    hasFocus() {
      return !this.blurred;
    }
    focus(options) {
      var _a3;
      if (!this.hasFocus()) {
        this.keyboardDelegate.focus();
        this.connectToVirtualKeyboard();
        this.model.announce("line");
      }
      if ((_a3 = options == null ? void 0 : options.scrollIntoView) != null ? _a3 : true)
        this.scrollIntoView();
    }
    blur() {
      this.disconnectFromVirtualKeyboard();
      if (!this.hasFocus())
        return;
      this.keyboardDelegate.blur();
    }
    select() {
      this.model.selection = { ranges: [[0, this.model.lastOffset]] };
    }
    applyStyle(inStyle, inOptions = {}) {
      var _a3, _b3;
      const options = {
        operation: "set",
        suppressChangeNotifications: false
      };
      if (isRange(inOptions))
        options.range = inOptions;
      else {
        options.range = inOptions.range;
        options.suppressChangeNotifications = (_a3 = inOptions.suppressChangeNotifications) != null ? _a3 : false;
      }
      const style = validateStyle(this, inStyle);
      const operation = (_b3 = options.operation) != null ? _b3 : "set";
      this.model.deferNotifications(
        { content: !options.suppressChangeNotifications, type: "insertText" },
        () => {
          if (options.range === void 0) {
            for (const range2 of this.model.selection.ranges)
              applyStyle(this.model, range2, style, { operation });
          } else
            applyStyle(this.model, options.range, style, { operation });
        }
      );
      requestUpdate(this);
    }
    getCaretPoint() {
      const caretOffset = getCaretPoint(this.field);
      return caretOffset ? { x: caretOffset.x, y: caretOffset.y } : null;
    }
    setCaretPoint(x, y) {
      const newPosition = offsetFromPoint(this, x, y, { bias: 0 });
      if (newPosition < 0)
        return false;
      const previousPosition = this.model.position;
      this.model.position = newPosition;
      this.model.announce("move", previousPosition);
      requestUpdate(this);
      return true;
    }
    getPrompt(id) {
      const prompt = this.model.findAtom(
        (a) => a.type === "prompt" && a.placeholderId === id
      );
      console.assert(
        prompt !== void 0,
        `MathLive 0.91.2:  no prompts with matching ID found`
      );
      return prompt;
    }
    getPromptValue(id, format) {
      const prompt = this.getPrompt(id);
      if (!prompt) {
        console.error(`MathLive 0.91.2: unknown prompt ${id}`);
        return "";
      }
      const first = this.model.offsetOf(prompt.firstChild);
      const last = this.model.offsetOf(prompt.lastChild);
      return this.model.getValue(first, last, format);
    }
    getPrompts(filter) {
      return this.model.getAllAtoms().filter((a) => {
        if (a.type !== "prompt")
          return false;
        if (!filter)
          return true;
        if (filter.id && a.placeholderId !== filter.id)
          return false;
        if (filter.locked && a.locked !== filter.locked)
          return false;
        if (filter.correctness === "undefined" && a.correctness)
          return false;
        if (filter.correctness && a.correctness !== filter.correctness)
          return false;
        return true;
      }).map((a) => a.placeholderId);
    }
    setPromptValue(id, value, insertOptions) {
      if (value !== void 0) {
        const prompt = this.getPrompt(id);
        if (!prompt) {
          console.error(`MathLive 0.91.2: unknown prompt ${id}`);
          return;
        }
        const branchRange = this.model.getBranchRange(
          this.model.offsetOf(prompt),
          "body"
        );
        this.model.setSelection(branchRange);
        this.insert(value, __spreadProps(__spreadValues({}, insertOptions), {
          insertionMode: "replaceSelection"
        }));
      }
      if (insertOptions == null ? void 0 : insertOptions.suppressChangeNotifications)
        this.valueOnFocus = this.getValue();
      requestUpdate(this);
    }
    setPromptState(id, state, locked) {
      const prompt = this.getPrompt(id);
      if (!prompt) {
        console.error(`MathLive 0.91.2: unknown prompt ${id}`);
        return;
      }
      if (state === "undefined")
        prompt.correctness = void 0;
      else if (typeof state === "string")
        prompt.correctness = state;
      if (typeof locked === "boolean") {
        prompt.locked = locked;
        prompt.captureSelection = locked;
      }
      requestUpdate(this);
    }
    getPromptState(id) {
      const prompt = this.getPrompt(id);
      if (!prompt) {
        console.error(`MathLive 0.91.2: unknown prompt ${id}`);
        return [void 0, true];
      }
      return [prompt.correctness, prompt.locked];
    }
    canUndo() {
      return this.undoManager.canUndo();
    }
    canRedo() {
      return this.undoManager.canRedo();
    }
    popUndoStack() {
      this.undoManager.pop();
    }
    snapshot() {
      var _a3;
      if (this.undoManager.snapshot()) {
        window.mathVirtualKeyboard.updateToolbar(makeProxy(this));
        (_a3 = this.host) == null ? void 0 : _a3.dispatchEvent(
          new CustomEvent("undo-state-change", {
            bubbles: true,
            composed: true,
            detail: { type: "snapshot" }
          })
        );
      }
    }
    snapshotAndCoalesce() {
      var _a3;
      if (this.undoManager.snapshotAndCoalesce()) {
        window.mathVirtualKeyboard.updateToolbar(makeProxy(this));
        (_a3 = this.host) == null ? void 0 : _a3.dispatchEvent(
          new CustomEvent("undo-state-change", {
            bubbles: true,
            composed: true,
            detail: { type: "snapshot" }
          })
        );
      }
    }
    undo() {
      var _a3;
      if (!this.undoManager.undo())
        return;
      window.mathVirtualKeyboard.updateToolbar(makeProxy(this));
      (_a3 = this.host) == null ? void 0 : _a3.dispatchEvent(
        new CustomEvent("undo-state-change", {
          bubbles: true,
          composed: true,
          detail: { type: "undo" }
        })
      );
    }
    redo() {
      var _a3;
      if (!this.undoManager.redo())
        return;
      window.mathVirtualKeyboard.updateToolbar(makeProxy(this));
      (_a3 = this.host) == null ? void 0 : _a3.dispatchEvent(
        new CustomEvent("undo-state-change", {
          bubbles: true,
          composed: true,
          detail: { type: "undo" }
        })
      );
    }
    resetUndo() {
      var _a3;
      (_a3 = this.undoManager) == null ? void 0 : _a3.reset();
    }
    _onSelectionDidChange() {
      var _a3, _b3;
      const model = this.model;
      this.keyboardDelegate.setValue(
        this.model.getValue(this.model.selection, "latex-expanded")
      );
      {
        const cursor = model.at(model.position);
        const newMode = (_a3 = cursor.mode) != null ? _a3 : effectiveMode(this.options);
        if (this.mode !== newMode) {
          if (this.mode === "latex") {
            complete(this, "accept", { mode: newMode });
            model.position = model.offsetOf(cursor);
          } else
            this.switchMode(newMode);
        }
      }
      (_b3 = this.host) == null ? void 0 : _b3.dispatchEvent(
        new Event("selection-change", {
          bubbles: true,
          composed: true
        })
      );
    }
    onFocus() {
      if (this.focusBlurInProgress || !this.blurred)
        return;
      this.focusBlurInProgress = true;
      this.blurred = false;
      this.keyboardDelegate.focus();
      render(this, { interactive: true });
      this.valueOnFocus = this.model.getValue();
      if (this.hasEditablePrompts && !this.model.at(this.model.anchor).parentPrompt)
        this.executeCommand("moveToNextPlaceholder");
      this.focusBlurInProgress = false;
    }
    onBlur() {
      var _a3, _b3, _c2;
      if (this.focusBlurInProgress || this.blurred)
        return;
      this.focusBlurInProgress = true;
      this.blurred = true;
      this.ariaLiveText.textContent = "";
      complete(this, "accept");
      if (this.model.getValue() !== this.valueOnFocus) {
        (_a3 = this.host) == null ? void 0 : _a3.dispatchEvent(
          new Event("change", { bubbles: true, composed: true })
        );
      }
      this.disconnectFromVirtualKeyboard();
      (_b3 = this.host) == null ? void 0 : _b3.dispatchEvent(
        new Event("blur", {
          bubbles: false,
          // DOM 'focus' and 'blur' don't bubble
          composed: true
        })
      );
      (_c2 = this.host) == null ? void 0 : _c2.dispatchEvent(
        new UIEvent("focusout", {
          bubbles: true,
          // unlike 'blur', focusout does bubble
          composed: true
        })
      );
      requestUpdate(this);
      this.focusBlurInProgress = false;
    }
    onCompositionStart(_composition) {
      this.model.deleteAtoms(range(this.model.selection));
      const caretPoint = getCaretPoint(this.field);
      if (!caretPoint)
        return;
      requestAnimationFrame(() => {
        render(this);
        this.keyboardDelegate.moveTo(
          caretPoint.x,
          caretPoint.y - caretPoint.height
        );
      });
    }
    onCompositionUpdate(composition) {
      updateComposition(this.model, composition);
      requestUpdate(this);
    }
    onCompositionEnd(composition) {
      removeComposition(this.model);
      onInput(this, composition, {
        simulateKeystroke: true
      });
    }
    onGeometryChange() {
      updatePopoverPosition(this);
    }
    onWheel(ev) {
      const wheelDelta = 5 * ev.deltaX;
      if (!Number.isFinite(wheelDelta) || wheelDelta === 0)
        return;
      const field = this.field;
      if (wheelDelta < 0 && field.scrollLeft === 0)
        return;
      if (wheelDelta > 0 && field.offsetWidth + field.scrollLeft >= field.scrollWidth)
        return;
      field.scrollBy({ top: 0, left: wheelDelta });
      ev.preventDefault();
      ev.stopPropagation();
    }
    getHTMLElement(atom) {
      var _a3;
      let target = atom;
      while (!target.id && target.hasChildren)
        target = atom.children[0];
      if (target.id) {
        return (_a3 = this.fieldContent) == null ? void 0 : _a3.querySelector(
          `[data-atom-id="${target.id}"]`
        );
      }
      throw new TypeError("Could not get an ID from atom");
    }
  };

  // src/editor-model/commands.ts
  function wordBoundaryOffset(model, offset, direction) {
    if (model.at(offset).mode !== "text")
      return offset;
    const dir = direction === "backward" ? -1 : 1;
    let result;
    if (LETTER_AND_DIGITS.test(model.at(offset).value)) {
      let i = offset;
      let match;
      do {
        match = model.at(i).mode === "text" && LETTER_AND_DIGITS.test(model.at(i).value);
        i += dir;
      } while (model.at(i) && match);
      result = model.at(i) ? i - 2 * dir : i - dir;
    } else if (/\s/.test(model.at(offset).value)) {
      let i = offset;
      while (model.at(i) && model.at(i).mode === "text" && /\s/.test(model.at(i).value))
        i += dir;
      if (!model.at(i)) {
        result = i - dir;
      } else {
        let match = true;
        do {
          match = model.at(i).mode === "text" && !/\s/.test(model.at(i).value);
          i += dir;
        } while (model.at(i) && match);
        result = model.at(i) ? i - 2 * dir : i - dir;
      }
    } else {
      let i = offset;
      while (model.at(i) && model.at(i).mode === "text" && !/\s/.test(model.at(i).value))
        i += dir;
      result = model.at(i) ? i : i - dir;
      let match = true;
      while (model.at(i) && match) {
        match = model.at(i).mode === "text" && /\s/.test(model.at(i).value);
        if (match)
          result = i;
        i += dir;
      }
      result = model.at(i) ? i - 2 * dir : i - dir;
    }
    return result - (dir > 0 ? 0 : 1);
  }
  function skip(model, direction, options) {
    var _a3, _b3, _c2, _d2, _e, _f, _g;
    const previousPosition = model.position;
    if (!((_a3 = options == null ? void 0 : options.extend) != null ? _a3 : false))
      model.collapseSelection(direction);
    let atom = model.at(model.position);
    if (direction === "forward") {
      if (atom.type === "msubsup") {
        atom = atom.rightSibling;
        if (!atom)
          atom = model.at(model.position + 1);
      } else
        atom = model.at(model.position + 1);
    }
    if (!atom) {
      model.announce("plonk");
      return false;
    }
    let offset = model.offsetOf(atom);
    if (atom instanceof TextAtom) {
      offset = wordBoundaryOffset(model, offset, direction);
    } else if (atom instanceof LatexAtom) {
      if (atom.isSuggestion) {
        console.assert(direction === "forward");
        while (atom && atom instanceof LatexAtom) {
          atom.isSuggestion = false;
          offset = model.offsetOf(atom);
          atom = atom.rightSibling;
        }
      } else if (direction === "forward") {
        atom = atom.rightSibling;
        if (!atom || !(atom instanceof LatexAtom)) {
          model.announce("plonk");
          return false;
        }
        while (atom && atom instanceof LatexAtom && /[a-zA-Z\*]/.test(atom.value)) {
          offset = model.offsetOf(atom);
          atom = atom.rightSibling;
        }
      } else {
        atom = atom.leftSibling;
        if (!atom || !(atom instanceof LatexAtom)) {
          model.announce("plonk");
          return false;
        }
        while (atom && atom instanceof LatexAtom && /[a-zA-Z\*]/.test(atom.value)) {
          offset = model.offsetOf(atom);
          atom = atom.leftSibling;
        }
      }
    } else if (direction === "forward" && atom.type === "mopen") {
      let level = 0;
      do {
        if (atom.type === "mopen")
          level += 1;
        else if (atom.type === "mclose")
          level -= 1;
        atom = atom.rightSibling;
      } while (!atom.isLastSibling && level !== 0);
      offset = model.offsetOf(atom.leftSibling);
    } else if (direction === "backward" && atom.type === "mclose") {
      let level = 0;
      do {
        if (atom.type === "mopen")
          level += 1;
        else if (atom.type === "mclose")
          level -= 1;
        atom = atom.leftSibling;
      } while (!atom.isFirstSibling && level !== 0);
      offset = model.offsetOf(atom);
    } else if (direction === "backward") {
      if (atom.type === "first") {
        while (offset > 0 && atom.type === "first") {
          offset -= 1;
          atom = model.at(offset);
        }
      } else {
        const type = atom.type;
        if (atom.type === "msubsup") {
          offset = model.offsetOf(model.at(offset).leftSibling);
        }
        offset -= 1;
        let nextType = (_b3 = model.at(offset)) == null ? void 0 : _b3.type;
        while (offset >= 0 && nextType === type) {
          if (((_c2 = model.at(offset)) == null ? void 0 : _c2.type) === "msubsup")
            offset = model.offsetOf(model.at(offset).leftSibling);
          else
            offset -= 1;
          nextType = model.at(offset).type;
        }
      }
    } else {
      const { type } = atom;
      let nextType = (_d2 = model.at(offset)) == null ? void 0 : _d2.type;
      const { lastOffset } = model;
      while (offset <= lastOffset && (nextType === type || nextType === "msubsup")) {
        while (((_e = model.at(offset).rightSibling) == null ? void 0 : _e.type) === "msubsup")
          offset = model.offsetOf(model.at(offset).rightSibling);
        offset += 1;
        nextType = (_f = model.at(offset)) == null ? void 0 : _f.type;
      }
      offset -= 1;
    }
    if ((_g = options == null ? void 0 : options.extend) != null ? _g : false) {
      if (!model.setSelection(model.anchor, offset)) {
        model.announce("plonk");
        return false;
      }
    } else {
      if (offset === model.position) {
        model.announce("plonk");
        return false;
      }
      model.position = offset;
    }
    model.announce("move", previousPosition);
    return true;
  }
  function move(model, direction, options) {
    var _a3, _b3, _c2, _d2, _e, _f;
    options = options != null ? options : { extend: false };
    model.mathfield.adoptStyle = direction === "backward" ? "right" : "left";
    if (direction !== "forward") {
      const [from, to] = getCommandSuggestionRange(model);
      if (from !== void 0 && to !== void 0)
        model.deleteAtoms([from, to]);
    }
    if (direction === "upward")
      return moveUpward(model, options);
    if (direction === "downward")
      return moveDownward(model, options);
    const previousPosition = model.position;
    if (options.extend)
      return model.extendSelection(direction);
    if (model.selectionIsPlaceholder) {
      model.collapseSelection(direction);
      return move(model, direction);
    }
    const handleDeadEnd = () => {
      var _a4, _b4;
      let result = true;
      if (!model.suppressChangeNotifications) {
        result = (_b4 = (_a4 = model.mathfield.host) == null ? void 0 : _a4.dispatchEvent(
          new CustomEvent("move-out", {
            detail: { direction },
            cancelable: true,
            bubbles: true,
            composed: true
          })
        )) != null ? _b4 : true;
      }
      if (result)
        model.announce("plonk");
      return result;
    };
    if (!model.collapseSelection(direction)) {
      let pos = model.position + (direction === "forward" ? 1 : -1);
      let atom = model.at(pos);
      if (pos >= 0 && pos <= model.lastOffset) {
        if (direction === "forward") {
          if (model.mathfield.hasEditablePrompts && !model.at(pos).parentPrompt) {
            const nextAtoms = model.getAtoms(pos, -1).map((a) => [a, ...a.children]).flat();
            const nextPrompts = nextAtoms.filter(
              (p) => p.type === "prompt" && !p.captureSelection
            );
            const nextPrompt = nextPrompts[0];
            if (!nextPrompt)
              return handleDeadEnd();
            pos = model.offsetOf(nextPrompt) - 1;
          } else if (atom.inCaptureSelection) {
            while (!atom.captureSelection)
              atom = atom.parent;
            pos = model.offsetOf(atom);
          } else if (!atom.isFirstSibling && atom.isLastSibling && ((_a3 = atom.parent) == null ? void 0 : _a3.skipBoundary)) {
            if (pos + 1 === model.lastOffset)
              pos = pos + 1;
            else {
              model.position = pos;
              return move(model, "forward", options);
            }
          } else if (((_b3 = atom.parent) == null ? void 0 : _b3.skipBoundary) && ((_c2 = atom.rightSibling) == null ? void 0 : _c2.isLastSibling))
            pos += 2;
          else if (((_d2 = atom.parent) == null ? void 0 : _d2.skipBoundary) && atom.type === "first")
            pos += 1;
          else if (atom instanceof LatexAtom && atom.isSuggestion)
            atom.isSuggestion = false;
        } else if (direction === "backward") {
          if (model.mathfield.hasEditablePrompts && !model.at(pos).parentPrompt) {
            const previousAtoms = model.getAtoms(0, pos).map((a) => [a, ...a.children]).flat();
            const previousPrompts = previousAtoms.filter(
              (p) => p.type === "prompt" && !p.captureSelection
            );
            const previousPrompt = previousPrompts[previousPrompts.length - 1];
            if (!previousPrompt)
              return handleDeadEnd();
            pos = model.offsetOf(previousPrompt) - 1;
          } else if ((_e = atom.parent) == null ? void 0 : _e.inCaptureSelection) {
            while (!atom.captureSelection)
              atom = atom.parent;
            pos = Math.max(0, model.offsetOf(atom.leftSibling));
          } else if (atom.skipBoundary) {
            pos = Math.max(0, model.position - 2);
          } else if (((_f = atom.parent) == null ? void 0 : _f.skipBoundary) && atom.type === "first")
            pos = Math.max(0, model.position - 2);
        }
      }
      if (pos < 0 || pos > model.lastOffset)
        return handleDeadEnd();
      model.setPositionHandlingPlaceholder(pos);
    }
    model.announce("move", previousPosition);
    return true;
  }
  function getClosestAtomToXPosition(mathfield, search, x) {
    let prevX = Infinity;
    let i = 0;
    for (; i < search.length; i++) {
      const toX = getLocalDOMRect(mathfield.getHTMLElement(search[i])).right;
      const abs = Math.abs(x - toX);
      if (abs <= prevX) {
        prevX = abs;
      } else {
        break;
      }
    }
    return search[i - 1];
  }
  function moveToClosestAtomVertically(model, fromAtom, toAtoms, extend, direction) {
    const hasEditablePrompts = model.mathfield.hasEditablePrompts;
    const editableAtoms = !hasEditablePrompts ? toAtoms : toAtoms.filter((a) => a.type === "prompt" && !a.captureSelection);
    const fromX = getLocalDOMRect(model.mathfield.getHTMLElement(fromAtom)).right;
    const targetSelection = model.offsetOf(
      getClosestAtomToXPosition(model.mathfield, editableAtoms, fromX)
    ) - (hasEditablePrompts ? 1 : 0);
    if (extend) {
      const [left, right] = model.selection.ranges[0];
      let newSelection;
      const cmp = direction === "up" ? left : right;
      if (targetSelection < cmp) {
        newSelection = {
          ranges: [[targetSelection, right]],
          direction: "backward"
        };
      } else {
        newSelection = {
          ranges: [[left, targetSelection]],
          direction: "forward"
        };
      }
      model.setSelection(newSelection);
    } else {
      model.setPositionHandlingPlaceholder(targetSelection);
    }
    model.announce(`move ${direction}`);
  }
  function moveUpward(model, options) {
    var _a3, _b3;
    const extend = (_a3 = options == null ? void 0 : options.extend) != null ? _a3 : false;
    if (!extend)
      model.collapseSelection("backward");
    const handleDeadEnd = () => {
      var _a4, _b4;
      let result = true;
      if (!model.suppressChangeNotifications) {
        result = (_b4 = (_a4 = model.mathfield.host) == null ? void 0 : _a4.dispatchEvent(
          new CustomEvent("move-out", {
            detail: { direction: "upward" },
            cancelable: true,
            bubbles: true,
            composed: true
          })
        )) != null ? _b4 : true;
      }
      model.announce(result ? "plonk" : "line");
      return result;
    };
    const baseAtom = model.at(model.position);
    let atom = baseAtom;
    while (atom && atom.treeBranch !== "below" && !(Array.isArray(atom.treeBranch) && atom.parent instanceof ArrayAtom))
      atom = atom.parent;
    if (Array.isArray(atom == null ? void 0 : atom.treeBranch) && atom.parent instanceof ArrayAtom) {
      const arrayAtom = atom.parent;
      if (atom.treeBranch[0] < 1)
        return handleDeadEnd();
      const rowAbove = atom.treeBranch[0] - 1;
      const aboveCell = arrayAtom.array[rowAbove][atom.treeBranch[1]];
      const cellHasPrompt = aboveCell.some(
        (a) => a.type === "prompt" && !a.captureSelection
      );
      if (!cellHasPrompt && model.mathfield.hasEditablePrompts)
        return handleDeadEnd();
      moveToClosestAtomVertically(model, baseAtom, aboveCell, extend, "up");
    } else if (atom) {
      const branch = (_b3 = atom.parent.branch("above")) != null ? _b3 : atom.parent.createBranch("above");
      const branchHasPrompt = branch.some(
        (a) => a.type === "prompt" && a.placeholderId
      );
      if (!branchHasPrompt && model.mathfield.hasEditablePrompts)
        return handleDeadEnd();
      moveToClosestAtomVertically(model, baseAtom, branch, extend, "up");
    } else
      return handleDeadEnd();
    return true;
  }
  function moveDownward(model, options) {
    var _a3, _b3;
    const extend = (_a3 = options == null ? void 0 : options.extend) != null ? _a3 : false;
    if (!extend)
      model.collapseSelection("forward");
    const handleDeadEnd = () => {
      var _a4, _b4;
      let result = true;
      if (!model.suppressChangeNotifications) {
        result = (_b4 = (_a4 = model.mathfield.host) == null ? void 0 : _a4.dispatchEvent(
          new CustomEvent("move-out", {
            detail: { direction: "downward" },
            cancelable: true,
            bubbles: true,
            composed: true
          })
        )) != null ? _b4 : true;
      }
      model.announce(result ? "plonk" : "line");
      return result;
    };
    const baseAtom = model.at(model.position);
    let atom = baseAtom;
    while (atom && atom.treeBranch !== "above" && !(Array.isArray(atom.treeBranch) && atom.parent instanceof ArrayAtom))
      atom = atom.parent;
    if (Array.isArray(atom == null ? void 0 : atom.treeBranch) && atom.parent instanceof ArrayAtom) {
      const arrayAtom = atom.parent;
      if (atom.treeBranch[0] + 1 > arrayAtom.array.length - 1)
        return handleDeadEnd();
      const rowBelow = atom.treeBranch[0] + 1;
      const belowCell = arrayAtom.array[rowBelow][atom.treeBranch[1]];
      const cellHasPrompt = belowCell.some(
        (a) => a.type === "prompt" && !a.captureSelection
      );
      if (!cellHasPrompt && model.mathfield.hasEditablePrompts)
        return handleDeadEnd();
      moveToClosestAtomVertically(model, baseAtom, belowCell, extend, "down");
    } else if (atom) {
      const branch = (_b3 = atom.parent.branch("below")) != null ? _b3 : atom.parent.createBranch("below");
      const branchHasPrompt = branch.some((a) => a.type === "prompt");
      if (!branchHasPrompt && model.mathfield.hasEditablePrompts)
        return handleDeadEnd();
      moveToClosestAtomVertically(model, baseAtom, branch, extend, "down");
    } else
      return handleDeadEnd();
    return true;
  }

  // src/editor-model/commands-delete.ts
  register2(
    {
      deleteAll: (model) => contentWillChange(model, { inputType: "deleteContent" }) && deleteRange(model, [0, -1], "deleteContent"),
      deleteForward: (model) => deleteForward(model),
      deleteBackward: (model) => deleteBackward(model),
      deleteNextWord: (model) => contentWillChange(model, { inputType: "deleteWordForward" }) && deleteRange(
        model,
        [model.anchor, wordBoundaryOffset(model, model.position, "forward")],
        "deleteWordForward"
      ),
      deletePreviousWord: (model) => contentWillChange(model, { inputType: "deleteWordBackward" }) && deleteRange(
        model,
        [model.anchor, wordBoundaryOffset(model, model.position, "backward")],
        "deleteWordBackward"
      ),
      deleteToGroupStart: (model) => contentWillChange(model, { inputType: "deleteSoftLineBackward" }) && deleteRange(
        model,
        [model.anchor, model.offsetOf(model.at(model.position).firstSibling)],
        "deleteSoftLineBackward"
      ),
      deleteToGroupEnd: (model) => contentWillChange(model, { inputType: "deleteSoftLineForward" }) && deleteRange(
        model,
        [model.anchor, model.offsetOf(model.at(model.position).lastSibling)],
        "deleteSoftLineForward"
      ),
      deleteToMathFieldStart: (model) => contentWillChange(model, { inputType: "deleteHardLineBackward" }) && deleteRange(model, [model.anchor, 0], "deleteHardLineBackward"),
      deleteToMathFieldEnd: (model) => contentWillChange(model, { inputType: "deleteHardLineForward" }) && deleteRange(model, [model.anchor, -1], "deleteHardLineForward")
    },
    { target: "model", category: "delete" }
  );

  // src/editor/speech-read-aloud.ts
  function removeHighlight(element) {
    if (!element)
      return;
    element.classList.remove("ML__highlight");
    if (element.children)
      for (const child of element.children)
        removeHighlight(child);
  }
  function highlightAtomID(element, atomID) {
    var _a3;
    if (!element)
      return;
    if (!atomID || ((_a3 = element.dataset) == null ? void 0 : _a3.atomId) === atomID) {
      element.classList.add("ML__highlight");
      if (element.children && element.children.length > 0) {
        [...element.children].forEach((x) => {
          if (x instanceof HTMLElement)
            highlightAtomID(x);
        });
      }
    } else {
      element.classList.remove("ML__highlight");
      if (element.children && element.children.length > 0) {
        [...element.children].forEach((x) => {
          if (x instanceof HTMLElement)
            highlightAtomID(x, atomID);
        });
      }
    }
  }
  function defaultReadAloudHook(element, text) {
    var _a3;
    if (!isBrowser())
      return;
    if (window.MathfieldElement.speechEngine !== "amazon") {
      console.error(
        `MathLive 0.91.2: Use Amazon TTS Engine for synchronized highlighting`
      );
      if (typeof window.MathfieldElement.speakHook === "function")
        window.MathfieldElement.speakHook(text);
      return;
    }
    if (!window.AWS) {
      console.error(
        `MathLive 0.91.2: AWS SDK not loaded. See https://www.npmjs.com/package/aws-sdk`
      );
      return;
    }
    const polly = new window.AWS.Polly({ apiVersion: "2016-06-10" });
    const parameters = {
      OutputFormat: "json",
      VoiceId: (_a3 = window.MathfieldElement.speechEngineVoice) != null ? _a3 : "Joanna",
      Engine: "standard",
      // The neural engine does not appear to support ssml marks
      Text: text,
      TextType: "ssml",
      SpeechMarkTypes: ["ssml"]
    };
    globalMathLive().readAloudElement = element;
    polly.synthesizeSpeech(parameters, (err, data) => {
      if (err) {
        console.trace(
          `MathLive 0.91.2: \`polly.synthesizeSpeech()\` error: ${err}`
        );
        return;
      }
      if (!(data == null ? void 0 : data.AudioStream)) {
        console.log("polly.synthesizeSpeech():", data);
        return;
      }
      const response = new TextDecoder("utf-8").decode(
        new Uint8Array(data.AudioStream)
      );
      globalMathLive().readAloudMarks = response.split("\n").map((x) => x ? JSON.parse(x) : {});
      globalMathLive().readAloudTokens = [];
      for (const mark of globalMathLive().readAloudMarks)
        if (mark.value)
          globalMathLive().readAloudTokens.push(mark.value);
      globalMathLive().readAloudCurrentMark = "";
      parameters.OutputFormat = "mp3";
      parameters.SpeechMarkTypes = [];
      polly.synthesizeSpeech(parameters, (err2, data2) => {
        if (err2) {
          console.trace(
            `MathLive 0.91.2: \`polly.synthesizeSpeech("${text}") error:${err2}`
          );
          return;
        }
        if (!(data2 == null ? void 0 : data2.AudioStream))
          return;
        const uInt8Array = new Uint8Array(data2.AudioStream);
        const blob = new Blob([uInt8Array.buffer], {
          type: "audio/mpeg"
        });
        const url = URL.createObjectURL(blob);
        const global = globalMathLive();
        if (!global.readAloudAudio) {
          global.readAloudAudio = new Audio();
          global.readAloudAudio.addEventListener("ended", () => {
            const mathfield = global.readAloudMathField;
            global.readAloudStatus = "ended";
            document.body.dispatchEvent(
              new Event("read-aloud-status-change", {
                bubbles: true,
                composed: true
              })
            );
            if (mathfield) {
              render(mathfield);
              global.readAloudElement = null;
              global.readAloudMathField = null;
              global.readAloudTokens = [];
              global.readAloudMarks = [];
              global.readAloudCurrentMark = "";
            } else
              removeHighlight(global.readAloudElement);
          });
          global.readAloudAudio.addEventListener("timeupdate", () => {
            let value = "";
            const target = global.readAloudAudio.currentTime * 1e3 + 100;
            for (const mark of global.readAloudMarks)
              if (mark.time < target)
                value = mark.value;
            if (global.readAloudCurrentMark !== value) {
              global.readAloudCurrentToken = value;
              if (value && value === global.readAloudFinalToken)
                global.readAloudAudio.pause();
              else {
                global.readAloudCurrentMark = value;
                highlightAtomID(
                  global.readAloudElement,
                  global.readAloudCurrentMark
                );
              }
            }
          });
        } else
          global.readAloudAudio.pause();
        global.readAloudAudio.src = url;
        global.readAloudStatus = "playing";
        document.body.dispatchEvent(
          new Event("read-aloud-status-change", {
            bubbles: true,
            composed: true
          })
        );
        global.readAloudAudio.play();
      });
    });
  }

  // src/public/mathfield-element.ts
  if (!isBrowser()) {
    console.error(
      `MathLive 0.91.2: this version of the MathLive library is for use in the browser. A subset of the API is available on the server side in the "mathlive-ssr" library. If using server side rendering (with React for example) you may want to do a dynamic import of the MathLive library inside a \`useEffect()\` call.`
    );
  }
  var MATHFIELD_TEMPLATE = isBrowser() ? document.createElement("template") : null;
  if (MATHFIELD_TEMPLATE) {
    MATHFIELD_TEMPLATE.innerHTML = `<style>
  :host { display: inline-block; background-color: field; color: fieldtext; border-width: 1px; border-style: solid; border-color: #acacac; border-radius: 2px; padding:4px; pointer-events: none;}
  :host([hidden]) { display: none; }
  :host([disabled]), :host([disabled]:focus), :host([disabled]:focus-within) { outline: none; opacity:  .5; }
  :host(:focus), :host(:focus-within) {
    outline: Highlight auto 1px;    /* For Firefox */
    outline: -webkit-focus-ring-color auto 1px;
  }
  </style>
  <span style="pointer-events:auto"></span><slot style="display:none"></slot>`;
  }
  var gDeferredState = /* @__PURE__ */ new WeakMap();
  var AUDIO_FEEDBACK_VOLUME = 0.5;
  var DEPRECATED_OPTIONS = {
    letterShapeStyle: "mf.letterShapeStyle = ...",
    horizontalSpacingScale: 'Removed. Use `"thinmuskip"`, `"medmuskip"`, and `"thickmuskip"` registers ',
    macros: "mf.macros = ...",
    registers: "mf.registers = ...",
    backgroundColorMap: "mf.backgroundColorMap = ...",
    colorMap: "mf.colorMap = ...",
    enablePopover: "mf.popoverPolicy = ...",
    mathModeSpace: "mf.mathModeSpace = ...",
    placeholderSymbol: "mf.placeholderSymbol = ...",
    readOnly: "mf.readOnly = ...",
    removeExtraneousParentheses: "mf.removeExtraneousParentheses = ...",
    scriptDepth: "mf.scriptDepth = ...",
    smartFence: "mf.smartFence = ...",
    smartMode: "mf.smartMode = ...",
    smartSuperscript: "mf.smartSuperscript = ...",
    inlineShortcutTimeout: "mf.inlineShortcutTimeout = ...",
    inlineShortcuts: "mf.inlineShortcuts = ...",
    keybindings: "mf.keybindings = ...",
    virtualKeyboardMode: "mf.mathVirtualKeyboardPolicy = ...",
    customVirtualKeyboardLayers: "mathVirtualKeyboard.layers = ...",
    customVirtualKeyboards: "mathVirtualKeyboard.layouts = ...",
    keypressSound: "mathVirtualKeyboard.keypressSound = ...",
    keypressVibration: "mathVirtualKeyboard.keypressVibration = ...",
    plonkSound: "mathVirtualKeyboard.plonkSound = ...",
    virtualKeyboardContainer: "mathVirtualKeyboard.container = ...",
    virtualKeyboardLayout: "mathVirtualKeyboard.alphabeticLayout = ...",
    virtualKeyboardTheme: "No longer supported",
    virtualKeyboardToggleGlyph: "No longer supported",
    virtualKeyboardToolbar: "mathVirtualKeyboard.editToolbar = ...",
    virtualKeyboards: "Use `mathVirtualKeyboard.layouts`",
    speechEngine: "`MathfieldElement.speechEngine`",
    speechEngineRate: "`MathfieldElement.speechEngineRate`",
    speechEngineVoice: "`MathfieldElement.speechEngineVoice`",
    textToSpeechMarkup: "`MathfieldElement.textToSpeechMarkup`",
    textToSpeechRules: "`MathfieldElement.textToSpeechRules`",
    textToSpeechRulesOptions: "`MathfieldElement.textToSpeechRulesOptions`",
    readAloudHook: "`MathfieldElement.readAloudHook`",
    speakHook: "`MathfieldElement.speakHook`",
    computeEngine: "`MathfieldElement.computeEngine`",
    fontsDirectory: "`MathfieldElement.fontsDirectory`",
    soundsDirectory: "`MathfieldElement.soundsDirectory`",
    createHTML: "`MathfieldElement.createHTML`",
    onExport: "`MathfieldElement.onExport`",
    onInlineShortcut: "`MathfieldElement.onInlineShortcut`",
    locale: "MathfieldElement.locale = ...",
    strings: "MathfieldElement.strings = ...",
    decimalSeparator: "MathfieldElement.decimalSeparator = ...",
    fractionNavigationOrder: "MathfieldElement.fractionNavigationOrder = ..."
  };
  var _MathfieldElement = class extends HTMLElement {
    /**
         * To create programmatically a new mathfield use:
         *
         ```javascript
        let mfe = new MathfieldElement();
    
        // Set initial value and options
        mfe.value = "\\frac{\\sin(x)}{\\cos(x)}";
    
        // Options can be set either as an attribute (for simple options)...
        mfe.setAttribute("letter-shape-style", "french");
    
        // ... or using properties
        mfe.letterShapeStyle = "french";
    
        // Attach the element to the DOM
        document.body.appendChild(mfe);
        ```
        */
    constructor(options) {
      super();
      if (options) {
        const warnings = [];
        for (const key of Object.keys(options)) {
          if (DEPRECATED_OPTIONS[key]) {
            if (DEPRECATED_OPTIONS[key].startsWith("mf.")) {
              if (!DEPRECATED_OPTIONS[key].startsWith(`mf.${key}`)) {
                const newName = DEPRECATED_OPTIONS[key].match(/([a-zA-Z]+) =/);
                warnings.push(
                  `Option \`${key}\` has been renamed \`${newName[1]}\``
                );
              } else {
                warnings.push(
                  `Option \`${key}\` cannot be used as a constructor option. Use ${DEPRECATED_OPTIONS[key]}`
                );
              }
            } else {
              warnings.push(
                `Option \`${key}\` cannot be used as a constructor option. Use ${DEPRECATED_OPTIONS[key]}`
              );
            }
          } else
            warnings.push(`Unexpected option \`${key}\``);
        }
        if (warnings.length > 0) {
          console.group(
            `%cMathLive 0.91.2: %cInvalid Options`,
            "color:#12b; font-size: 1.1rem",
            "color:#db1111; font-size: 1.1rem"
          );
          console.warn(
            `Some of the options passed to \`new MathFieldElement(...)\` are invalid. 
          See https://cortexjs.io/mathlive/changelog/ for details.`
          );
          for (const warning of warnings)
            console.warn(warning);
          console.groupEnd();
        }
      }
      if (isElementInternalsSupported()) {
        this._internals = this.attachInternals();
        this._internals["role"] = "math";
        this._internals.ariaLabel = "math input field";
        this._internals.ariaMultiLine = "false";
      }
      this.attachShadow({ mode: "open", delegatesFocus: true });
      this.shadowRoot.append(MATHFIELD_TEMPLATE.content.cloneNode(true));
      const slot = this.shadowRoot.querySelector("slot:not([name])");
      this._slotValue = slot.assignedNodes().map((x) => x.nodeType === 3 ? x.textContent : "").join("").trim();
      if (options)
        this._setOptions(options);
    }
    static get formAssociated() {
      return isElementInternalsSupported();
    }
    /**
     * Private lifecycle hooks
     * @internal
     */
    static get optionsAttributes() {
      return {
        "default-mode": "string",
        "letter-shape-style": "string",
        "popover-policy": "string",
        "math-mode-space": "string",
        "read-only": "boolean",
        "remove-extraneous-parentheses": "on/off",
        "smart-fence": "on/off",
        "smart-mode": "on/off",
        "smart-superscript": "on/off",
        "inline-shortcut-timeout": "string",
        "script-depth": "string",
        "virtual-keyboard-target-origin": "string",
        "math-virtual-keyboard-policy": "string"
      };
    }
    /**
     * Custom elements lifecycle hooks
     * @internal
     */
    static get observedAttributes() {
      return [
        ...Object.keys(this.optionsAttributes),
        "contenteditable",
        // Global attribute
        "disabled",
        // Global attribute
        "readonly",
        // A semi-global attribute (not all standard elements support it, but some do)
        "read-only"
        // Alternate spelling for `readonly`
      ];
    }
    /**
     * A URL fragment pointing to the directory containing the fonts
     * necessary to render a formula.
     *
     * These fonts are available in the `/dist/fonts` directory of the SDK.
     *
     * Customize this value to reflect where you have copied these fonts,
     * or to use the CDN version.
     *
     * The default value is `"./fonts"`. Use `null` to prevent
     * any fonts from being loaded.
     *
     * Changing this setting after the mathfield has been created will have
     * no effect.
     *
     * ```javascript
     * {
     *      // Use the CDN version
     *      fontsDirectory: ''
     * }
     * ```
     *
     * ```javascript
     * {
     *      // Use a directory called "fonts", located next to the
     *      // `mathlive.js` (or `mathlive.mjs`) file.
     *      fontsDirectory: './fonts'
     * }
     * ```
     *
     * ```javascript
     * {
     *      // Use a directory located at the root of your website
     *      fontsDirectory: 'https://example.com/fonts'
     * }
     * ```
     *
     */
    static get fontsDirectory() {
      return this._fontsDirectory;
    }
    static set fontsDirectory(value) {
      this._fontsDirectory = value;
      reloadFonts();
    }
    /**
     * A URL fragment pointing to the directory containing the optional
     * sounds used to provide feedback while typing.
     *
     * Some default sounds are available in the `/dist/sounds` directory of the SDK.
     *
     * Use `null` to prevent any sound from being loaded.
     *
     */
    static get soundsDirectory() {
      return this._soundsDirectory;
    }
    static set soundsDirectory(value) {
      this._soundsDirectory = value;
      this.audioBuffers = {};
    }
    /**
     * When a key on the virtual keyboard is pressed, produce a short audio
     * feedback.
     *
     * If the property is set to a `string`, the same sound is played in all
     * cases. Otherwise, a distinct sound is played:
     *
     * -   `delete` a sound played when the delete key is pressed
     * -   `return` ... when the return/tab key is pressed
     * -   `spacebar` ... when the spacebar is pressed
     * -   `default` ... when any other key is pressed. This property is required,
     *     the others are optional. If they are missing, this sound is played as
     *     well.
     *
     * The value of the properties should be either a string, the name of an
     * audio file in the `soundsDirectory` directory or `null` to suppress the sound.
     */
    static get keypressSound() {
      return this._keypressSound;
    }
    static set keypressSound(value) {
      var _a3, _b3, _c2;
      this.audioBuffers = {};
      if (value === null) {
        this._keypressSound = {
          spacebar: null,
          return: null,
          delete: null,
          default: null
        };
      } else if (typeof value === "string") {
        this._keypressSound = {
          spacebar: value,
          return: value,
          delete: value,
          default: value
        };
      } else if (typeof value === "object" && "default" in value) {
        this._keypressSound = {
          spacebar: (_a3 = value.spacebar) != null ? _a3 : value.default,
          return: (_b3 = value.return) != null ? _b3 : value.default,
          delete: (_c2 = value.delete) != null ? _c2 : value.default,
          default: value.default
        };
      }
    }
    static get plonkSound() {
      return this._plonkSound;
    }
    static set plonkSound(value) {
      this.audioBuffers = {};
      this._plonkSound = value;
    }
    static get audioContext() {
      if (!this._audioContext)
        this._audioContext = new AudioContext();
      return this._audioContext;
    }
    // @todo https://github.com/microsoft/TypeScript/issues/30024
    /**
     * Indicates which speech engine to use for speech output.
     *
     * Use `local` to use the OS-specific TTS engine.
     *
     * Use `amazon` for Amazon Text-to-Speech cloud API. You must include the
     * AWS API library and configure it with your API key before use.
     *
     * **See**
     * {@link https://cortexjs.io/mathlive/guides/speech/ | Guide: Speech}
     */
    static get speechEngine() {
      return this._speechEngine;
    }
    static set speechEngine(value) {
      this._speechEngine = value;
    }
    /**
     * Sets the speed of the selected voice.
     *
     * One of `x-slow`, `slow`, `medium`, `fast`, `x-fast` or a value as a
     * percentage.
     *
     * Range is `20%` to `200%` For example `200%` to indicate a speaking rate
     * twice the default rate.
     */
    static get speechEngineRate() {
      return this._speechEngineRate;
    }
    static set speechEngineRate(value) {
      this._speechEngineRate = value;
    }
    /**
     * Indicates the voice to use with the speech engine.
     *
     * This is dependent on the speech engine. For Amazon Polly, see here:
     * https://docs.aws.amazon.com/polly/latest/dg/voicelist.html
     *
     */
    static get speechEngineVoice() {
      return this._speechEngineVoice;
    }
    static set speechEngineVoice(value) {
      this._speechEngineVoice = value;
    }
    /**
     * The markup syntax to use for the output of conversion to spoken text.
     *
     * Possible values are `ssml` for the SSML markup or `mac` for the macOS
     * markup, i.e. `&#91;&#91;ltr&#93;&#93;`.
     *
     */
    static get textToSpeechMarkup() {
      return this._textToSpeechMarkup;
    }
    static set textToSpeechMarkup(value) {
      this._textToSpeechMarkup = value;
    }
    /**
     * Specify which set of text to speech rules to use.
     *
     * A value of `mathlive` indicates that the simple rules built into MathLive
     * should be used.
     *
     * A value of `sre` indicates that the Speech Rule Engine from Volker Sorge
     * should be used.
     *
     * **(Caution)** SRE is not included or loaded by MathLive. For this option to
     * work SRE should be loaded separately.
     *
     * **See**
     * {@link https://cortexjs.io/mathlive/guides/speech/ | Guide: Speech}
     */
    static get textToSpeechRules() {
      return this._textToSpeechRules;
    }
    static set textToSpeechRules(value) {
      this._textToSpeechRules = value;
    }
    /**
     * A set of key/value pairs that can be used to configure the speech rule
     * engine.
     *
     * Which options are available depends on the speech rule engine in use.
     * There are no options available with MathLive's built-in engine. The
     * options for the SRE engine are documented
     * {@link https://github.com/zorkow/speech-rule-engine | here}
     */
    static get textToSpeechRulesOptions() {
      return this._textToSpeechRulesOptions;
    }
    static set textToSpeechRulesOptions(value) {
      this._textToSpeechRulesOptions = value;
    }
    /**
     * The locale (language + region) to use for string localization.
     *
     * If none is provided, the locale of the browser is used.
     *
     */
    static get locale() {
      return l10n.locale;
    }
    static set locale(value) {
      if (value === "auto")
        value = navigator.language.slice(0, 5);
      l10n.locale = value;
    }
    /**
     * The symbol used to separate the integer part from the fractional part of a
     * number.
     *
     * When `","` is used, the corresponding LaTeX string is `{,}`, in order
     * to ensure proper spacing (otherwise an extra gap is displayed after the
     * comma).
     *
     * This affects:
     * - what happens when the `,` key is pressed (if `decimalSeparator` is
     * `","`, the `{,}` LaTeX string is inserted when following some digits)
     * - the label and behavior of the "." key in the default virtual keyboard
     *
     * **Default**: `"."`
     */
    static get decimalSeparator() {
      return this._decimalSeparator;
    }
    static set decimalSeparator(value) {
      this._decimalSeparator = value;
      if (this._computeEngine) {
        this._computeEngine.latexOptions.decimalMarker = this.decimalSeparator === "," ? "{,}" : ".";
      }
    }
    /**
    * An object whose keys are a locale string, and whose values are an object of
    * string identifier to localized string.
    *
    * **Example**
    *
    ```json
    {
      "fr-CA": {
          "tooltip.undo": "Annuler",
          "tooltip.redo": "Refaire",
      }
    }
    ```
    *
    * This will override the default localized strings.
    */
    static get strings() {
      return l10n.strings;
    }
    static set strings(value) {
      l10n.merge(value);
    }
    /**
     * A custom compute engine instance. If none is provided, a default one is
     * used. If `null` is specified, no compute engine is used.
     */
    static get computeEngine() {
      var _a3, _b3;
      if (this._computeEngine === void 0) {
        const ComputeEngineCtor = (_a3 = window[Symbol.for("io.cortexjs.compute-engine")]) == null ? void 0 : _a3.ComputeEngine;
        if (ComputeEngineCtor)
          this._computeEngine = new ComputeEngineCtor();
        else {
          console.error(
            `MathLive 0.91.2: The CortexJS Compute Engine library is not available.
          
          Load the library, for example with:
          
          import "https://unpkg.com/@cortex-js/compute-engine?module"`
          );
        }
        if (this._computeEngine && this.decimalSeparator === ",")
          this._computeEngine.latexOptions.decimalMarker = "{,}";
      }
      return (_b3 = this._computeEngine) != null ? _b3 : null;
    }
    static set computeEngine(value) {
      this._computeEngine = value;
    }
    static async loadSound(sound) {
      delete this.audioBuffers[sound];
      let soundFile = "";
      switch (sound) {
        case "keypress":
          soundFile = this._keypressSound.default;
          break;
        case "return":
          soundFile = this._keypressSound.return;
          break;
        case "spacebar":
          soundFile = this._keypressSound.spacebar;
          break;
        case "delete":
          soundFile = this._keypressSound.delete;
          break;
        case "plonk":
          soundFile = this.plonkSound;
          break;
      }
      if (typeof soundFile !== "string")
        return;
      soundFile = soundFile.trim();
      const soundsDirectory = this.soundsDirectory;
      if (soundsDirectory === void 0 || soundsDirectory === null || soundsDirectory === "null" || soundFile === "none" || soundFile === "null")
        return;
      const response = await fetch(
        await resolveUrl(`${soundsDirectory}/${soundFile}`)
      );
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
      this.audioBuffers[sound] = audioBuffer;
    }
    static async playSound(name) {
      if (!this.audioBuffers[name])
        await this.loadSound(name);
      if (!this.audioBuffers[name])
        return;
      const soundSource = this.audioContext.createBufferSource();
      soundSource.buffer = this.audioBuffers[name];
      const gainNode = this.audioContext.createGain();
      gainNode.gain.value = AUDIO_FEEDBACK_VOLUME;
      soundSource.connect(gainNode).connect(this.audioContext.destination);
      soundSource.start();
    }
    onPointerDown() {
      window.addEventListener(
        "pointerup",
        (evt) => {
          var _a3;
          if (evt.target === this && !((_a3 = this._mathfield) == null ? void 0 : _a3.disabled)) {
            this.dispatchEvent(
              new MouseEvent("click", {
                altKey: evt.altKey,
                button: evt.button,
                buttons: evt.buttons,
                clientX: evt.clientX,
                clientY: evt.clientY,
                ctrlKey: evt.ctrlKey,
                metaKey: evt.metaKey,
                movementX: evt.movementX,
                movementY: evt.movementY,
                relatedTarget: evt.relatedTarget,
                screenX: evt.screenX,
                screenY: evt.screenY,
                shiftKey: evt.shiftKey
              })
            );
          }
        },
        { once: true }
      );
    }
    getPromptValue(placeholderId) {
      var _a3, _b3;
      return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.getPromptValue(placeholderId)) != null ? _b3 : "";
    }
    /** Return the id of the prompts matching the filter */
    getPrompts(filter) {
      var _a3, _b3;
      return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.getPrompts(filter)) != null ? _b3 : [];
    }
    addEventListener(type, listener, options) {
      return super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
    }
    get form() {
      var _a3;
      return (_a3 = this._internals) == null ? void 0 : _a3["form"];
    }
    get name() {
      var _a3;
      return (_a3 = this.getAttribute("name")) != null ? _a3 : "";
    }
    get type() {
      return this.localName;
    }
    get mode() {
      var _a3, _b3;
      return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.mode) != null ? _b3 : "math";
    }
    set mode(value) {
      if (!this._mathfield)
        return;
      this._mathfield.mode = value;
    }
    /**
       * If the Compute Engine library is available, return a boxed MathJSON expression representing the value of the mathfield.
       *
       * To load the Compute Engine library, use:
       * ```js
    import 'https://unpkg.com/@cortex-js/compute-engine?module';
    ```
       *
       */
    get expression() {
      if (!this._mathfield)
        return void 0;
      if (!window[Symbol.for("io.cortexjs.compute-engine")]) {
        console.error(
          `MathLive 0.91.2: The CortexJS Compute Engine library is not available.
        
        Load the library, for example with:
        
        import "https://unpkg.com/@cortex-js/compute-engine?module"`
        );
      }
      return this._mathfield.expression;
    }
    set expression(mathJson) {
      var _a3, _b3;
      if (!this._mathfield)
        return;
      const latex = (_b3 = (_a3 = _MathfieldElement.computeEngine) == null ? void 0 : _a3.box(mathJson).latex) != null ? _b3 : null;
      if (latex !== null)
        this._mathfield.setValue(latex);
      if (!window[Symbol.for("io.cortexjs.compute-engine")]) {
        console.error(
          `MathLive 0.91.2: The CortexJS Compute Engine library is not available.
        
        Load the library, for example with:
        
        import "https://unpkg.com/@cortex-js/compute-engine?module"`
        );
      }
    }
    get errors() {
      var _a3, _b3;
      return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.errors) != null ? _b3 : [];
    }
    _getOptions(keys) {
      if (this._mathfield)
        return get(this._mathfield.options, keys);
      if (!gDeferredState.has(this))
        return null;
      return get(
        update(getDefault(), gDeferredState.get(this).options),
        keys
      );
    }
    getOptions(keys) {
      console.warn(
        `%cMathLive 0.91.2: %cDeprecated Usage%c
      \`mf.getOptions()\` is deprecated. Read the property directly on the mathfield instead.
      See https://cortexjs.io/mathlive/changelog/ for details.`,
        "color:#12b; font-size: 1.1rem",
        "color:#db1111; font-size: 1.1rem",
        "color: inherit, font-size: 1rem"
      );
      if (this._mathfield)
        return get(this._mathfield.options, keys);
      if (!gDeferredState.has(this))
        return null;
      return get(
        update(getDefault(), gDeferredState.get(this).options),
        keys
      );
    }
    /** @internal */
    reflectAttributes() {
      const defaultOptions = getDefault();
      const options = this._getOptions();
      Object.keys(_MathfieldElement.optionsAttributes).forEach((x) => {
        const prop = toCamelCase(x);
        if (_MathfieldElement.optionsAttributes[x] === "on/off") {
          if (defaultOptions[prop] !== options[prop])
            this.setAttribute(x, options[prop] ? "on" : "off");
          else
            this.removeAttribute(x);
        } else if (defaultOptions[prop] !== options[prop]) {
          if (_MathfieldElement.optionsAttributes[x] === "boolean") {
            if (options[prop]) {
              this.setAttribute(x, "");
            } else {
              this.removeAttribute(x);
            }
          } else {
            if (typeof options[prop] === "string" || typeof options[prop] === "number")
              this.setAttribute(x, options[prop].toString());
          }
        }
      });
    }
    /**
     *  @category Options
     * @deprecated
     */
    getOption(key) {
      console.warn(
        `%cMathLive 0.91.2: %cDeprecated Usage%c
      \`mf.getOption()\` is deprecated. Read the property directly on the mathfield instead.
      See https://cortexjs.io/mathlive/changelog/ for details.`,
        "color:#12b; font-size: 1.1rem",
        "color:#db1111; font-size: 1.1rem",
        "color: inherit, font-size: 1rem"
      );
      return this._getOptions([key])[key];
    }
    /** @internal */
    _getOption(key) {
      return this._getOptions([key])[key];
    }
    /** @internal */
    _setOptions(options) {
      if (this._mathfield)
        this._mathfield.setOptions(options);
      else if (gDeferredState.has(this)) {
        const mergedOptions = __spreadValues(__spreadValues({}, gDeferredState.get(this).options), options);
        gDeferredState.set(this, __spreadProps(__spreadValues({}, gDeferredState.get(this)), {
          selection: { ranges: mergedOptions.readOnly ? [[0, 0]] : [[0, -1]] },
          options: mergedOptions
        }));
      } else {
        gDeferredState.set(this, {
          value: void 0,
          selection: { ranges: [[0, 0]] },
          options
        });
      }
      this.reflectAttributes();
    }
    /**
     *  @category Options
     * @deprecated
     */
    setOptions(options) {
      console.group(
        `%cMathLive 0.91.2: %cDeprecated Usage`,
        "color:#12b; font-size: 1.1rem",
        "color:#db1111; font-size: 1.1rem"
      );
      console.warn(
        ` \`mf.setOptions()\` is deprecated. Set the property directly on the mathfield instead.
      See https://cortexjs.io/mathlive/changelog/ for details.`
      );
      for (const key of Object.keys(options)) {
        if (DEPRECATED_OPTIONS[key]) {
          console.warn(
            `\`mf.setOptions({${key}:...})\` -> ${DEPRECATED_OPTIONS[key]}`
          );
        }
      }
      console.groupEnd();
      this._setOptions(options);
    }
    /**
     * @inheritdoc Mathfield.executeCommand
     */
    executeCommand(command) {
      var _a3, _b3;
      return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.executeCommand(command)) != null ? _b3 : false;
    }
    getValue(arg1, arg2, arg3) {
      var _a3, _b3;
      if (this._mathfield)
        return this._mathfield.model.getValue(arg1, arg2, arg3);
      if (gDeferredState.has(this)) {
        let start;
        let end;
        let format = void 0;
        if (isSelection(arg1)) {
          [start, end] = arg1.ranges[0];
          format = arg2;
        } else if (isRange(arg1)) {
          [start, end] = arg1;
          format = arg2;
        } else if (isOffset(arg1) && isOffset(arg2)) {
          start = arg1;
          end = arg2;
          format = arg3;
        } else {
          start = 0;
          end = -1;
          format = arg1;
        }
        if ((format === void 0 || format === "latex") && start === 0 && end === -1)
          return (_b3 = (_a3 = gDeferredState.get(this).value) != null ? _a3 : this.textContent) != null ? _b3 : "";
      }
      return "";
    }
    /**
     * @inheritdoc Mathfield.setValue
     * @category Accessing and changing the content
     */
    setValue(value, options) {
      if (this._mathfield && value !== void 0) {
        if (!options)
          options = { suppressChangeNotifications: true };
        this._mathfield.setValue(value, options);
        return;
      }
      if (gDeferredState.has(this)) {
        const options2 = gDeferredState.get(this).options;
        gDeferredState.set(this, {
          value,
          selection: {
            ranges: options2.readOnly ? [[0, 0]] : [[0, -1]],
            direction: "forward"
          },
          options: options2
        });
        return;
      }
      const attrOptions = getOptionsFromAttributes(this);
      gDeferredState.set(this, {
        value,
        selection: {
          ranges: attrOptions.readOnly ? [[0, 0]] : [[0, -1]],
          direction: "forward"
        },
        options: attrOptions
      });
    }
    /**
     * @inheritdoc Mathfield.hasFocus
     *
     * @category Focus
     *
     */
    hasFocus() {
      var _a3, _b3;
      return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.hasFocus()) != null ? _b3 : false;
    }
    /**
     * Sets the focus to the mathfield (will respond to keyboard input).
     *
     * @category Focus
     *
     */
    focus() {
      var _a3;
      (_a3 = this._mathfield) == null ? void 0 : _a3.focus();
    }
    /**
     * Remove the focus from the mathfield (will no longer respond to keyboard
     * input).
     *
     * @category Focus
     *
     */
    blur() {
      var _a3;
      (_a3 = this._mathfield) == null ? void 0 : _a3.blur();
    }
    /**
     * Select the content of the mathfield.
     * @category Selection
     */
    select() {
      var _a3;
      (_a3 = this._mathfield) == null ? void 0 : _a3.select();
    }
    /**
       * @inheritdoc Mathfield.insert
    
       *  @category Accessing and changing the content
       */
    insert(s, options) {
      var _a3, _b3;
      return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.insert(s, options)) != null ? _b3 : false;
    }
    /**
     * @inheritdoc Mathfield.applyStyle
     *
     * @category Accessing and changing the content
     */
    applyStyle(style, options) {
      var _a3;
      return (_a3 = this._mathfield) == null ? void 0 : _a3.applyStyle(style, options);
    }
    /**
     * The bottom location of the caret (insertion point) in viewport
     * coordinates.
     *
     * @category Selection
     */
    get caretPoint() {
      var _a3, _b3;
      return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.getCaretPoint()) != null ? _b3 : null;
    }
    set caretPoint(point) {
      var _a3;
      if (!point)
        return;
      (_a3 = this._mathfield) == null ? void 0 : _a3.setCaretPoint(point.x, point.y);
    }
    /**
     * `x` and `y` are in viewport coordinates.
     *
     * Return true if the location of the point is a valid caret location.
     *
     * See also [[`caretPoint`]]
     * @category Selection
     */
    setCaretPoint(x, y) {
      var _a3, _b3;
      return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.setCaretPoint(x, y)) != null ? _b3 : false;
    }
    /** The offset closest to the location `(x, y)` in viewport coordinate.
     *
     * **`bias`**:  if `0`, the vertical midline is considered to the left or
     * right sibling. If `-1`, the left sibling is favored, if `+1`, the right
     * sibling is favored.
     *
     * @category Selection
     */
    offsetFromPoint(x, y, options) {
      if (!this._mathfield)
        return -1;
      return offsetFromPoint(this._mathfield, x, y, options);
    }
    /** The bounding rect of the atom at offset
     *
     * @category Selection
     *
     */
    hitboxFromOffset(offset) {
      if (!this._mathfield)
        return null;
      const atom = this._mathfield.model.at(offset);
      if (!atom)
        return null;
      const bounds = getAtomBounds(this._mathfield, atom);
      if (!bounds)
        return null;
      return new DOMRect(
        bounds.left,
        bounds.top,
        bounds.right - bounds.left,
        bounds.bottom - bounds.top
      );
    }
    /**
     * Reset the undo stack
     * (for parent components with their own undo/redo)
     */
    resetUndo() {
      var _a3;
      (_a3 = this._mathfield) == null ? void 0 : _a3.resetUndo();
    }
    /**
     * Return whether there are undoable items
     * (for parent components with their own undo/redo)
     */
    canUndo() {
      if (!this._mathfield)
        return false;
      return this._mathfield.canUndo();
    }
    /**
     * Return whether there are redoable items
     * (for parent components with their own undo/redo)
     */
    canRedo() {
      if (!this._mathfield)
        return false;
      return this._mathfield.canRedo();
    }
    /**
     * Custom elements lifecycle hooks
     * @internal
     */
    connectedCallback() {
      var _a3, _b3, _c2;
      requestAnimationFrame(() => void loadFonts());
      this.shadowRoot.host.addEventListener(
        "pointerdown",
        () => this.onPointerDown(),
        true
      );
      this.shadowRoot.host.addEventListener(
        "focus",
        () => {
          var _a4;
          return (_a4 = this._mathfield) == null ? void 0 : _a4.focus();
        },
        true
      );
      this.shadowRoot.host.addEventListener(
        "blur",
        () => {
          var _a4;
          return (_a4 = this._mathfield) == null ? void 0 : _a4.blur();
        },
        true
      );
      if (!isElementInternalsSupported()) {
        if (!this.hasAttribute("role"))
          this.setAttribute("role", "math");
        if (!this.hasAttribute("aria-label"))
          this.setAttribute("aria-label", "math input field");
        this.setAttribute("aria-multiline", "false");
      }
      if (!this.hasAttribute("contenteditable"))
        this.setAttribute("contenteditable", "true");
      if (!this.hasAttribute("tabindex"))
        this.setAttribute("tabindex", "0");
      const slot = this.shadowRoot.querySelector("slot:not([name])");
      let value = "";
      if (this.hasAttribute("value"))
        value = (_a3 = this.getAttribute("value")) != null ? _a3 : "";
      else {
        value = (_b3 = slot == null ? void 0 : slot.assignedNodes().map((x) => x.nodeType === 3 ? x.textContent : "").join("").trim()) != null ? _b3 : "";
      }
      this._mathfield = new MathfieldPrivate(
        this.shadowRoot.querySelector(":host > span"),
        __spreadProps(__spreadValues({}, gDeferredState.has(this) ? gDeferredState.get(this).options : getOptionsFromAttributes(this)), {
          eventSink: this,
          value
        })
      );
      if (!gDeferredState.has(this)) {
        this.upgradeProperty("disabled");
        this.upgradeProperty("readonly");
        for (const attr of Object.keys(_MathfieldElement.optionsAttributes))
          this.upgradeProperty(toCamelCase(attr));
      }
      if (!((_c2 = this._mathfield) == null ? void 0 : _c2.model)) {
        this._mathfield = null;
        return;
      }
      if (gDeferredState.has(this)) {
        this._mathfield.model.deferNotifications(
          { content: false, selection: false },
          () => {
            const value2 = gDeferredState.get(this).value;
            if (value2 !== void 0)
              this._mathfield.setValue(value2);
            this._mathfield.model.selection = gDeferredState.get(this).selection;
            gDeferredState.delete(this);
          }
        );
      }
      slot.addEventListener("slotchange", (event) => {
        if (event.target !== slot)
          return;
        const value2 = slot.assignedNodes().map((x) => x.nodeType === 3 ? x.textContent : "").join("").trim();
        if (value2 === this._slotValue)
          return;
        if (!this._mathfield)
          this.value = value2;
        else {
          this._mathfield.setValue(value2);
        }
      });
      this.dispatchEvent(
        new Event("mount", { cancelable: false, bubbles: true, composed: true })
      );
    }
    /**
     * Custom elements lifecycle hooks
     * @internal
     */
    disconnectedCallback() {
      this.dispatchEvent(
        new Event("unmount", { cancelable: false, bubbles: true, composed: true })
      );
      if (!this._mathfield)
        return;
      const options = get(
        this._mathfield.options,
        Object.keys(_MathfieldElement.optionsAttributes).map((x) => toCamelCase(x))
      );
      gDeferredState.set(this, {
        value: this._mathfield.getValue(),
        selection: this._mathfield.model.selection,
        options
      });
      this._mathfield.dispose();
      this._mathfield = null;
    }
    /**
     * Private lifecycle hooks
     * @internal
     */
    upgradeProperty(prop) {
      if (this.hasOwnProperty(prop)) {
        const value = this[prop];
        delete this[prop];
        if (prop === "readonly" || prop === "read-only")
          prop = "readOnly";
        this[prop] = value;
      }
    }
    /**
     * Custom elements lifecycle hooks
     * @internal
     */
    attributeChangedCallback(name, oldValue, newValue) {
      if (oldValue === newValue)
        return;
      const hasValue = newValue !== null;
      switch (name) {
        case "contenteditable":
          if (this._mathfield)
            requestUpdate(this._mathfield);
          break;
        case "disabled":
          this.disabled = hasValue;
          break;
        case "read-only":
        case "readonly":
          this.readOnly = hasValue;
          break;
        default:
      }
    }
    get readonly() {
      return this.hasAttribute("readonly") || this.hasAttribute("read-only");
    }
    set readonly(value) {
      const isReadonly = Boolean(value);
      if (isReadonly) {
        this.setAttribute("readonly", "");
        if (isElementInternalsSupported())
          this._internals.ariaReadOnly = "true";
        else
          this.setAttribute("aria-readonly", "true");
        this.setAttribute("aria-readonly", "true");
      } else {
        if (isElementInternalsSupported())
          this._internals.ariaReadOnly = "false";
        else
          this.removeAttribute("aria-readonly");
        this.removeAttribute("readonly");
        this.removeAttribute("read-only");
      }
      this._setOptions({ readOnly: isReadonly });
    }
    get disabled() {
      return this.hasAttribute("disabled");
    }
    set disabled(value) {
      var _a3;
      const isDisabled = Boolean(value);
      if (isDisabled)
        this.setAttribute("disabled", "");
      else
        this.removeAttribute("disabled");
      if (isElementInternalsSupported())
        this._internals.ariaDisabled = isDisabled ? "true" : "false";
      else
        this.setAttribute("aria-disabled", isDisabled ? "true" : "false");
      if (isDisabled && ((_a3 = this._mathfield) == null ? void 0 : _a3.hasFocus) && window.mathVirtualKeyboard.visible)
        this._mathfield.executeCommand("hideVirtualKeyboard");
    }
    /**
     * The content of the mathfield as a LaTeX expression.
     * ```js
     * document.querySelector('mf').value = '\\frac{1}{\\pi}'
     * ```
     *  @category Accessing and changing the content
     */
    get value() {
      return this.getValue();
    }
    /**
     *  @category Accessing and changing the content
     */
    set value(value) {
      this.setValue(value);
    }
    get defaultMode() {
      return this._getOption("defaultMode");
    }
    set defaultMode(value) {
      this._setOptions({ defaultMode: value });
    }
    get macros() {
      return this._getOption("macros");
    }
    set macros(value) {
      this._setOptions({ macros: value });
    }
    get registers() {
      return this._getOption("registers");
    }
    set registers(value) {
      this._setOptions({ registers: value });
    }
    get colorMap() {
      return this._getOption("colorMap");
    }
    set colorMap(value) {
      this._setOptions({ colorMap: value });
    }
    get backgroundColorMap() {
      return this._getOption("backgroundColorMap");
    }
    set backgroundColorMap(value) {
      this._setOptions({ backgroundColorMap: value });
    }
    get letterShapeStyle() {
      return this._getOption("letterShapeStyle");
    }
    set letterShapeStyle(value) {
      this._setOptions({ letterShapeStyle: value });
    }
    get smartMode() {
      return this._getOption("smartMode");
    }
    set smartMode(value) {
      this._setOptions({ smartMode: value });
    }
    get smartFence() {
      return this._getOption("smartFence");
    }
    set smartFence(value) {
      this._setOptions({ smartFence: value });
    }
    get smartSuperscript() {
      return this._getOption("smartSuperscript");
    }
    set smartSuperscript(value) {
      this._setOptions({ smartSuperscript: value });
    }
    get scriptDepth() {
      return this._getOption("scriptDepth");
    }
    set scriptDepth(value) {
      this._setOptions({ scriptDepth: value });
    }
    get removeExtraneousParentheses() {
      return this._getOption("removeExtraneousParentheses");
    }
    set removeExtraneousParentheses(value) {
      this._setOptions({ removeExtraneousParentheses: value });
    }
    get mathModeSpace() {
      return this._getOption("mathModeSpace");
    }
    set mathModeSpace(value) {
      this._setOptions({ mathModeSpace: value });
    }
    get placeholderSymbol() {
      return this._getOption("placeholderSymbol");
    }
    set placeholderSymbol(value) {
      this._setOptions({ placeholderSymbol: value });
    }
    get popoverPolicy() {
      return this._getOption("popoverPolicy");
    }
    set popoverPolicy(value) {
      this._setOptions({ popoverPolicy: value });
    }
    get mathVirtualKeyboardPolicy() {
      return this._getOption("mathVirtualKeyboardPolicy");
    }
    set mathVirtualKeyboardPolicy(value) {
      this._setOptions({ mathVirtualKeyboardPolicy: value });
    }
    get inlineShortcuts() {
      return this._getOption("inlineShortcuts");
    }
    set inlineShortcuts(value) {
      this._setOptions({ inlineShortcuts: value });
    }
    get inlineShortcutTimeout() {
      return this._getOption("inlineShortcutTimeout");
    }
    set inlineShortcutTimeout(value) {
      this._setOptions({ inlineShortcutTimeout: value });
    }
    get keybindings() {
      return this._getOption("keybindings");
    }
    set keybindings(value) {
      this._setOptions({ keybindings: value });
    }
    get onInlineShortcut() {
      return this._getOption("onInlineShortcut");
    }
    set onInlineShortcut(value) {
      this._setOptions({ onInlineShortcut: value });
    }
    get onExport() {
      return this._getOption("onExport");
    }
    set onExport(value) {
      this._setOptions({ onExport: value });
    }
    get readOnly() {
      return this._getOption("readOnly");
    }
    set readOnly(value) {
      this._setOptions({ readOnly: value });
    }
    setPromptState(id, state, locked) {
      var _a3;
      (_a3 = this._mathfield) == null ? void 0 : _a3.setPromptState(id, state, locked);
    }
    getPromptState(id) {
      var _a3, _b3;
      return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.getPromptState(id)) != null ? _b3 : [void 0, true];
    }
    setPromptContent(id, content, insertOptions) {
      var _a3;
      (_a3 = this._mathfield) == null ? void 0 : _a3.setPromptValue(id, content, insertOptions);
    }
    get virtualKeyboardTargetOrigin() {
      return this._getOption("virtualKeyboardTargetOrigin");
    }
    set virtualKeyboardTargetOrigin(value) {
      this._setOptions({ virtualKeyboardTargetOrigin: value });
    }
    /**
     * An array of ranges representing the selection.
     *
     * It is guaranteed there will be at least one element. If a discontinuous
     * selection is present, the result will include more than one element.
     *
     * @category Selection
     *
     */
    get selection() {
      if (this._mathfield)
        return this._mathfield.model.selection;
      if (gDeferredState.has(this))
        return gDeferredState.get(this).selection;
      return { ranges: [[0, 0]], direction: "forward" };
    }
    /**
     *
     * @category Selection
     */
    set selection(sel) {
      if (typeof sel === "number")
        sel = { ranges: [[sel, sel]] };
      if (this._mathfield) {
        this._mathfield.model.selection = sel;
        return;
      }
      if (gDeferredState.has(this)) {
        gDeferredState.set(this, __spreadProps(__spreadValues({}, gDeferredState.get(this)), {
          selection: sel
        }));
        return;
      }
      gDeferredState.set(this, {
        value: void 0,
        selection: sel,
        options: getOptionsFromAttributes(this)
      });
    }
    get selectionIsCollapsed() {
      const selection = this.selection;
      return selection.ranges.length === 1 && selection.ranges[0][0] === selection.ranges[0][1];
    }
    /**
     * The position of the caret/insertion point, from 0 to `lastOffset`.
     *
     * @category Selection
     *
     */
    get position() {
      if (this._mathfield)
        return this._mathfield.model.position;
      if (gDeferredState.has(this))
        return gDeferredState.get(this).selection.ranges[0][0];
      return 0;
    }
    /**
     * @category Selection
     */
    set position(offset) {
      if (this._mathfield)
        this._mathfield.model.position = offset;
      if (gDeferredState.has(this)) {
        gDeferredState.set(this, __spreadProps(__spreadValues({}, gDeferredState.get(this)), {
          selection: { ranges: [[offset, offset]] }
        }));
        return;
      }
      gDeferredState.set(this, {
        value: void 0,
        selection: { ranges: [[offset, offset]] },
        options: getOptionsFromAttributes(this)
      });
    }
    /**
     * The depth of an offset represent the depth in the expression tree.
     */
    getOffsetDepth(offset) {
      var _a3;
      if (this._mathfield)
        return ((_a3 = this._mathfield.model.at(offset)) == null ? void 0 : _a3.treeDepth) - 2;
      return 0;
    }
    /**
     * The last valid offset.
     * @category Selection
     */
    get lastOffset() {
      var _a3, _b3;
      return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.model.lastOffset) != null ? _b3 : -1;
    }
  };
  var MathfieldElement = _MathfieldElement;
  MathfieldElement.version = "0.91.2";
  MathfieldElement._fontsDirectory = "./fonts";
  MathfieldElement._soundsDirectory = "./sounds";
  /**
   * When a key on the virtual keyboard is pressed, produce a short haptic
   * feedback, if the device supports it.
   */
  MathfieldElement.keypressVibration = true;
  MathfieldElement._keypressSound = {
    spacebar: "keypress-spacebar.wav",
    return: "keypress-return.wav",
    delete: "keypress-delete.wav",
    default: "keypress-standard.wav"
  };
  /**
   * Sound played to provide feedback when a command has no effect, for example
   * when pressing the spacebar at the root level.
   *
   * The property is either:
   * - a string, the name of an audio file in the `soundsDirectory` directory
   * - null to turn off the sound
   */
  MathfieldElement._plonkSound = "plonk.wav";
  /** @internal */
  MathfieldElement.audioBuffers = {};
  /**
   * Support for [Trusted Type](https://w3c.github.io/webappsec-trusted-types/dist/spec/).
   *
   * This optional function will be called before a string of HTML is
   * injected in the DOM, allowing that string to be sanitized
   * according to a policy defined by the host.
   */
  MathfieldElement.createHTML = (x) => x;
  /** @internal */
  MathfieldElement._speechEngineRate = "100%";
  /** @internal */
  MathfieldElement._speechEngineVoice = "Joanna";
  /** @internal */
  MathfieldElement._textToSpeechMarkup = "";
  /** @internal */
  MathfieldElement._textToSpeechRules = "mathlive";
  /** @internal */
  MathfieldElement._textToSpeechRulesOptions = {};
  MathfieldElement.speakHook = defaultSpeakHook;
  MathfieldElement.readAloudHook = defaultReadAloudHook;
  /** @internal */
  MathfieldElement._decimalSeparator = ".";
  /**
   * When using the keyboard to navigate a fraction, the order in which the
   * numerator and navigator are traversed:
   * - "numerator-denominator": first the elements in the numerator, then
   *   the elements in the denominator.
   * - "denominator-numerator": first the elements in the denominator, then
   *   the elements in the numerator. In some East-Asian cultures, fractions
   *   are read and written denominator first ("fnzh"). With this option
   *   the keyboard navigation follows this convention.
   *
   * **Default**: `"numerator-denominator"`
   */
  MathfieldElement.fractionNavigationOrder = "numerator-denominator";
  function toCamelCase(s) {
    return s.toLowerCase().replace(/[^a-zA-Z\d]+(.)/g, (m, c) => c.toUpperCase());
  }
  function getOptionsFromAttributes(mfe) {
    const result = {};
    const attribs = MathfieldElement.optionsAttributes;
    Object.keys(attribs).forEach((x) => {
      if (mfe.hasAttribute(x)) {
        const value = mfe.getAttribute(x);
        if (attribs[x] === "boolean")
          result[toCamelCase(x)] = true;
        else if (attribs[x] === "on/off") {
          if (value === "on")
            result[toCamelCase(x)] = true;
          else if (value === "off")
            result[toCamelCase(x)] = false;
          else
            result[toCamelCase(x)] = void 0;
        } else if (attribs[x] === "number")
          result[toCamelCase(x)] = Number.parseFloat(value != null ? value : "0");
        else
          result[toCamelCase(x)] = value;
      } else if (attribs[x] === "boolean")
        result[toCamelCase(x)] = false;
    });
    return result;
  }
  function isElementInternalsSupported() {
    if (!("ElementInternals" in window) || !HTMLElement.prototype.attachInternals)
      return false;
    if (!("role" in window.ElementInternals.prototype))
      return false;
    return true;
  }
  var mathfield_element_default = MathfieldElement;
  var _a2, _b2, _c, _d;
  if (isBrowser() && !((_a2 = window.customElements) == null ? void 0 : _a2.get("math-field"))) {
    (_c = window[_b2 = Symbol.for("io.cortexjs.mathlive")]) != null ? _c : window[_b2] = {};
    const global = window[Symbol.for("io.cortexjs.mathlive")];
    global.version = "0.91.2";
    window.MathfieldElement = MathfieldElement;
    (_d = window.customElements) == null ? void 0 : _d.define("math-field", MathfieldElement);
  }

  // src/public/mathlive-ssr.ts
  function convertLatexToMarkup(text, options) {
    var _a3;
    options = options != null ? options : {};
    options.mathstyle = (_a3 = options.mathstyle) != null ? _a3 : "displaystyle";
    const globalContext = defaultGlobalContext();
    const root = new Atom("root", globalContext);
    root.body = parseLatex(text, globalContext, {
      parseMode: "math",
      mathstyle: options.mathstyle
    });
    const context = new Context(
      {
        registers: globalContext.registers,
        renderPlaceholder: () => new Box(160, { maxFontSize: 1 })
      },
      {
        fontSize: DEFAULT_FONT_SIZE,
        letterShapeStyle: globalContext.letterShapeStyle
      },
      options.mathstyle
    );
    const box = root.render(context);
    if (!box)
      return "";
    adjustInterAtomSpacing(box, context);
    coalesce(box);
    const wrapper = makeStruts(box, { classes: "ML__mathlive" });
    return wrapper.toMarkup();
  }
  function validateLatex2(s) {
    return validateLatex(s, defaultGlobalContext());
  }
  function convertLatexToMathMl(latex, options = {}) {
    return toMathML(
      parseLatex(latex, defaultGlobalContext(), {
        parseMode: "math",
        args: () => "",
        mathstyle: "displaystyle"
      }),
      options
    );
  }
  function convertLatexToSpeakableText(latex) {
    const atoms = parseLatex(latex, defaultGlobalContext(), {
      parseMode: "math",
      mathstyle: "displaystyle"
    });
    return atomToSpeakableText(atoms);
  }
  var gComputeEngine;
  function serializeMathJsonToLatex(json) {
    var _a3, _b3;
    if (!gComputeEngine) {
      const ComputeEngineCtor = (_a3 = globalThis[Symbol.for("io.cortexjs.compute-engine")]) == null ? void 0 : _a3.ComputeEngine;
      if (ComputeEngineCtor)
        gComputeEngine = new ComputeEngineCtor();
      else {
        console.error(
          `MathLive 0.91.2: The CortexJS Compute Engine library is not available.
        
        Load the library, for example with:
        
        import "https://unpkg.com/@cortex-js/compute-engine?module"`
        );
      }
    }
    return (_b3 = gComputeEngine == null ? void 0 : gComputeEngine.box(json).latex) != null ? _b3 : "";
  }
  function convertLatexToAsciiMath(latex, mode = "math") {
    const context = defaultGlobalContext();
    const root = new Atom("root", context);
    root.body = parseLatex(latex, context, { parseMode: mode });
    return atomToAsciiMath(root);
  }
  function convertAsciiMathToLatex(ascii) {
    return parseMathString(ascii, { format: "ascii-math" })[1];
  }

  // src/addons/auto-render.ts
  function findEndOfMath(delimiter, text, startIndex) {
    let index = startIndex;
    let braceLevel = 0;
    const delimLength = delimiter.length;
    while (index < text.length) {
      const character = text[index];
      if (braceLevel <= 0 && text.slice(index, index + delimLength) === delimiter)
        return index;
      if (character === "\\")
        index++;
      else if (character === "{")
        braceLevel++;
      else if (character === "}")
        braceLevel--;
      index++;
    }
    return -1;
  }
  function splitAtDelimiters(startData, leftDelim, rightDelim, mathstyle, format = "latex") {
    const finalData = [];
    for (const startDatum of startData) {
      if (startDatum.type === "text") {
        const text = startDatum.data;
        let lookingForLeft = true;
        let currIndex = 0;
        let nextIndex;
        nextIndex = text.indexOf(leftDelim);
        if (nextIndex !== -1) {
          currIndex = nextIndex;
          if (currIndex > 0) {
            finalData.push({
              type: "text",
              data: text.slice(0, currIndex)
            });
          }
          lookingForLeft = false;
        }
        let done = false;
        while (!done) {
          if (lookingForLeft) {
            nextIndex = text.indexOf(leftDelim, currIndex);
            if (nextIndex === -1) {
              done = true;
              break;
            }
            if (currIndex !== nextIndex) {
              finalData.push({
                type: "text",
                data: text.slice(currIndex, nextIndex)
              });
            }
            currIndex = nextIndex;
          } else {
            nextIndex = findEndOfMath(
              rightDelim,
              text,
              currIndex + leftDelim.length
            );
            if (nextIndex === -1) {
              done = true;
              break;
            }
            let formula = text.slice(currIndex + leftDelim.length, nextIndex);
            if (format === "ascii-math")
              [, formula] = parseMathString(formula, { format: "ascii-math" });
            finalData.push({
              type: "math",
              data: formula,
              rawData: text.slice(currIndex, nextIndex + rightDelim.length),
              mathstyle
            });
            currIndex = nextIndex + rightDelim.length;
          }
          lookingForLeft = !lookingForLeft;
        }
        if (currIndex < text.length) {
          finalData.push({
            type: "text",
            data: text.slice(currIndex)
          });
        }
      } else
        finalData.push(startDatum);
    }
    return finalData;
  }
  function splitWithDelimiters(text, texDelimiters, mathAsciiDelimiters) {
    let data = [{ type: "text", data: text }];
    if (texDelimiters == null ? void 0 : texDelimiters.inline) {
      texDelimiters.inline.forEach(([openDelim, closeDelim]) => {
        data = splitAtDelimiters(data, openDelim, closeDelim, "textstyle");
      });
    }
    if (texDelimiters == null ? void 0 : texDelimiters.display) {
      texDelimiters.display.forEach(([openDelim, closeDelim]) => {
        data = splitAtDelimiters(data, openDelim, closeDelim, "displaystyle");
      });
    }
    if (mathAsciiDelimiters == null ? void 0 : mathAsciiDelimiters.inline) {
      mathAsciiDelimiters.inline.forEach(([openDelim, closeDelim]) => {
        data = splitAtDelimiters(
          data,
          openDelim,
          closeDelim,
          "textstyle",
          "ascii-math"
        );
      });
    }
    if (mathAsciiDelimiters == null ? void 0 : mathAsciiDelimiters.display) {
      mathAsciiDelimiters.display.forEach(([openDelim, closeDelim]) => {
        data = splitAtDelimiters(
          data,
          openDelim,
          closeDelim,
          "displaystyle",
          "ascii-math"
        );
      });
    }
    return data;
  }
  function createMathMLNode(latex, options) {
    const span = document.createElement("span");
    try {
      const html = "<math xmlns='http://www.w3.org/1998/Math/MathML'>" + options.renderToMathML(latex) + "</math>";
      span.innerHTML = window.MathfieldElement.createHTML(html);
    } catch (error) {
      console.error(
        `MathLive 0.91.2:  Could not convert "${latex}"' to MathML with ${error}`
      );
      span.textContent = latex;
    }
    span.className = "ML__sr-only";
    return span;
  }
  function createMarkupNode(text, options, mathstyle, createNodeOnFailure) {
    try {
      const html = options.renderToMarkup(text, {
        mathstyle,
        format: "html"
      });
      const element = document.createElement(
        mathstyle === "displaystyle" ? "div" : "span"
      );
      element.setAttribute("aria-hidden", "true");
      element.innerHTML = window.MathfieldElement.createHTML(html);
      return element;
    } catch (error) {
      console.error("Could not parse'" + text + "' with ", error);
      if (createNodeOnFailure)
        return document.createTextNode(text);
    }
    return null;
  }
  function createAccessibleMarkupPair(latex, mathstyle, options, createNodeOnFailure) {
    var _a3;
    const markupNode = createMarkupNode(
      latex,
      options,
      mathstyle ? mathstyle : "displaystyle",
      createNodeOnFailure
    );
    const accessibleContent = (_a3 = options.renderAccessibleContent) != null ? _a3 : "";
    if (markupNode && /\b(mathml|speakable-text)\b/i.test(accessibleContent)) {
      const fragment = document.createElement("span");
      if (/\bmathml\b/i.test(accessibleContent) && options.renderToMathML)
        fragment.append(createMathMLNode(latex, options));
      if (/\bspeakable-text\b/i.test(accessibleContent) && options.renderToSpeakableText) {
        const span = document.createElement("span");
        const html = options.renderToSpeakableText(latex);
        span.innerHTML = window.MathfieldElement.createHTML(html);
        span.className = "ML__sr-only";
        fragment.append(span);
      }
      fragment.append(markupNode);
      return fragment;
    }
    return markupNode;
  }
  function scanText2(text, options) {
    var _a3, _b3, _c2;
    let fragment = null;
    if (((_a3 = options.TeX) == null ? void 0 : _a3.processEnvironments) && /^\s*\\begin/.test(text)) {
      fragment = document.createDocumentFragment();
      const node = createAccessibleMarkupPair(text, "", options, true);
      if (node)
        fragment.appendChild(node);
    } else {
      if (!text.trim())
        return null;
      const data = splitWithDelimiters(
        text,
        (_b3 = options.TeX) == null ? void 0 : _b3.delimiters,
        (_c2 = options.asciiMath) == null ? void 0 : _c2.delimiters
      );
      if (data.length === 1 && data[0].type === "text") {
        return null;
      }
      fragment = document.createDocumentFragment();
      for (const datum of data) {
        if (datum.type === "text")
          fragment.appendChild(document.createTextNode(datum.data));
        else {
          const node = createAccessibleMarkupPair(
            datum.data,
            datum.mathstyle === "textstyle" ? "textstyle" : "displaystyle",
            options,
            true
          );
          if (node)
            fragment.appendChild(node);
        }
      }
    }
    return fragment;
  }
  function scanElement(element, options) {
    var _a3, _b3, _c2, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
    if (element.childNodes.length === 1 && element.childNodes[0].nodeType === 3) {
      const text = (_a3 = element.childNodes[0].textContent) != null ? _a3 : "";
      if (((_b3 = options.TeX) == null ? void 0 : _b3.processEnvironments) && /^\s*\\begin/.test(text)) {
        element.textContent = "";
        const node = createAccessibleMarkupPair(text, "", options, true);
        if (node)
          element.append(node);
        return;
      }
      const data = splitWithDelimiters(
        text,
        (_c2 = options.TeX) == null ? void 0 : _c2.delimiters,
        (_d2 = options.asciiMath) == null ? void 0 : _d2.delimiters
      );
      if (data.length === 1 && data[0].type === "math") {
        element.textContent = "";
        const node = createAccessibleMarkupPair(
          data[0].data,
          data[0].mathstyle === "textstyle" ? "textstyle" : "displaystyle",
          options,
          true
        );
        if (node)
          element.append(node);
        return;
      }
      if (data.length === 1 && data[0].type === "text") {
        return;
      }
    }
    for (let i = element.childNodes.length - 1; i >= 0; i--) {
      const childNode = element.childNodes[i];
      if (childNode.nodeType === 3) {
        const frag = scanText2((_e = childNode.textContent) != null ? _e : "", options);
        if (frag) {
          i += frag.childNodes.length - 1;
          childNode.replaceWith(frag);
        }
      } else if (childNode.nodeType === 1) {
        const el = childNode;
        const tag = childNode.nodeName.toLowerCase();
        if (tag === "script") {
          const scriptNode = childNode;
          let textContent = void 0;
          if ((_f = options.processScriptTypePattern) == null ? void 0 : _f.test(scriptNode.type))
            textContent = (_g = scriptNode.textContent) != null ? _g : "";
          else if ((_h = options.processMathJSONScriptTypePattern) == null ? void 0 : _h.test(scriptNode.type)) {
            try {
              textContent = (_j = options.serializeToLatex) == null ? void 0 : _j.call(
                options,
                JSON.parse((_i = scriptNode.textContent) != null ? _i : "")
              );
            } catch (e) {
              console.error(e);
            }
          }
          if (textContent) {
            let style = "displaystyle";
            for (const l of scriptNode.type.split(";")) {
              const [key, value] = l.toLowerCase().split("=");
              if (key.trim() === "mode")
                style = value.trim() === "display" ? "displaystyle" : "textstyle";
            }
            const span = createAccessibleMarkupPair(
              textContent,
              style,
              options,
              true
            );
            if (span)
              scriptNode.parentNode.replaceChild(span, scriptNode);
          }
        } else {
          const shouldRender = ((_l = (_k = options.processClassPattern) == null ? void 0 : _k.test(el.className)) != null ? _l : false) || !(((_n = (_m = options.skipTags) == null ? void 0 : _m.includes(tag)) != null ? _n : false) || ((_p = (_o = options.ignoreClassPattern) == null ? void 0 : _o.test(el.className)) != null ? _p : false));
          if (shouldRender) {
            if (element.childNodes.length === 1 && element.childNodes[0].nodeType === 3) {
              const formula = element.textContent;
              element.textContent = "";
              const node = createAccessibleMarkupPair(
                formula != null ? formula : "",
                "displaystyle",
                options,
                true
              );
              if (node)
                element.append(node);
            } else
              scanElement(el, options);
          }
        }
      }
    }
  }
  var DEFAULT_AUTO_RENDER_OPTIONS = {
    // Name of tags whose content will not be scanned for math delimiters
    skipTags: [
      "math-field",
      "noscript",
      "style",
      "textarea",
      "pre",
      "code",
      "annotation",
      "annotation-xml"
    ],
    // <script> tags of the following types will be processed. Others, ignored.
    processScriptType: "math/tex",
    // <script> tag with this type will be processed as MathJSON
    processMathJSONScriptType: "math/json",
    // Regex pattern of the class name of elements whose contents should not
    // be processed
    ignoreClass: "tex2jax_ignore",
    // Regex pattern of the class name of elements whose contents should
    // be processed when they appear inside ones that are ignored.
    processClass: "tex2jax_process",
    // Indicate the format to use to render accessible content
    renderAccessibleContent: "mathml",
    asciiMath: {
      delimiters: {
        display: [
          ["`", "`"]
          // ASCII Math delimiters
        ]
      }
    },
    TeX: {
      processEnvironments: true,
      delimiters: {
        inline: [["\\(", "\\)"]],
        display: [
          ["$$", "$$"],
          ["\\[", "\\]"]
        ]
      }
    }
  };
  function autoRenderMathInElement(element, options) {
    var _a3, _b3, _c2, _d2;
    try {
      const optionsPrivate = __spreadValues(__spreadValues({}, DEFAULT_AUTO_RENDER_OPTIONS), options);
      optionsPrivate.ignoreClassPattern = new RegExp(
        (_a3 = optionsPrivate.ignoreClass) != null ? _a3 : ""
      );
      optionsPrivate.processClassPattern = new RegExp(
        (_b3 = optionsPrivate.processClass) != null ? _b3 : ""
      );
      optionsPrivate.processScriptTypePattern = new RegExp(
        (_c2 = optionsPrivate.processScriptType) != null ? _c2 : ""
      );
      optionsPrivate.processMathJSONScriptTypePattern = new RegExp(
        (_d2 = optionsPrivate.processMathJSONScriptType) != null ? _d2 : ""
      );
      requestAnimationFrame(() => void loadFonts());
      inject(
        null,
        core_default,
        hashCode(core_default).toString(36)
      );
      scanElement(element, optionsPrivate);
    } catch (error) {
      if (error instanceof Error)
        console.error("renderMathInElement(): " + error.message);
      else {
        console.error(
          "renderMathInElement(): Could not render math for element",
          element
        );
      }
    }
  }

  // src/virtual-keyboard/commands.ts
  function switchKeyboardLayer(layerName) {
    const keyboard = VirtualKeyboard.singleton;
    keyboard.show();
    hideVariantsPanel();
    const layers = keyboard.element.querySelectorAll(".MLK__layer");
    let found = false;
    for (const layer of layers) {
      if (layer.dataset.layer === layerName) {
        found = true;
        break;
      }
    }
    if (found) {
      for (const layer of layers) {
        if (layer.dataset.layer === layerName)
          layer.classList.add("is-visible");
        else
          layer.classList.remove("is-visible");
      }
    }
    keyboard.render();
    keyboard.focus();
    return true;
  }
  function toggleVirtualKeyboard() {
    const kbd = window.mathVirtualKeyboard;
    if (kbd.visible)
      kbd.hide({ animate: true });
    else
      kbd.show({ animate: true });
    return false;
  }
  register2(
    {
      switchKeyboardLayer,
      toggleVirtualKeyboard,
      hideVirtualKeyboard: () => {
        window.mathVirtualKeyboard.hide({ animate: true });
        return false;
      },
      showVirtualKeyboard: () => {
        window.mathVirtualKeyboard.show({ animate: true });
        return false;
      }
    },
    { target: "virtual-keyboard" }
  );

  // src/mathlive.ts
  function globalMathLive() {
    var _a3, _b3;
    (_b3 = globalThis[_a3 = Symbol.for("io.cortexjs.mathlive")]) != null ? _b3 : globalThis[_a3] = {};
    return globalThis[Symbol.for("io.cortexjs.mathlive")];
  }
  function makeSharedVirtualKeyboard() {
    console.warn(
      `%cMathLive 0.91.2: %cmakeSharedVirtualKeyboard() is deprecated. 
    Use \`window.mathVirtualKeyboard\` to access the virtual keyboard instance.
    See https://cortexjs.io/mathlive/changelog/ for details.`,
      "color:#12b; font-size: 1.1rem",
      "color:#db1111; font-size: 1.1rem"
    );
    return window.mathVirtualKeyboard;
  }
  function renderMathInDocument(options) {
    renderMathInElement(document.body, options);
  }
  function getElement(element) {
    if (typeof element === "string") {
      const result = document.getElementById(element);
      if (result === null)
        throw new Error(`The element with ID "${element}" could not be found.`);
      return result;
    }
    return typeof element === "string" ? null : element;
  }
  function renderMathInElement(element, options) {
    var _a3, _b3, _c2, _d2;
    const el = getElement(element);
    if (!el)
      return;
    const optionsPrivate = options != null ? options : {};
    (_a3 = optionsPrivate.renderToMarkup) != null ? _a3 : optionsPrivate.renderToMarkup = convertLatexToMarkup;
    (_b3 = optionsPrivate.renderToMathML) != null ? _b3 : optionsPrivate.renderToMathML = convertLatexToMathMl;
    (_c2 = optionsPrivate.renderToSpeakableText) != null ? _c2 : optionsPrivate.renderToSpeakableText = convertLatexToSpeakableText;
    (_d2 = optionsPrivate.serializeToLatex) != null ? _d2 : optionsPrivate.serializeToLatex = serializeMathJsonToLatex;
    autoRenderMathInElement(el, optionsPrivate);
  }
  var version = {
    mathlive: "0.91.2"
  };
  return __toCommonJS(mathlive_exports);
})();
Object.assign(exports, MathLive); Object.defineProperty(exports, '__esModule', { value: true });}));
